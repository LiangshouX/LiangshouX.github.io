<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liangshou</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-20T15:30:39.172Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Liangshou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Java 容器</title>
    <link href="http://example.com/2023/10/20/2023-10-20-%E5%85%B3%E4%BA%8EJava%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2023/10/20/2023-10-20-%E5%85%B3%E4%BA%8EJava%E9%9B%86%E5%90%88/</id>
    <published>2023-10-20T09:13:55.270Z</published>
    <updated>2023-10-20T15:30:39.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java容器概述"><a href="#Java容器概述" class="headerlink" title="Java容器概述"></a>Java容器概述</h1><p>Java中的容器，也就是Java 集合，是一套用于存储和组织数据的对象。容器类提供了一种将多个对象集合在一起的方式，并提供了一组方法来管理和操作这些对象。</p><p>Java容器主要派生自两大接口：<code>Collection</code>接口和<code>Map</code>接口。前者主要用于存放单一元素，后者则主要用于存放键值对。对于<code>Collection</code>接口，其有三个主要的子接口：<code>List</code>接口、<code>Queue</code>接口、<code>Set</code>接口。Java容器的系统结构可参考下图：</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E7%BB%9F.png" alt="java容器系统"></p><blockquote><p>分享来源：<a href="https://www.processon.com/view/616d69c3e0b34d7c7dba91f7?fromnew=1">processon-java集合系统</a>。</p></blockquote><h2 id="List-Set-Queue-Map-概述"><a href="#List-Set-Queue-Map-概述" class="headerlink" title="List, Set, Queue, Map 概述"></a>List, Set, Queue, Map 概述</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List接口是用来处理顺序相关问题的很好的工具，其特点是存储的元素是有序的、可重复的。List接口最常用的实现类包括了 <code>LinkedList</code>、<code>ArrayList</code>、<code>Stack</code>以及<code>Vector</code>等，其中<code>Stack</code>类是<code>Vector</code>类的子类。</p><p>List的JDK源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; </span><br></pre></td></tr></table></figure><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><ul><li><p><code>ArrayList</code>：<code>ArrayList</code>是一个可以<strong>动态增长</strong>的数组，其底层数据结构是 <code>Object[]</code>数组，在JDK源码中有如下的定义（已省略javadoc）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br></pre></td></tr></table></figure><blockquote><p>在Java中，<code>transient</code> 关键字用于修饰类的<strong>实例变量</strong>。当一个实例变量被标记为 <code>transient</code> 时，它告诉Java的序列化机制不要将该变量的值持久化（即不要将其写入对象的序列化表示中），而只序列化对象的其他部分。这在对象序列化和反序列化时非常有用。</p></blockquote></li><li><p><code>LinkedList</code>：该类继承了<code>AbstractSequentialList</code>抽象类，底层的数据结构是双向链表，使用泛型定义链表节点，JDK源码（JDK17）为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Vector</code>：该类的底层数据结构同样为<code>Object[]</code>数组，JDK源码中的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br></pre></td></tr></table></figure></li><li><p><code>Stack</code>：继承了<code>Vector</code>类，底层的数据结构与<code>Vector</code>一致。</p></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set在数学中是集合的意思，<code>Set</code>接口组织数据的特点是<strong>注重独一无二的性质</strong>，存储的元素不可重复的。</p><h4 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><ul><li><p><code>HashSet</code>：HashSet 的特点是<strong>无序性</strong>和<strong>唯一性</strong>，底层采用了<code>HashMap</code>来存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li><li><p><code>LinkedHashSet</code>：HashSet的子类，内部实现通过<code>LinkedHashMap</code>，通过<code>supper</code>调用父类的构造方法，HashSet中定义的源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>TreeSet</code>：区别于<code>HashSet</code>，TreeSet的特点是<strong>有序</strong>且<strong>唯一</strong>的，底层采用了红黑树的数据结构实现。实际上，JDK17中，TreeSet类实现的是<code>NavigableMap</code> 接口，而后者继承了<code>SortedMap</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">    </span><br><span class="line"><span class="comment">// NavigableSet接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">SortedMap</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue（队列）中，按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><h4 id="底层数据结构-2"><a href="#底层数据结构-2" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><ul><li><code>PriorityQueue</code>：底层是使用 <code>Object[]</code> 数组来实现小顶堆。</li><li><code>DelayQueue</code>：<code>PriorityQueue</code>。</li><li><code>ArrayDeque</code>:：可扩容动态双向数组。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>使用键值对（key-value）存储，类似于数学上的函数的一个key对应唯一value的关系，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p><h4 id="底层数据结构-3"><a href="#底层数据结构-3" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p><p><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</p><p><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java容器概述&quot;&gt;&lt;a href=&quot;#Java容器概述&quot; class=&quot;headerlink&quot; title=&quot;Java容器概述&quot;&gt;&lt;/a&gt;Java容器概述&lt;/h1&gt;&lt;p&gt;Java中的容器，也就是Java 集合，是一套用于存储和组织数据的对象。容器类提供了一种将多</summary>
      
    
    
    
    <category term="Java手账本" scheme="http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 常识？我咋不知道</title>
    <link href="http://example.com/2023/10/19/2023-10-19-%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%E5%B8%B8%E8%AF%86/"/>
    <id>http://example.com/2023/10/19/2023-10-19-%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%E5%B8%B8%E8%AF%86/</id>
    <published>2023-10-19T15:51:41.429Z</published>
    <updated>2023-10-20T08:56:14.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-SE，Java-EE-Java-ME？"><a href="#Java-SE，Java-EE-Java-ME？" class="headerlink" title="Java SE，Java EE &amp; Java ME？"></a>Java SE，Java EE &amp; Java ME？</h1><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/Java技术平台关系图.png" alt="Java技术平台关系图" style="zoom:67%;" /><p>有没有想过，同样是Java，会不会存在不同的版本 or anything else？事实上，为了使软件开发人员、服务提供商和设备生产商可以针对特定的市场进行开发，SUN公司将Java划分为三个技术平台：</p><ul><li>Java SE：Standard Edition（标准版）</li><li>Java EE：Enterprise Edition（商业版）</li><li>Java ME：Micro Edition（小型版）</li></ul><h2 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h2><p>全称为Java Platform Standard Edition，这是Java 平台标准版，包含标准的 JVM和标准库，更具体地说，包括了 Java 核心的类库，如集合、IO、数据库连接以及网络编程等。</p><p>JavaSE 是Java 编程语言的基础，三个核心平台中的核心部分，Java EE 和 Java ME 都是从 JavaSE的基础上发展而来的 </p><p>JavaSE是为开发<strong>普通桌面</strong>和<strong>商务应用程序</strong>提供的解决方案。</p><h2 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h2><p>全称是 Java Platform Enterprise Edition，Java 平台企业版，建立在 Java SE 的基础上，并加入了大量的 API 和库，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。</p><p>Java EE是进一步学习Web应用所必须的，Spring等框架都是Java EE开源生态系统的一部分。</p><p>JavaEE 是为开发<strong>企业级应用程序</strong>提供的解决方案。 </p><h2 id="Java-ME"><a href="#Java-ME" class="headerlink" title="Java ME"></a>Java ME</h2><p>全称是 Java Platform Micro Edition，Java平台小型版，是一个针对 <strong>嵌入式设备</strong> 的 “瘦身版”，要用于小型数字电子设备上软件程序的开发，例如家用电器的智能化、联网功能等。</p><p>此外，JavaME提供了HTTP等高级Internet协议，使移动电话能以Client&#x2F; Server方式直接访问 Internet的全部信息，提供最效率的无线交流。</p><p>JavaME 是为开发电子消费产品和嵌入式设备提供的解决方案。然而Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，只需要了解即可。</p><h1 id="JDK，JVM-JRE？"><a href="#JDK，JVM-JRE？" class="headerlink" title="JDK，JVM &amp; JRE？"></a>JDK，JVM &amp; JRE？</h1><blockquote><p>Java文档官网：<a href="https://docs.oracle.com/en/java/index.html">https://docs.oracle.com/en/java/index.html</a></p></blockquote><p>立即推(张宇老师口吻)：这题我会！事实上，这个问题倒是比较容易理解。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/jdk&jvm.png" alt="jdk&jvm" style="zoom:67%;" /><blockquote><p>详细信息可参考：<a href="https://www.oracle.com/java/technologies/platform-glance.html">官方架构图</a>。</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/java8-conceptual-design.jpg" alt="img"></p></blockquote><h2 id="JVM-JIT"><a href="#JVM-JIT" class="headerlink" title="JVM &amp; JIT"></a>JVM &amp; JIT</h2><p>JVM 即 Java 虚拟机，是运⾏ Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。</p><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时⽐较⾼效</p><p>⽽且，由于字节码并不针对⼀种特定的机器，因此，Java 程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。</p></blockquote><p>Java 程序从源代码到编译运⾏⼀般需要经历以下的过程：</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/Java%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java源码编译运行过程"></p><blockquote><p>事实上，可以运行在 Java 虚拟机上的语言除了 Java外还有很多，如Groovy(.groovy)、Kotlin(.kt)、JRuby(.rb)、Clojure(.clj)等，它们编译运行的过程大致相似，经过对应的编译器编译为 .class字节码文件。</p></blockquote><p>这里需要格外注意的是 <code>.class --&gt; 机器码</code> 这⼀步。在这⼀步 JVM 类加载器⾸先加载字节码⽂件，然后通过 <strong>解释器</strong> 逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐较慢。⽽且，有些⽅法和代码块是经常需要被调⽤的(也就是所谓的热点代码)，所以后⾯引进了 JIT （Just in Time Compilation）编译器，⽽ JIT 属于运⾏时编译。当 JIT 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。⽽我们知道，机器码的运⾏效率肯定是⾼于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><p>于是引入 JIT 后，程序从源代码到编译运⾏经历的过程具体为：</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/Java%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B-JIT.png" alt="Java源码编译运行过程-JIT"></p><h2 id="JDK-JRE"><a href="#JDK-JRE" class="headerlink" title="JDK &amp; JRE"></a>JDK &amp; JRE</h2><p>JDK 是 Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</p><p>如果只是为了运⾏⼀下 Java 程序的话，只需要安装 JRE 就可以了。如果需要进⾏⼀些Java 编程⽅⾯的⼯作，那么就需要安装 JDK 了。</p><blockquote><p>这也不是绝对的。有时，即使不打算在计算机上进⾏任何 Java 开发，仍然需要安装 JDK。例如，如果要使⽤ JSP 部署 Web 应⽤程序，那么从技术上讲，只是在应⽤程序服务器中运⾏ Java 程序。</p><p>但是因为应⽤程序服务器会将 JSP 转换为 Java servlet，并且需要使⽤ JDK 来编译 servlet，还是需要安装JDK</p></blockquote><h1 id="编译与解释并存？"><a href="#编译与解释并存？" class="headerlink" title="编译与解释并存？"></a>编译与解释并存？</h1><p>参考JVM部分，可知 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p><h1 id="AOT-JIT？"><a href="#AOT-JIT？" class="headerlink" title="AOT &amp; JIT？"></a>AOT &amp; JIT？</h1><blockquote><p>可参考：<a href="https://www.modb.pro/db/190497">理解Java的JIT和AOT</a>，<a href="https://juejin.cn/post/7184712312983388217#heading-0">JIT v.s. AOT in Java</a>。</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/jit-vs-aot.png" alt="jit-vs-aot"> </p></blockquote><p>JIT是Just-In-Time的首字母缩写，指程序<strong>运行期间</strong>发生的编译行为。</p><ul><li>JIT多伴随解释器，因为解释型语言是按行解释执行，JIT将“常用”功能编译为机器码，需要时直接执行，减少解释时间；</li><li><em>例如：Python(pypy)，新版Javascript、Ruby、Php解释器；</em></li></ul><p>AOT是Ahead-Of-Time的首字母缩写，指程序<strong>运行之前</strong>发生的编译行为。</p><ul><li>对于编译型语言，AOT啥也不是，本身就是先编译后执行，但对于解释型语言，AOT提前“预见”热点功能，并编译为机器码，同样减少解释时间；</li><li><em>例如：C，C++，Rust，Go，Java AOT；</em></li></ul><p>AOP是JDK 9 引入了一种新的编译模式，主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-SE，Java-EE-Java-ME？&quot;&gt;&lt;a href=&quot;#Java-SE，Java-EE-Java-ME？&quot; class=&quot;headerlink&quot; title=&quot;Java SE，Java EE &amp;amp; Java ME？&quot;&gt;&lt;/a&gt;Java SE，</summary>
      
    
    
    
    <category term="Java手账本" scheme="http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>链表刷题—Java版</title>
    <link href="http://example.com/2023/10/17/2023-10-17-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E2%80%94Java%E7%89%88/"/>
    <id>http://example.com/2023/10/17/2023-10-17-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E2%80%94Java%E7%89%88/</id>
    <published>2023-10-17T12:07:36.377Z</published>
    <updated>2023-10-20T06:44:40.896Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>链表是通过<strong>指针</strong>串联在一起的<strong>线性结构</strong>，指针是其中的一个重要部分。简单了解指针的概念：</p><blockquote><p>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。</p></blockquote><p>就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var-name</span><br></pre></td></tr></table></figure><p>在C&#x2F;C++等语言中，都显式地定义了指针用于直接访问内存地址的机制，然而学习 Java 的人或多或少都听说过“Java没有指针”。</p><p>Java的设计目标之一是提供一种更安全和易于学习的编程语言。为了实现这一目标，Java采用了一种自动内存管理的方式，即垃圾回收机制。Java引入了<strong>引用</strong>（reference）的概念，但不允许直接访问内存地址。这意味着在Java中，并不能像C或C++中那样使用指针来操作内存。这种设计决策有助于减少内存管理错误和提高安全性。关于更多Java指针的理解，可参考 <a href="https://zhuanlan.zhihu.com/p/131612029">知乎专栏—Java真的没有“指针”吗？</a>。</p><p>关于链表的基础理论，本文不再赘述，可参考：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录-链表基础理论</a>。</p><p>Java 链表的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><blockquote><p> 题目链接：</p><p> <a href="https://leetcode.cn/problems/design-linked-list/">LC707. 设计链表</a></p></blockquote><h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><blockquote><p>题目链接：</p><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">LC203. 移除链表元素</a>;</p><p><a href="https://www.nowcoder.com/share/jump/8214310031697562609849">BM9删除链表的倒数第n个节点</a></p></blockquote><p>因为是单链表，从前往后遍历，假如当前访问结点的 val 是要移除的，无法很好地定位到当前节点的前一个节点；另外就是需要考虑头结点可能为需要移除的结点的情况。综合来看，可以有三种移除方式：不设置 pre 节点和虚拟节点、仅设置pre节点、同时设置pre节点和虚拟节点。</p><h2 id="LC203"><a href="#LC203" class="headerlink" title="LC203"></a>LC203</h2><h3 id="不设置-pre-节点和-虚拟节点"><a href="#不设置-pre-节点和-虚拟节点" class="headerlink" title="不设置 pre 节点和 虚拟节点"></a>不设置 pre 节点和 虚拟节点</h3><p>分两步考虑：首先处理掉头结点需要移除的情况，之后判断 curr.next 节点是否需要移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            <span class="comment">// 处理头结点要移除的情况</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// curr的下一个节点</span></span><br><span class="line">            <span class="keyword">while</span>(curr.next != <span class="literal">null</span> &amp;&amp; curr.next.val == val)&#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仅设置pre节点"><a href="#仅设置pre节点" class="headerlink" title="仅设置pre节点"></a>仅设置pre节点</h3><p>同上一种方式，首先处理掉头结点需要移除的情况，之后使用 pre 节点指向 curr 的前一个节点，遍历中只需要关注 curr 节点的 val。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            <span class="comment">// 处理头结点要移除的情况</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == val)&#123;</span><br><span class="line">                pre.next = curr.next;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre = pre.next;              </span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同时设置-pre-节点和-虚拟节点"><a href="#同时设置-pre-节点和-虚拟节点" class="headerlink" title="同时设置 pre 节点和 虚拟节点"></a>同时设置 pre 节点和 虚拟节点</h3><p>这样做的好处在于，移除头结点和普通节点的逻辑可以统一，即原链表的所有节点就都可以按照统一的方式进行移除，使用 dummy.next 定位头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 设置虚拟节点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(curr.val == val)&#123;</span><br><span class="line">               pre.next = curr.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               pre = curr;</span><br><span class="line">           &#125;</span><br><span class="line">           curr = curr.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM9"><a href="#BM9" class="headerlink" title="BM9"></a>BM9</h2><h3 id="index定位"><a href="#index定位" class="headerlink" title="index定位"></a>index定位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定链表的长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> len - n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定位到要移除的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 向前移动 first 指针，使 first和 second 之间的间隔为n个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时移动 first 和 second</span></span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h1><blockquote><p>题目链接：</p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">LC206 反转链表</a>。</p></blockquote><p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p><p>接下来，就是循环走以上代码逻辑了，继续移动pre和cur指针。</p><p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;链表是通过&lt;strong&gt;指针&lt;/strong&gt;串联在一起的&lt;strong&gt;线性结构&lt;/strong&gt;，指针是其中</summary>
      
    
    
    
    <category term="刷题日记" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="NowCoder" scheme="http://example.com/tags/NowCoder/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL—— 基础理论概念</title>
    <link href="http://example.com/2023/10/17/2023-10-17-MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/10/17/2023-10-17-MySQL%E5%9F%BA%E7%A1%80/</id>
    <published>2023-10-17T01:01:41.415Z</published>
    <updated>2023-10-17T03:57:40.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h1><h2 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1. 数据库相关概念"></a>1. 数据库相关概念</h2><p>首先辨析三个概念：数据库、数据库管理系统、SQL</p><table><thead><tr><th>名称</th><th>含义</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>存储数据的仓库，数据是有组织地进行存储</td><td>DataBase(DB)</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System(DBMS)</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong></td><td>Structured Query Language(SQL)</td></tr></tbody></table><p>各大主流 DBMS 的排名参考 <a href="https://db-engines.com/en/ranking">DB-Engines Ranking</a>，</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231017092505034.png" alt="image-20231017092505034"></p><ul><li>Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。</li><li>MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。</li><li>SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。</li><li>PostgreSQL：开源免费的中小型数据库。</li><li>DB2：IBM公司的大型收费数据库产品。</li><li>SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。</li></ul><p>而不论我们使用的是上面的哪一个关系型数据库，最终在操作时，都是使用SQL语言来进行统一操作，因为SQL语言，是操作关系型数据库的 <strong>统一标准</strong> 。</p><h2 id="2-MySQL数据库"><a href="#2-MySQL数据库" class="headerlink" title="2. MySQL数据库"></a>2. MySQL数据库</h2><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/%E4%B8%8B%E8%BD%BD.png" alt="MySQL"></p><p>官网地址： <a href="https://www.mysql.com/">https://www.mysql.com/</a></p><p>MySQL官方提供了两种不同的版本：</p><ul><li><p>社区版本（MySQL Community Server）</p><p>免费， MySQL不提供任何技术支持</p></li><li><p>商业版本（MySQL Enterprise Edition）</p><p>收费，可以使用30天，官方提供技术支持</p></li></ul><p><strong>安装与配置</strong>教程参考 <a href="https://zhuanlan.zhihu.com/p/37152572">知乎-smi安装</a>、<a href="https://www.cnblogs.com/GCTTT/p/17321192.html">博客园-压缩包安装</a>。</p><h2 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3. 数据模型"></a>3. 数据模型</h2><h3 id="1-关系型数据库-RDBMS"><a href="#1-关系型数据库-RDBMS" class="headerlink" title="1) 关系型数据库(RDBMS)"></a>1) 关系型数据库(RDBMS)</h3><p>概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p><p>所谓二维表，指的是由行和列组成的表，类似于Excel表格数据，有表头、有列、有行，还可以通过一列关联另外一个表格中的某一列数据。上述的MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。</p><p>特点：</p><ul><li>使用表存储数据，格式统一，便于维护。</li><li>使用SQL语言操作，标准统一，使用方便。</li></ul><h3 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2) 数据模型"></a>2) 数据模型</h3><p>MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构如图:</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231017100042364.png" alt="image-20231017100042364"></p><ul><li>可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。</li><li>可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。</li><li>一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录</li></ul><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong> 。</p><h2 id="1-SQL通用语法"><a href="#1-SQL通用语法" class="headerlink" title="1. SQL通用语法"></a>1. SQL通用语法</h2><ol><li>SQL语句可以单行或多行书写，以分号结尾;</li><li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性;</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写;</li><li>注释：</li><li>单行注释：– 注释内容 或 # 注释内容</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ol><h2 id="2-SQL分类"><a href="#2-SQL分类" class="headerlink" title="2. SQL分类"></a>2. SQL分类</h2><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的</td></tr></tbody></table><h2 id="3-DDL——数据定义语言"><a href="#3-DDL——数据定义语言" class="headerlink" title="3. DDL——数据定义语言"></a>3. DDL——数据定义语言</h2><p>Data Definition Language  数据定义语言，用来定义数据库对象(数据库，表，字段)</p><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ol><li>查询所有数据库</li><li>查询当前数据库</li><li>创建数据库</li><li>删除数据库</li><li>切换数据库</li></ol><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="查询创建"><a href="#查询创建" class="headerlink" title="查询创建"></a>查询创建</h4><ol><li>查询当前所有表</li><li>查看指定表结构</li><li>查询指定表的建表语句</li><li>创建表结构</li></ol><h4 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h4><p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><ol><li><p>数值类型</p><table><thead><tr><th>类型</th><th>大小(BYTE)</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>(-128,127)</td><td>…</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2</td><td>(-32768,32768)</td><td>…</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>(-8388608,8388607)</td><td>…</td><td>大整数值</td></tr><tr><td>INT&#x2F;INTEGER</td><td>4</td><td>(-2^31, 2^31-1)</td><td>…</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8</td><td>(-2^63, 2^63-1)</td><td>…</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4</td><td>…</td><td>…</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8</td><td>…</td><td>…</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>依赖于精度M和标度D的值</td><td>…</td><td>小数值</td></tr></tbody></table></li><li><p>字符串类型</p><table><thead><tr><th>类型</th><th>大小(byte)</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINITEXT</td><td>0-255</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65535</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65535</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16777215</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MIDEUMTEXT</td><td>0-16777215</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4294967295</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4294967295</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- 1) 用户名 username ------&gt; 长度不定，最长不会超过50</span><br><span class="line">username varchar(50)</span><br><span class="line"></span><br><span class="line">--- 2) 性别  gender   ------&gt; 存储值，不是男就是女</span><br><span class="line">gender   char(1)</span><br><span class="line"></span><br><span class="line">--- 3) 手机号 phone   ------&gt; 固定长度11（仅限国内移动手机号）</span><br><span class="line">phone    char(11)</span><br></pre></td></tr></table></figure></li><li><p>日期时间类型</p><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>DATA</td><td>3</td><td></td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td></td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td></td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td></td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td></td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table></li></ol><h2 id="4-DML"><a href="#4-DML" class="headerlink" title="4. DML"></a>4. DML</h2><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE）</li><li>删除数据（DELETE）</li></ul><h2 id="5-DQL"><a href="#5-DQL" class="headerlink" title="5. DQL"></a>5. DQL</h2><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。</p><p>查询关键字: SELECT</p><p>在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。</p><h2 id="6-DCL"><a href="#6-DCL" class="headerlink" title="6. DCL"></a>6. DCL</h2><p>DCL英文全称是<strong>Data Control Language</strong>(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="内置函数一览"><a href="#内置函数一览" class="headerlink" title="内置函数一览"></a>内置函数一览</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …sn)</td><td>字符串拼接，将s1，s2，… sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str, N, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><h3 id="演示用例"><a href="#演示用例" class="headerlink" title="演示用例"></a>演示用例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--- concat</span><br><span class="line">select concat(&quot;Hello&quot;, &quot;World&quot;);</span><br><span class="line"></span><br><span class="line">--- lower &amp; upper</span><br><span class="line">select lower(&quot;Hello&quot;);</span><br><span class="line">select upper(&#x27;Hello&#x27;);</span><br><span class="line"></span><br><span class="line">--- lpad &amp; rpad</span><br><span class="line">select lpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line">select rpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">--- trim去除空格</span><br><span class="line">select trim(&#x27; Hello MySQL &#x27;);</span><br><span class="line"></span><br><span class="line">--- substring</span><br><span class="line">select substring(&#x27;Hello MySQL&#x27;,1,5);</span><br></pre></td></tr></table></figure><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><h3 id="内置函数一览-1"><a href="#内置函数一览-1" class="headerlink" title="内置函数一览"></a>内置函数一览</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h3 id="演示用例-1"><a href="#演示用例-1" class="headerlink" title="演示用例"></a>演示用例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--- ceil &amp; floor</span><br><span class="line">select ceil(1.1);</span><br><span class="line">select flooor(1.9);</span><br><span class="line"></span><br><span class="line">--- mod</span><br><span class="line">select mod(7,4);</span><br><span class="line"></span><br><span class="line">--- rand</span><br><span class="line">select rand();</span><br><span class="line"></span><br><span class="line">--- round</span><br><span class="line">select round(3.344, 2);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">通过数据库的函数，生成一个六位数的随机验证码。</span><br><span class="line">思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0</span><br><span class="line">*/</span><br><span class="line">select lpad(round(rand()*1000000 , 0), 6, &#x27;0&#x27;);</span><br></pre></td></tr></table></figure><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL概述&quot;&gt;&lt;a href=&quot;#MySQL概述&quot; class=&quot;headerlink&quot; title=&quot;MySQL概述&quot;&gt;&lt;/a&gt;MySQL概述&lt;/h1&gt;&lt;h2 id=&quot;1-数据库相关概念&quot;&gt;&lt;a href=&quot;#1-数据库相关概念&quot; class=&quot;header</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="后端" scheme="http://example.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java中的栈与队列</title>
    <link href="http://example.com/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2023-10-16T05:12:04.799Z</published>
    <updated>2023-10-20T06:41:20.189Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要记述 Java在实践中如何使用栈，关于栈与队列的基础知识点本文不再赘述，可参考 <a href="http://data.biancheng.net/view/169.html">编程帮-栈</a>、<a href="http://data.biancheng.net/view/300.html">编程帮-队列</a>。</p></blockquote><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="标准库-java-util-Stack-实现"><a href="#标准库-java-util-Stack-实现" class="headerlink" title="标准库 java.util.Stack 实现"></a>标准库 <code>java.util.Stack</code> 实现</h2><p>在 <code>java.util</code> 中封装了 Stack 类，其继承自Vector类，定义了push、pop、peek、empty、search五个操作对Vector进行了扩展，JDK源码（已省去jdoc）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Vector</span>&lt;E&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">push</span><span class="params">(E item)</span> &#123;</span><br><span class="line">        addElement(item);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="type">int</span>     <span class="variable">len</span> <span class="operator">=</span> size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>     <span class="variable">len</span> <span class="operator">=</span> size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1224463164541339165L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Deque接口实现"><a href="#Deque接口实现" class="headerlink" title="Deque接口实现"></a>Deque接口实现</h2><p>在Java中，栈可以使用<code>java.util.Stack</code>类实现，也可以使用 <code>java.util.LinkedList</code> 结合<code>push</code>和<code>pop</code>操作来实现自定义的栈。通常，建议使用 <code>Deque </code>接口中的 <code>LinkedList</code> 实现来代替<code>java.util.Stack</code>，因为后者是基于向量的数据结构，性能较差。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackByDeque</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(top + <span class="string">&quot; &quot;</span> + stack.size());</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，值得注意的是 <code>LinkedList</code> 类。<code>LinkedList</code>是Java中的一个双向链表实现，它继承自<code>AbstractSequentialList</code>类，并实现了<code>List</code>和<code>Deque</code>接口，同时提供了双向链表的功能。JDK中的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    ...</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><code>LinkedList</code> 类有以下的特点：</p><ol><li><strong>双向链表</strong>: <code>LinkedList</code>是基于双向链表数据结构的实现，每个元素都被包装在一个节点中，而每个节点都包含指向前一个节点和后一个节点的引用。这使得在链表中插入和删除元素的操作非常高效，因为只需要调整节点的引用，而不需要移动其他元素。</li><li><strong>实现了List接口</strong>: <code>LinkedList</code>实现了<code>List</code>接口，这意味着它可以像<code>ArrayList</code>一样用于存储有序的元素集合，支持随机访问、按索引插入和删除元素。与<code>ArrayList</code>不同，<code>LinkedList</code>在插入和删除操作上通常更高效，但在随机访问上性能较差。</li><li><strong>实现了Deque接口</strong>: <code>LinkedList</code>还实现了<code>Deque</code>接口，这使得它可以被用作双端队列（double-ended queue）。您可以在队列的前端和后端进行插入和删除操作，支持先进先出（FIFO）和后进先出（LIFO）等不同的数据操作模式。</li><li><strong>适合用于栈和队列</strong>: 由于<code>LinkedList</code>支持双向操作，它特别适合用作栈和队列的基础数据结构。您可以使用<code>push</code>和<code>pop</code>操作来实现栈，使用<code>offer</code>和<code>poll</code>操作来实现队列。</li><li><strong>非线程安全</strong>: 与<code>ArrayList</code>不同，<code>LinkedList</code>是非线程安全的，这意味着在多线程环境下需要进行额外的同步处理，或者使用<code>java.util.concurrent</code>包中的并发数据结构来保证线程安全。</li><li><strong>动态大小</strong>: <code>LinkedList</code>的大小是动态的，它会根据需要动态分配内存。这意味着它可以容纳任意数量的元素，但需要根据实际使用情况分配和释放内存，可能会引入一些内存管理开销。</li></ol><p><code>LinkedList</code>是一个灵活的双向链表实现，适合用于需要频繁插入和删除操作的情况，以及栈和队列等数据结构的实现。但需要注意，对于需要随机访问的情况，<code>ArrayList</code>通常更为高效。</p><h2 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h2><h3 id="1-使用数组"><a href="#1-使用数组" class="headerlink" title="1. 使用数组"></a>1. 使用数组</h3><p>可以使用数组来实现栈，通过维护一个指向栈顶元素的指针（通常称为top），以及数组来存储栈的元素。当进行<code>push</code>和<code>pop</code>操作时，相应地更新栈顶指针和数组元素。这种实现方式的优点是简单，但需要注意数组大小的限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;   <span class="comment">// 栈的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;       <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;   <span class="comment">// 存储元素的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="built_in">this</span>.top = -<span class="number">1</span>; <span class="comment">// 栈开始时为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否已满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈已满，无法入栈&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[++top] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空，无法出栈&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回一个特定的值表示栈为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空，无法查看栈顶元素&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回一个特定的值表示栈为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶元素：&quot;</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出栈元素：&quot;</span> + stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-使用链表"><a href="#2-使用链表" class="headerlink" title="2. 使用链表:"></a>2. 使用链表:</h3><p>类似于使用数组，您可以使用链表来实现栈。链表的头节点可以充当栈顶，而<code>push</code>和<code>pop</code>操作将在链表头部进行。这种实现方式通常不会受到数组大小的限制，并且在动态大小方面更加灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListStack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top; <span class="comment">// 栈顶节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(item);</span><br><span class="line">        newNode.next = top;</span><br><span class="line">        top = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空，无法出栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空，无法查看栈顶元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedListStack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶元素：&quot;</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出栈元素：&quot;</span> + stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-使用单链表节点"><a href="#3-使用单链表节点" class="headerlink" title="3. 使用单链表节点"></a>3. 使用单链表节点</h3><p>如果不需要支持<code>pop</code>操作，只需要实现<code>push</code>和<code>peek</code>，您可以使用单链表节点来创建一个简化的栈。每个节点包含数据和一个指向下一个节点的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedListStack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top; <span class="comment">// 栈顶节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(item);</span><br><span class="line">        newNode.next = top;</span><br><span class="line">        top = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空，无法出栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空，无法查看栈顶元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SingleLinkedListStack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">SingleLinkedListStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶元素：&quot;</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出栈元素：&quot;</span> + stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-使用双链表节点"><a href="#4-使用双链表节点" class="headerlink" title="4. 使用双链表节点"></a>4. 使用双链表节点</h3><p>如果需要支持<code>pop</code>操作和更高效的<code>pop</code>和<code>peek</code>操作，可以使用双链表节点来实现栈。这种实现方式允许从栈顶和栈底执行<code>pop</code>和<code>peek</code>操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListStack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top; <span class="comment">// 栈顶节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; prev;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="literal">null</span>) &#123;</span><br><span class="line">            newNode.next = top;</span><br><span class="line">            top.prev = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        top = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空，无法出栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="literal">null</span>) &#123;</span><br><span class="line">            top.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空，无法查看栈顶元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DoubleLinkedListStack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">DoubleLinkedListStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶元素：&quot;</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出栈元素：&quot;</span> + stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义栈的实现方式可以根据特定需求选择，但需要注意线程安全和性能方面的考虑。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="java-util-Queue-接口实现"><a href="#java-util-Queue-接口实现" class="headerlink" title="java.util.Queue 接口实现"></a><code>java.util.Queue</code> 接口实现</h2><p>Java提供了<code>java.util.Queue</code>接口，是队列的标准接口。可以使用不同的实现类来创建队列，包括：</p><ul><li><code>java.util.LinkedList</code>：基于双向链表的实现，支持先进先出（FIFO）操作。</li><li><code>java.util.PriorityQueue</code>：优先级队列的实现，元素按照优先级顺序排列。</li></ul><p>以下使用<code>java.util.LinkedList</code>来实现队列。<code>offer</code>方法用于将元素入队列，<code>poll</code>方法用于出队列。由于<code>LinkedList</code>实现了<code>Queue</code>接口，可以方便地使用它来实现队列的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueByLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入对列</span></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        queue.offer(<span class="number">2</span>);</span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出队元素： &quot;</span> + queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PriorityQueue</code>是一个优先级队列，它根据元素的优先级来排列队列中的元素。较小的元素具有较高的优先级。使用<code>offer</code>方法入队列，<code>poll</code>方法出队列，优先级较高的元素会首先被出队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueByPriorityQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入对列</span></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        queue.offer(<span class="number">2</span>);</span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出队元素： &quot;</span> + queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-java-util-concurrent-包中的队列"><a href="#使用-java-util-concurrent-包中的队列" class="headerlink" title="使用 java.util.concurrent 包中的队列"></a>使用 <code>java.util.concurrent</code> 包中的队列</h2><p>Java的<code>java.util.concurrent</code>包提供了多线程安全的队列实现，用于多线程环境。一些常见的实现包括：</p><ul><li><code>java.util.concurrent.LinkedBlockingQueue</code>：基于链表的阻塞队列。</li><li><code>java.util.concurrent.ArrayBlockingQueue</code>：基于数组的阻塞队列。</li><li><code>java.util.concurrent.PriorityBlockingQueue</code>：多线程安全的优先级队列。</li></ul><h2 id="自定义队列"><a href="#自定义队列" class="headerlink" title="自定义队列"></a>自定义队列</h2><p>此外，还可以使用数组或链表等数据结构来自定义队列的实现，根据特定需求创建自己的队列类。这通常需要额外的编程工作，但可以满足特定场景的需求。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文总结了Java中栈和队列的几种实现方式:</p><ol><li>栈的实现:<ul><li>使用Java标准库中的Stack类</li><li>使用Deque接口中的LinkedList实现栈操作</li><li>自定义数组栈、链表栈、单链表栈、双链表栈</li></ul></li><li>队列的实现:<ul><li>使用Java标准库中的Queue接口及其实现类LinkedList、PriorityQueue</li><li>使用java.util.concurrent包下的阻塞队列</li><li>自定义使用数组或链表实现的队列</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要记述 Java在实践中如何使用栈，关于栈与队列的基础知识点本文不再赘述，可参考 &lt;a href=&quot;http://data.biancheng.net/view/169.html&quot;&gt;编程帮-栈&lt;/a&gt;、&lt;a href=&quot;http://data</summary>
      
    
    
    
    <category term="Java手账本" scheme="http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo渲染的页面不支持mermaid语法</title>
    <link href="http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/</id>
    <published>2023-10-15T22:09:15.568Z</published>
    <updated>2023-10-15T22:40:11.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mermaid 的介绍和使用请参考  <a href="https://zhuanlan.zhihu.com/p/172635547">这篇文章</a> 和 <a href="https://mermaid.js.org/intro/">官方文档</a>。</p></blockquote><h1 id="hexo渲染的页面不支持mermaid语法问题"><a href="#hexo渲染的页面不支持mermaid语法问题" class="headerlink" title="hexo渲染的页面不支持mermaid语法问题"></a>hexo渲染的页面不支持mermaid语法问题</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在typora编写的Markdown文件能很好地渲染 mermaid 流程图，然而使用 hexo 部署后却不能渲染，只能显示出 mermaid 代码。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>从 <a href="https://hexo.io/plugins/">hexo插件官网</a> 找到对应的插件 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams</a>，参照 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams</a> 官方给出的环境配置方法进行配置。</p><ol><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-mermaid-diagrams</span><br><span class="line">// or</span><br><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><p>同时修改根目录和themes目录下的 <code>_config.yml</code> 文件，加上以下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;7.1.2&quot;</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure></li><li><p>在pug或js中包含mermaid.js</p><p>笔者使用的主题是 pure，在 <code>themes\pure\layout\_commons</code> 路径下的 <code>footer.ejs</code> 中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">  &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><blockquote><p>具体情况请参考 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams官方说明 </a>。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;mermaid 的介绍和使用请参考  &lt;a href=&quot;https://zhuanlan.zhihu.com/p/172635547&quot;&gt;这篇文章&lt;/a&gt; 和 &lt;a href=&quot;https://mermaid.js.org/intro/&quot;&gt;官方文档&lt;</summary>
      
    
    
    
    <category term="随机BUG" scheme="http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
    <category term="mermaid" scheme="http://example.com/tags/mermaid/"/>
    
  </entry>
  
  <entry>
    <title>二叉树基本定义以及遍历方法</title>
    <link href="http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</id>
    <published>2023-10-15T16:52:39.418Z</published>
    <updated>2023-10-20T06:44:51.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自程序员Carl的 <a href="https://programmercarl.com/">代码随想录</a>。</p></blockquote><p>[toc]</p><h1 id="二叉树的基本定义"><a href="#二叉树的基本定义" class="headerlink" title="二叉树的基本定义"></a>二叉树的基本定义</h1><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><p>解题过程中二叉树有两种主要的形式：<strong>满二叉树</strong>和<strong>完全二叉树</strong>。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树，如下图所示。</p><blockquote><p>文章中使用了画图功能，使用方式参考 <a href="https://zhuanlan.zhihu.com/p/172635547">这篇文章</a>， mermaid语法请参考 <a href="https://mermaid.js.org/intro/">官方文档</a>。</p></blockquote><pre class="mermaid">graph TDA-->BA-->CB-->DB-->EC-->FC-->GD-->HD-->IE-->JE-->KF-->LF-->MG-->NG-->O</pre><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。如下面的两个是完全二叉树：</p><pre class="mermaid">graph TDA-->BA-->CB-->DB-->EC-->FC-->GD-->HD-->IE-->J</pre><pre class="mermaid">graph TDA-->BA-->CB-->DB-->EC-->FC-->GD-->HD-->IE-->JE-->K</pre><p>而下面一个就不是完全二叉树：</p><pre class="mermaid">graph TDA-->BA-->CB-->DB-->EC-->FC-->GD-->HD-->IE-->NullE-->K</pre><blockquote><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系</strong></p></blockquote><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>相比于前面介绍的没有数值的树，二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>例如下面这两棵树都是搜索树</p><pre class="mermaid">graph TD10-->610-->166-->36-->916-->1416-->19</pre><pre class="mermaid">graph TD10-->610-->Null6-->36-->9</pre><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。例如：</p><pre class="mermaid">graph TD10-->610-->166-->36-->9</pre><pre class="mermaid">graph TD10-->610-->166-->36-->916-->1416-->19</pre><blockquote><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是$log\ n$，</p><p>注意这里不包括unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表</p></blockquote><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p><p>链式存储比较直观，即给每个节点设置左指针和有指针，分别指向左子树和右子树。</p><p>如何顺序存储呢？其实就是用数组来存储二叉树，顺序存储的方式如图：</p><pre class="mermaid">graph TDa-->ba-->cb-->db-->ec-->fc-->g</pre><p>对应的存储数组为：<code>[a,b,c,d,e,f,g]</code>，下标对应 0-6。</p><p>顺序存储的遍历方式：</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><blockquote><p>注意总结做题的框架！！</p></blockquote><p>关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。</p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候还会介绍到。</p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>在深度优先遍历中：有三个顺序，前中后序遍历。<strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，因此只需要记住： 前中后序指的就是中间节点的位置。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>例如对于下面的图，前中后序遍历的顺序依次是：</p><ul><li>前序（DLR）：abdecfg</li><li>中序（LDR）：dbeafcg</li><li>后序（LRD）：debfgca</li></ul><pre class="mermaid">graph TDa-->ba-->cb-->db-->ec-->fc-->g</pre><p>最后是二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p><p>前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><h2 id="二叉树的代码实现"><a href="#二叉树的代码实现" class="headerlink" title="二叉树的代码实现"></a>二叉树的代码实现</h2><blockquote><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p><p>因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++代码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1><h2 id="递归的三要素"><a href="#递归的三要素" class="headerlink" title="递归的三要素"></a>递归的三要素</h2><p>本部分将介绍前后中序的递归写法。首先确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><h2 id="题目链接及题解"><a href="#题目链接及题解" class="headerlink" title="题目链接及题解"></a>题目链接及题解</h2><ol><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LC144_二叉树的前序遍历</a><ol><li>确定递归函数的参数和返回值。预设代码给出了preorderTraversal函数，其参数为 TreeNode类型的root节点，返回List&lt;Integer&gt;类型。实现递归函数preorder，该函数主要实现对二叉树的遍历，并把遍历结果插入result向量中，返回值为void；参数需要两个：当前的结点和result向量</li><li>确定终止条件：当前结点为 null 时递归终止</li><li>单层递归逻辑：DLR</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定参数：当前节点 和 result List</span></span><br><span class="line">    <span class="comment">// 返回值： void</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单层递归逻辑：DLR</span></span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        preorder(curr.left, result);</span><br><span class="line">        preorder(curr.right, result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LC94_二叉树的中序遍历</a></li></ol><blockquote><p>原理&amp;思路同上一题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRD</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(curr.left, result);</span><br><span class="line">        postorder(curr.right, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LC145_二叉树的后序遍历</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(curr.left, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        inorder(curr.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/share/jump/8214310031697402552220">BM24 二叉树的中序遍历</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] resultArr = result.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(curr.left, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        inorder(curr.right, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/share/jump/8214310031697403236272">BM25 二叉树的后序遍历</a></p><p><a href="https://www.nowcoder.com/share/jump/8214310031697403428551">BM23 二叉树的前序遍历</a></p><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><blockquote><p>见 <a href="https://programmercarl.com/">代码随想录</a>。</p></blockquote><h2 id="迭代法遍历的基本原理"><a href="#迭代法遍历的基本原理" class="headerlink" title="迭代法遍历的基本原理"></a>迭代法遍历的基本原理</h2><blockquote><p>此部分建议细读 <a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">代码随想录-二叉树的迭代遍历</a> 理解迭代遍历的基本原理。</p></blockquote><h2 id="统一迭代方法"><a href="#统一迭代方法" class="headerlink" title="统一迭代方法"></a>统一迭代方法</h2><p>迭代法实现的先中后序，其实风格并不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。</p><p>经过实践会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。</p><p>统一写法的基本思路是：<strong>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记</strong>。</p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">            st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">            st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">            st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">            node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）         </span></span><br><span class="line">                               </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="102二叉树的层序遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 102.二叉树的层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun02</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="literal">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="literal">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ol><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LC102. 二叉树的层序遍历</a>；</li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LC107. 二叉树的层序遍历 II</a>；</li><li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">LC199. 二叉树的右视图</a>；</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文来自程序员Carl的 &lt;a href=&quot;https://programmercarl.com/&quot;&gt;代码随想录&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;二叉树的基本定义&quot;&gt;&lt;a href=&quot;#二叉树</summary>
      
    
    
    
    <category term="刷题日记" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="NowCoder" scheme="http://example.com/tags/NowCoder/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/10/15/2023-10-15-hello-world/"/>
    <id>http://example.com/2023/10/15/2023-10-15-hello-world/</id>
    <published>2023-10-14T16:08:56.164Z</published>
    <updated>2023-10-14T16:04:19.185Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建GitHub Page-Jekyll篇</title>
    <link href="http://example.com/2023/10/13/2023-10-13-%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/"/>
    <id>http://example.com/2023/10/13/2023-10-13-%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/</id>
    <published>2023-10-13T09:25:37.729Z</published>
    <updated>2023-10-20T06:46:27.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote><p>emoji 好看吗？<a href="https://sunhwee.com/posts/a927e90e.html#toc-heading-3">这里 </a>有很多哦</p></blockquote><p>应该没有一个开发人员不向往有一个自己的个人网页吧？:smirk: </p><p>这个主页怎么搭建呢？事实上，网络上有很多将搭建个人博客网站的项目，这样当然是好的，可是似乎需要自己搞一台服务器啊？如果服务器过期了，网站是不是就404了呢？:thinking: </p><p>那能不能不用自己租服务器，快乐当白嫖怪呢？GitHub表示：宝宝，还没想起来我吗？:triumph::kissing_heart:</p><p>不会前端咋办？当然是本着<strong>将白嫖进行到底</strong>的原则啦！看这里:point_right: <a href="http://jekyllthemes.org/">Jekyll 模板</a>:point_left:。</p><h2 id="二、Windows环境配置"><a href="#二、Windows环境配置" class="headerlink" title="二、Windows环境配置"></a>二、Windows环境配置</h2><ul><li>Ruby (ruby -v)</li><li>RubyGems (gem -v)</li><li>Gcc &amp; make (gcc -v | g++ -v | make -v )</li><li>Git (git –version)</li></ul><h3 id="配置Gcc、make环境"><a href="#配置Gcc、make环境" class="headerlink" title="配置Gcc、make环境"></a>配置Gcc、make环境</h3><blockquote><p>参考：</p><ol><li><a href="https://blog.csdn.net/qq_42544728/article/details/128037835">Gcc、g++安装</a>；</li><li><a href="https://tehub.com/a/aCYp1uw0tG">make安装</a>。</li></ol></blockquote><h3 id="安装-Ruby-和-Jekyll"><a href="#安装-Ruby-和-Jekyll" class="headerlink" title="安装 Ruby 和 Jekyll"></a>安装 Ruby 和 Jekyll</h3><blockquote><p>参考 <a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a> 。</p></blockquote><h4 id="通过-RubyInstaller-安装"><a href="#通过-RubyInstaller-安装" class="headerlink" title="通过 RubyInstaller 安装"></a>通过 RubyInstaller 安装</h4><p>Windows上安装Ruby和Jekyll最简单的方法是 <a href="https://rubyinstaller.org/">RubyInstaller</a>，RubyInstaller是一个基于windows的比较完备的安装程序，包括Ruby语言、执行环境、重要文档等等。</p><p>官方配置中介绍的是 RubyInstaller-2.4及更新版本，直接选择最新的安装包。</p><p>详细步骤：</p><ol><li><p>从 <a href="https://rubyinstaller.org/downloads/">RubyInstaller Downloads</a> 下载并安装 Ruby+Devkit 版本。使用默认选项进行安装；</p></li><li><p>在安装向导的最后阶段运行 <code>ridk install</code> 步骤。这是安装带有本地扩展的 gem 所需要的。可以在 <a href="https://github.com/oneclick/rubyinstaller2#using-the-installer-on-a-target-system">RubyInstaller Documentation</a> 中找到更多相关信息。从选项中选择 <code>MSYS2 and MINGW development tool chain</code> ；</p></li><li><p>从开始菜单打开一个新的命令提示窗口，这样对 PATH 环境变量的更改就会生效。使用命令 <code>gem Install Jekyll Bundler</code> 安装Jekyll和Bundler；</p><blockquote><p>注意：此处需将 Ruby gem的源换回国内源，<a href="https://mirrors.tuna.tsinghua.edu.cn/help/rubygems/">清华镜像源操作方法</a>。</p></blockquote></li><li><p>查看Jekyll 是否正确安装：<code>jekyll -v</code>；</p></li></ol><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 55%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013174616311.png" alt="Image 1" style="width: 100%;">        <p>RubyInstaller Downloads页面</p>    </div>    <div style="width: 40%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013175724296.png" alt="Image 2" style="width: 100%;">        <p>安装向导完成页面</p>    </div></div><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 50%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013175756189.png" alt="Image 1" style="width: 100%;">        <p>运行 ridk install</p>    </div>    <div style="width: 50%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013180247061.png" alt="Image 2" style="width: 100%;">        <p>ridk install 运行完成</p>    </div></div><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 60%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013181646903.png" alt="Image 1" style="width: 100%;">        <p>检查Jekyll是否成功安装</p>    </div>    <div style="width: 40%;">        <img src="" alt="Image 2" style="width: 100%;">        <p></p>    </div></div><h4 id="通过bash安装"><a href="#通过bash安装" class="headerlink" title="通过bash安装"></a>通过bash安装</h4><blockquote><p>参考 <a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a> ，此处不再尝试</p></blockquote><h2 id="三、配置个人主页"><a href="#三、配置个人主页" class="headerlink" title="三、配置个人主页"></a>三、配置个人主页</h2><p>根据自己选择的 <a href="http://jekyllthemes.org/">Jekyll 模板</a>，进行后续配置。以 <a href="https://chirpy.cotes.page/posts/getting-started/">Chirpy</a> 模板为例。</p><h3 id="1-创建仓库-准备模板源码"><a href="#1-创建仓库-准备模板源码" class="headerlink" title="1. 创建仓库 + 准备模板源码"></a>1. 创建仓库 + 准备模板源码</h3><p>首先创建名为 <code>username.github.io</code> 的远程仓库，并clone到本地。</p><blockquote><p>:warning: username不是你的昵称 or 你自己的名字。</p><p>:heavy_check_mark: username是你的github账户名，要严格保持一致</p></blockquote><p>下载 <a href="http://jekyllthemes.org/themes/jekyll-theme-chirpy/">Chripy</a> 的源码，解压到clone的本地文件夹目录下，使用 <code>bundle install</code> 构建本地环境。</p><blockquote><p>:warning: 记住将 <code>Gemfile</code> 中的 source 替换为 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/rubygems/">清华镜像源</a>。</p></blockquote><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013215146729.png" alt="image-20231013215146729" style="zoom: 50%;" /><h3 id="2-部署个人主页"><a href="#2-部署个人主页" class="headerlink" title="2. 部署个人主页"></a>2. 部署个人主页</h3><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>部署前，配置 <code>_config.yml</code> 中的 <code>url</code>，填写为仓库地址。</p><blockquote><p><strong>Before the deployment begins, check out the file<code>_config.yml</code>and make sure the<code>url</code>is configured correctly.</strong> Furthermore, if you prefer the <a href="https://link.zhihu.com/?target=https://help.github.com/en/github/working-with-github-pages/about-github-pages%23types-of-github-pages-sites">project site</a> and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than<strong>GitHub Pages</strong>, remember to change the<code>baseurl</code>to your project name that starts with a slash, e.g,<code>/project-name</code>.</p></blockquote><h4 id="使用Github-Action部署个人主页。"><a href="#使用Github-Action部署个人主页。" class="headerlink" title="使用Github Action部署个人主页。"></a>使用Github Action部署个人主页。</h4><ol><li><p>首先在仓库设置页(Settings)-&gt;Pages-&gt;Build and deployment从下拉菜单中选择Github Actions。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013220645578.png" alt="image-20231013220645578" style="zoom: 50%;" /><blockquote><ol><li>Browse to your repository on GitHub. Select the tab <em>Settings</em>, then click <em>Pages</em> in the left navigation bar. Then, in the <strong>Source</strong> section (under <em>Build and deployment</em>), select <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow"><strong>GitHub Actions</strong></a> from the dropdown menu.</li></ol></blockquote></li><li><p>然后把本地修改commit并提交到Github远程仓库上，可以触发<code>Github Action</code>的<code>Build and deployment</code>工作流进行部署。如果没有自动触发，可以手动点击<code>Build and Deploy</code>进行部署。</p><blockquote><ol start="2"><li>Push any commits to GitHub to trigger the <em>Actions</em> workflow. In the <em>Actions</em> tab of your repository, you should see the workflow <em>Build and Deploy</em> running. Once the build is complete and successful, the site will be deployed automatically.</li></ol></blockquote></li><li><p>等待一段时间后，在 Actions 页查看部署情况。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013224102256.png" alt="image-20231013224102256" style="zoom:67%;" /></li><li><p>可能的错误</p></li></ol><h4 id="可选-手动构建和配置"><a href="#可选-手动构建和配置" class="headerlink" title="(可选)手动构建和配置"></a>(可选)手动构建和配置</h4><blockquote><p>不再演示，可参考 <a href="https://chirpy.cotes.page/posts/getting-started/">官方文档</a>。</p></blockquote><h4 id="本地运行Jekyll项目"><a href="#本地运行Jekyll项目" class="headerlink" title="本地运行Jekyll项目"></a>本地运行Jekyll项目</h4><p>在项目路径下使用命令 <code>bundle exec jekyll serve</code>，即可在 Web 浏览器中导航到 <code>http://localhost:4000</code> 浏览本地项目。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013230309002.png" alt="image-20231013230309002" style="zoom: 50%;" /><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/641525444">知乎-春枫禾旭 的博客</a>；</li><li><a href="https://docs.github.com/zh/pages/getting-started-with-github-pages">GitHub Page中文教程</a>；</li><li><a href="http://jekyllthemes.org/">Jekyll 模板主页</a>；</li><li><a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a>；</li><li><a href="https://chirpy.cotes.page/posts/getting-started/">Chirpy官方文档</a> ；</li><li><a href="https://sunhwee.com/posts/a927e90e.html#toc-heading-3">emoji小基地</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;emoji 好看吗？&lt;a href=&quot;https://sunhwee.com/posts/a927</summary>
      
    
    
    
    <category term="工具库" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
    
    <category term="Github" scheme="http://example.com/tags/Github/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
</feed>
