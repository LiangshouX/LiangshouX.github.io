<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liangshou</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-16T05:12:04.799Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Liangshou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2023-10-16T05:12:04.799Z</published>
    <updated>2023-10-16T05:12:04.799Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo渲染的页面不支持mermaid语法</title>
    <link href="http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/</id>
    <published>2023-10-15T22:09:15.568Z</published>
    <updated>2023-10-15T22:40:11.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mermaid 的介绍和使用请参考  <a href="https://zhuanlan.zhihu.com/p/172635547">这篇文章</a> 和 <a href="https://mermaid.js.org/intro/">官方文档</a>。</p></blockquote><h1 id="hexo渲染的页面不支持mermaid语法问题"><a href="#hexo渲染的页面不支持mermaid语法问题" class="headerlink" title="hexo渲染的页面不支持mermaid语法问题"></a>hexo渲染的页面不支持mermaid语法问题</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在typora编写的Markdown文件能很好地渲染 mermaid 流程图，然而使用 hexo 部署后却不能渲染，只能显示出 mermaid 代码。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>从 <a href="https://hexo.io/plugins/">hexo插件官网</a> 找到对应的插件 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams</a>，参照 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams</a> 官方给出的环境配置方法进行配置。</p><ol><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-mermaid-diagrams</span><br><span class="line">// or</span><br><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><p>同时修改根目录和themes目录下的 <code>_config.yml</code> 文件，加上以下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;7.1.2&quot;</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure></li><li><p>在pug或js中包含mermaid.js</p><p>笔者使用的主题是 pure，在 <code>themes\pure\layout\_commons</code> 路径下的 <code>footer.ejs</code> 中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">  &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><blockquote><p>具体情况请参考 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams官方说明 </a>。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;mermaid 的介绍和使用请参考  &lt;a href=&quot;https://zhuanlan.zhihu.com/p/172635547&quot;&gt;这篇文章&lt;/a&gt; 和 &lt;a href=&quot;https://mermaid.js.org/intro/&quot;&gt;官方文档&lt;</summary>
      
    
    
    
    <category term="随机BUG" scheme="http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
    <category term="mermaid" scheme="http://example.com/tags/mermaid/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>二叉树基本定义以及遍历方法</title>
    <link href="http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</id>
    <published>2023-10-15T16:52:39.418Z</published>
    <updated>2023-10-16T05:28:41.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自程序员Carl的 <a href="https://programmercarl.com/">代码随想录</a>。</p></blockquote><p>[toc]</p><h1 id="二叉树的基本定义"><a href="#二叉树的基本定义" class="headerlink" title="二叉树的基本定义"></a>二叉树的基本定义</h1><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><p>解题过程中二叉树有两种主要的形式：<strong>满二叉树</strong>和<strong>完全二叉树</strong>。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树，如下图所示。</p><blockquote><p>文章中使用了画图功能，使用方式参考 <a href="https://zhuanlan.zhihu.com/p/172635547">这篇文章</a>， mermaid语法请参考 <a href="https://mermaid.js.org/intro/">官方文档</a>。</p></blockquote><pre class="mermaid">graph TDA-->BA-->CB-->DB-->EC-->FC-->GD-->HD-->IE-->JE-->KF-->LF-->MG-->NG-->O</pre><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。如下面的两个是完全二叉树：</p><pre class="mermaid">graph TDA-->BA-->CB-->DB-->EC-->FC-->GD-->HD-->IE-->J</pre><pre class="mermaid">graph TDA-->BA-->CB-->DB-->EC-->FC-->GD-->HD-->IE-->JE-->K</pre><p>而下面一个就不是完全二叉树：</p><pre class="mermaid">graph TDA-->BA-->CB-->DB-->EC-->FC-->GD-->HD-->IE-->NullE-->K</pre><blockquote><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系</strong></p></blockquote><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>相比于前面介绍的没有数值的树，二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>例如下面这两棵树都是搜索树</p><pre class="mermaid">graph TD10-->610-->166-->36-->916-->1416-->19</pre><pre class="mermaid">graph TD10-->610-->Null6-->36-->9</pre><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。例如：</p><pre class="mermaid">graph TD10-->610-->166-->36-->9</pre><pre class="mermaid">graph TD10-->610-->166-->36-->916-->1416-->19</pre><blockquote><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是$log\ n$，</p><p>注意这里不包括unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表</p></blockquote><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p><p>链式存储比较直观，即给每个节点设置左指针和有指针，分别指向左子树和右子树。</p><p>如何顺序存储呢？其实就是用数组来存储二叉树，顺序存储的方式如图：</p><pre class="mermaid">graph TDa-->ba-->cb-->db-->ec-->fc-->g</pre><p>对应的存储数组为：<code>[a,b,c,d,e,f,g]</code>，下标对应 0-6。</p><p>顺序存储的遍历方式：</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><blockquote><p>注意总结做题的框架！！</p></blockquote><p>关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。</p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候还会介绍到。</p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>在深度优先遍历中：有三个顺序，前中后序遍历。<strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，因此只需要记住： 前中后序指的就是中间节点的位置。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>例如对于下面的图，前中后序遍历的顺序依次是：</p><ul><li>前序（DLR）：abdecfg</li><li>中序（LDR）：dbeafcg</li><li>后序（LRD）：debfgca</li></ul><pre class="mermaid">graph TDa-->ba-->cb-->db-->ec-->fc-->g</pre><p>最后是二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p><p>前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><h2 id="二叉树的代码实现"><a href="#二叉树的代码实现" class="headerlink" title="二叉树的代码实现"></a>二叉树的代码实现</h2><blockquote><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p><p>因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++代码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1><h2 id="递归的三要素"><a href="#递归的三要素" class="headerlink" title="递归的三要素"></a>递归的三要素</h2><p>本部分将介绍前后中序的递归写法。首先确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><h2 id="题目链接及题解"><a href="#题目链接及题解" class="headerlink" title="题目链接及题解"></a>题目链接及题解</h2><ol><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LC144_二叉树的前序遍历</a><ol><li>确定递归函数的参数和返回值。预设代码给出了preorderTraversal函数，其参数为 TreeNode类型的root节点，返回List&lt;Integer&gt;类型。实现递归函数preorder，该函数主要实现对二叉树的遍历，并把遍历结果插入result向量中，返回值为void；参数需要两个：当前的结点和result向量</li><li>确定终止条件：当前结点为 null 时递归终止</li><li>单层递归逻辑：DLR</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定参数：当前节点 和 result List</span></span><br><span class="line">    <span class="comment">// 返回值： void</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单层递归逻辑：DLR</span></span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        preorder(curr.left, result);</span><br><span class="line">        preorder(curr.right, result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LC94_二叉树的中序遍历</a></li></ol><blockquote><p>原理&amp;思路同上一题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRD</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(curr.left, result);</span><br><span class="line">        postorder(curr.right, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LC145_二叉树的后序遍历</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(curr.left, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        inorder(curr.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/share/jump/8214310031697402552220">BM24 二叉树的中序遍历</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] resultArr = result.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(curr.left, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        inorder(curr.right, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/share/jump/8214310031697403236272">BM25 二叉树的后序遍历</a></p><p><a href="https://www.nowcoder.com/share/jump/8214310031697403428551">BM23 二叉树的前序遍历</a></p><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><blockquote><p>见 <a href="https://programmercarl.com/">代码随想录</a>。</p></blockquote><h2 id="迭代法遍历的基本原理"><a href="#迭代法遍历的基本原理" class="headerlink" title="迭代法遍历的基本原理"></a>迭代法遍历的基本原理</h2><blockquote><p>此部分建议细读 <a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">代码随想录-二叉树的迭代遍历</a> 理解迭代遍历的基本原理。</p></blockquote><h2 id="统一迭代方法"><a href="#统一迭代方法" class="headerlink" title="统一迭代方法"></a>统一迭代方法</h2><p>迭代法实现的先中后序，其实风格并不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。</p><p>经过实践会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。</p><p>统一写法的基本思路是：<strong>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记</strong>。</p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">            st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">            st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">            st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">            node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）         </span></span><br><span class="line">                               </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="102二叉树的层序遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 102.二叉树的层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun02</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="literal">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="literal">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ol><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LC102. 二叉树的层序遍历</a>；</li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LC107. 二叉树的层序遍历 II</a>；</li><li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">LC199. 二叉树的右视图</a>；</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文来自程序员Carl的 &lt;a href=&quot;https://programmercarl.com/&quot;&gt;代码随想录&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;二叉树的基本定义&quot;&gt;&lt;a href=&quot;#二叉树</summary>
      
    
    
    
    <category term="刷题笔记" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="NowCoder" scheme="http://example.com/tags/NowCoder/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/10/15/hello-world/"/>
    <id>http://example.com/2023/10/15/hello-world/</id>
    <published>2023-10-14T16:08:56.164Z</published>
    <updated>2023-10-14T16:04:19.185Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建GitHub Page-Jekyll篇</title>
    <link href="http://example.com/2023/10/13/%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/"/>
    <id>http://example.com/2023/10/13/%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/</id>
    <published>2023-10-13T09:25:37.729Z</published>
    <updated>2023-10-15T09:13:37.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote><p>emoji 好看吗？<a href="https://sunhwee.com/posts/a927e90e.html#toc-heading-3">这里 </a>有很多哦</p></blockquote><p>应该没有一个开发人员不向往有一个自己的个人网页吧？:smirk: </p><p>这个主页怎么搭建呢？事实上，网络上有很多将搭建个人博客网站的项目，这样当然是好的，可是似乎需要自己搞一台服务器啊？如果服务器过期了，网站是不是就404了呢？:thinking: </p><p>那能不能不用自己租服务器，快乐当白嫖怪呢？GitHub表示：宝宝，还没想起来我吗？:triumph::kissing_heart:</p><p>不会前端咋办？当然是本着<strong>将白嫖进行到底</strong>的原则啦！看这里:point_right: <a href="http://jekyllthemes.org/">Jekyll 模板</a>:point_left:。</p><h2 id="二、Windows环境配置"><a href="#二、Windows环境配置" class="headerlink" title="二、Windows环境配置"></a>二、Windows环境配置</h2><ul><li>Ruby (ruby -v)</li><li>RubyGems (gem -v)</li><li>Gcc &amp; make (gcc -v | g++ -v | make -v )</li><li>Git (git –version)</li></ul><h3 id="配置Gcc、make环境"><a href="#配置Gcc、make环境" class="headerlink" title="配置Gcc、make环境"></a>配置Gcc、make环境</h3><blockquote><p>参考：</p><ol><li><a href="https://blog.csdn.net/qq_42544728/article/details/128037835">Gcc、g++安装</a>；</li><li><a href="https://tehub.com/a/aCYp1uw0tG">make安装</a>。</li></ol></blockquote><h3 id="安装-Ruby-和-Jekyll"><a href="#安装-Ruby-和-Jekyll" class="headerlink" title="安装 Ruby 和 Jekyll"></a>安装 Ruby 和 Jekyll</h3><blockquote><p>参考 <a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a> 。</p></blockquote><h4 id="通过-RubyInstaller-安装"><a href="#通过-RubyInstaller-安装" class="headerlink" title="通过 RubyInstaller 安装"></a>通过 RubyInstaller 安装</h4><p>Windows上安装Ruby和Jekyll最简单的方法是 <a href="https://rubyinstaller.org/">RubyInstaller</a>，RubyInstaller是一个基于windows的比较完备的安装程序，包括Ruby语言、执行环境、重要文档等等。</p><p>官方配置中介绍的是 RubyInstaller-2.4及更新版本，直接选择最新的安装包。</p><p>详细步骤：</p><ol><li><p>从 <a href="https://rubyinstaller.org/downloads/">RubyInstaller Downloads</a> 下载并安装 Ruby+Devkit 版本。使用默认选项进行安装；</p></li><li><p>在安装向导的最后阶段运行 <code>ridk install</code> 步骤。这是安装带有本地扩展的 gem 所需要的。可以在 <a href="https://github.com/oneclick/rubyinstaller2#using-the-installer-on-a-target-system">RubyInstaller Documentation</a> 中找到更多相关信息。从选项中选择 <code>MSYS2 and MINGW development tool chain</code> ；</p></li><li><p>从开始菜单打开一个新的命令提示窗口，这样对 PATH 环境变量的更改就会生效。使用命令 <code>gem Install Jekyll Bundler</code> 安装Jekyll和Bundler；</p><blockquote><p>注意：此处需将 Ruby gem的源换回国内源，<a href="https://mirrors.tuna.tsinghua.edu.cn/help/rubygems/">清华镜像源操作方法</a>。</p></blockquote></li><li><p>查看Jekyll 是否正确安装：<code>jekyll -v</code>；</p></li></ol><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 55%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013174616311.png" alt="Image 1" style="width: 100%;">        <p>RubyInstaller Downloads页面</p>    </div>    <div style="width: 40%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013175724296.png" alt="Image 2" style="width: 100%;">        <p>安装向导完成页面</p>    </div></div><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 50%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013175756189.png" alt="Image 1" style="width: 100%;">        <p>运行 ridk install</p>    </div>    <div style="width: 50%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013180247061.png" alt="Image 2" style="width: 100%;">        <p>ridk install 运行完成</p>    </div></div><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 60%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013181646903.png" alt="Image 1" style="width: 100%;">        <p>检查Jekyll是否成功安装</p>    </div>    <div style="width: 40%;">        <img src="" alt="Image 2" style="width: 100%;">        <p></p>    </div></div><h4 id="通过bash安装"><a href="#通过bash安装" class="headerlink" title="通过bash安装"></a>通过bash安装</h4><blockquote><p>参考 <a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a> ，此处不再尝试</p></blockquote><h2 id="三、配置个人主页"><a href="#三、配置个人主页" class="headerlink" title="三、配置个人主页"></a>三、配置个人主页</h2><p>根据自己选择的 <a href="http://jekyllthemes.org/">Jekyll 模板</a>，进行后续配置。以 <a href="https://chirpy.cotes.page/posts/getting-started/">Chirpy</a> 模板为例。</p><h3 id="1-创建仓库-准备模板源码"><a href="#1-创建仓库-准备模板源码" class="headerlink" title="1. 创建仓库 + 准备模板源码"></a>1. 创建仓库 + 准备模板源码</h3><p>首先创建名为 <code>username.github.io</code> 的远程仓库，并clone到本地。</p><blockquote><p>:warning: username不是你的昵称 or 你自己的名字。</p><p>:heavy_check_mark: username是你的github账户名，要严格保持一致</p></blockquote><p>下载 <a href="http://jekyllthemes.org/themes/jekyll-theme-chirpy/">Chripy</a> 的源码，解压到clone的本地文件夹目录下，使用 <code>bundle install</code> 构建本地环境。</p><blockquote><p>:warning: 记住将 <code>Gemfile</code> 中的 source 替换为 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/rubygems/">清华镜像源</a>。</p></blockquote><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013215146729.png" alt="image-20231013215146729" style="zoom: 50%;" /><h3 id="2-部署个人主页"><a href="#2-部署个人主页" class="headerlink" title="2. 部署个人主页"></a>2. 部署个人主页</h3><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>部署前，配置 <code>_config.yml</code> 中的 <code>url</code>，填写为仓库地址。</p><blockquote><p><strong>Before the deployment begins, check out the file<code>_config.yml</code>and make sure the<code>url</code>is configured correctly.</strong> Furthermore, if you prefer the <a href="https://link.zhihu.com/?target=https://help.github.com/en/github/working-with-github-pages/about-github-pages%23types-of-github-pages-sites">project site</a> and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than<strong>GitHub Pages</strong>, remember to change the<code>baseurl</code>to your project name that starts with a slash, e.g,<code>/project-name</code>.</p></blockquote><h4 id="使用Github-Action部署个人主页。"><a href="#使用Github-Action部署个人主页。" class="headerlink" title="使用Github Action部署个人主页。"></a>使用Github Action部署个人主页。</h4><ol><li><p>首先在仓库设置页(Settings)-&gt;Pages-&gt;Build and deployment从下拉菜单中选择Github Actions。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013220645578.png" alt="image-20231013220645578" style="zoom: 50%;" /><blockquote><ol><li>Browse to your repository on GitHub. Select the tab <em>Settings</em>, then click <em>Pages</em> in the left navigation bar. Then, in the <strong>Source</strong> section (under <em>Build and deployment</em>), select <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow"><strong>GitHub Actions</strong></a> from the dropdown menu.</li></ol></blockquote></li><li><p>然后把本地修改commit并提交到Github远程仓库上，可以触发<code>Github Action</code>的<code>Build and deployment</code>工作流进行部署。如果没有自动触发，可以手动点击<code>Build and Deploy</code>进行部署。</p><blockquote><ol start="2"><li>Push any commits to GitHub to trigger the <em>Actions</em> workflow. In the <em>Actions</em> tab of your repository, you should see the workflow <em>Build and Deploy</em> running. Once the build is complete and successful, the site will be deployed automatically.</li></ol></blockquote></li><li><p>等待一段时间后，在 Actions 页查看部署情况。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013224102256.png" alt="image-20231013224102256" style="zoom:67%;" /></li><li><p>可能的错误</p></li></ol><h4 id="可选-手动构建和配置"><a href="#可选-手动构建和配置" class="headerlink" title="(可选)手动构建和配置"></a>(可选)手动构建和配置</h4><blockquote><p>不再演示，可参考 <a href="https://chirpy.cotes.page/posts/getting-started/">官方文档</a>。</p></blockquote><h4 id="本地运行Jekyll项目"><a href="#本地运行Jekyll项目" class="headerlink" title="本地运行Jekyll项目"></a>本地运行Jekyll项目</h4><p>在项目路径下使用命令 <code>bundle exec jekyll serve</code>，即可在 Web 浏览器中导航到 <code>http://localhost:4000</code> 浏览本地项目。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013230309002.png" alt="image-20231013230309002" style="zoom: 50%;" /><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/641525444">知乎-春枫禾旭 的博客</a>；</li><li><a href="https://docs.github.com/zh/pages/getting-started-with-github-pages">GitHub Page中文教程</a>；</li><li><a href="http://jekyllthemes.org/">Jekyll 模板主页</a>；</li><li><a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a>；</li><li><a href="https://chirpy.cotes.page/posts/getting-started/">Chirpy官方文档</a> ；</li><li><a href="https://sunhwee.com/posts/a927e90e.html#toc-heading-3">emoji小基地</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;emoji 好看吗？&lt;a href=&quot;https://sunhwee.com/posts/a927</summary>
      
    
    
    
    <category term="GitHub" scheme="http://example.com/categories/GitHub/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
    <category term="Github" scheme="http://example.com/tags/Github/"/>
    
  </entry>
  
</feed>
