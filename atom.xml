<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liangshou</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-25T16:13:26.437Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Liangshou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LC热题100-前缀和+哈希表</title>
    <link href="http://example.com/2023/10/25/2023-10-25-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/25/2023-10-25-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-25T15:43:31.248Z</published>
    <updated>2023-10-25T16:13:26.437Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked">和为k的子数组</a></p></blockquote><p>参见：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        pre[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++){</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(pre[i] - k)){</span><br><span class="line">                res += map.get(pre[i] - k);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            map.put(pre[i], map.getOrDefault(pre[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;amp;envId=top-100-liked&quot;</summary>
      
    
    
    
    <category term="刷题日记" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="NowCoder" scheme="http://example.com/tags/NowCoder/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>你好，volatile！你好，synchronized！</title>
    <link href="http://example.com/2023/10/25/2023-10-25-volatile%E4%B8%8Esynchronized/"/>
    <id>http://example.com/2023/10/25/2023-10-25-volatile%E4%B8%8Esynchronized/</id>
    <published>2023-10-25T12:18:17.726Z</published>
    <updated>2023-10-27T06:55:42.890Z</updated>
    
    <content type="html"><![CDATA[<p><code>Synchronized</code>和<code>Volatile</code>是两个在Java中用于处理多线程编程的关键字，它们分别用于实现<strong>线程同步</strong>和<strong>确保可见性</strong>。在Java多线程编程中，二者是互补的存在，而不是对立的存在。</p><h1>volatile</h1><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><h2 id="指令重排">指令重排</h2><p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><h3 id="什么是指令重排？">什么是指令重排？</h3><blockquote><p>简单来说，就是指在程序中写的代码，在执行时并不一定按照写的顺序。</p></blockquote><p>Java指令重排是一种编译器和JVM（Java虚拟机）优化技术，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入的代码进行<strong>乱序执行优化</strong>，处理器会在计算之后将乱序执行的结果重组，并确保这一结果和顺序执行结果是一致的，但是这个过程并不保证各个语句<strong>计算的先后顺序</strong>和<strong>输入代码中的顺序</strong>一致。这就是指令重排序。</p><h3 id="什么时候会发生指令重排？">什么时候会发生指令重排？</h3><ol><li>编译器重排：编译器在生成字节码或本机代码时可能会重新排列指令，以优化执行路径。这种重排通常是在不改变程序语义的前提下进行的。</li><li>处理器重排：现代处理器通常具有多级流水线，它们可以重新排列执行指令以充分利用硬件资源。处理器重排是在指令级别进行的，它不会改变程序的语义，但可能会影响线程之间的可见性。</li><li>JVM重排：JVM也可能会重新排列Java字节码指令以提高性能。这种重排也是在不改变程序语义的前提下进行的。</li></ol><h3 id="一个指令重排的复现案例">一个指令重排的复现案例</h3><p>定义四个静态变量x,y,a,b，每次循环时让他们都等于0，接着用两个线程，<strong>第一个线程执行a=1;x=b;第二个线程执行b=1;y=a。</strong></p><p>从逻辑上来讲，这段程序<strong>应该有3个结果：</strong></p><ol><li>当第一个线程执行到a=1的时候，第二个线程执行到了b=1，最后<strong>x=1，y=1</strong>；</li><li>当第一个线程执行完，第二个线程才刚开始，最后<strong>x=0，y=1</strong>；</li><li>当第二个线程执行完，第一个线程才开始，最后<strong>x=1，y=0</strong>；</li></ol><p>理论上无论怎么样都不可能x=0,y=0;</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileReOrderDemo</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException{</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>;  y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;  b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开两个线程，第一个线程执行 a=1；x=b；   第二个线程执行 b=1;y=a</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                    <span class="comment">// 线程1会比线程2先执行，因此用nanoTime让线程1等待线程2 0.01毫秒</span></span><br><span class="line">                    shortWait(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line"></span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两个线程都执行完成后拼接结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> String.format(<span class="string">"第 %d 次执行:\tx=%d\ty=%d"</span>, i, x, y);</span><br><span class="line">            System.out.println(result);</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">while</span> (x != <span class="number">0</span> || y != <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用了一个循环来等待一段时间，但不涉及锁或通知机制。它不会释放锁，也不会等待其他线程的通知。</span></span><br><span class="line"><span class="comment">     * 仅用于简单的等待一段时间，而不是线程之间的协作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval 等待的时间间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shortWait</span><span class="params">(<span class="type">long</span> interval)</span>{</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">long</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        }<span class="keyword">while</span> (start + interval &gt;= end);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>实际上，当程序运行几万或几十几百万次后，会出现<code>x=0,y=0;</code>的结果：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第 4870627 次执行:x=0y=1</span><br><span class="line">第 4870628 次执行:x=0y=1</span><br><span class="line">第 4870629 次执行:x=0y=1</span><br><span class="line">第 4870630 次执行:x=0y=1</span><br><span class="line">第 4870631 次执行:x=0y=0</span><br></pre></td></tr></tbody></table></figure><p>这就是因为指令被重排序了，x=b先于a=1执行，y=a先于b=1执行。</p><h2 id="volatile-禁止指令重排">volatile 禁止指令重排</h2><p>如果我们将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><blockquote><p><strong>内存屏障</strong> 是一个CPU的指令，它可以保证特定操作的执行顺序。</p></blockquote><p><code>volatile</code>关键字确保了禁止特定类型的指令重排。在<code>volatile</code>变量的读操作和写操作周围，编译器和处理器会添加内存屏障（Memory Barrier），确保写操作不会被重排到读操作之前，也不会被重排到读操作之后。这意味着其他线程在读取<code>volatile</code>变量时，将看到写操作的结果，而不会看到它们之间的重排序。</p><blockquote><p><strong>单例模式</strong>：一种创建型设计模式，它确保<strong>一个类只有一个实例</strong>，并提供一个全局访问点以获取该实例。单例模式通常用于那些需要在应用程序中全局共享一个实例的情况，以确保该实例在整个应用程序生命周期内只被创建一次。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验锁实现对象单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 判断是否已经实例化过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>){</span><br><span class="line">            <span class="comment">// 类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class){</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>){</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><h2 id="volatile保证变量的可见性">volatile保证变量的可见性</h2><p>设计如下的程序验证：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileVisibilityDemo</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toggleFlag</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 修改 flag 的值</span></span><br><span class="line">        flag = !flag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">// 读取 flag</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">VolatileVisibilityDemo</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileVisibilityDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 A：修改flag</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 让 B 线程有足够的时间启动</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">            example.toggleFlag();</span><br><span class="line">            System.out.println(<span class="string">"Flag has been set to true"</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 B：检查flag的值</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (!example.isFlag()){</span><br><span class="line">                <span class="comment">// 等待 flag 变成 true</span></span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"Flag is now true"</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个示例中，有两个线程，线程A负责修改<code>flag</code>的值为<code>true</code>，而线程B负责检查<code>flag</code>的值是否为<code>true</code>。由于<code>flag</code>被声明为<code>volatile</code>，线程B能够立即看到线程A对<code>flag</code>的修改，因此线程B将在<code>flag</code>变为<code>true</code>后输出相应的信息。</p><p>如果将<code>flag</code>声明为非<code>volatile</code>的话，线程B可能会永远等待下去，因为不保证可见性，线程B无法及时获取到线程A对<code>flag</code>的修改。这就是<code>volatile</code>关键字的作用，确保变量的可见性，适用于需要跨线程通信的情况。</p><h2 id="volatile不保证原子性">volatile不保证原子性</h2><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><blockquote><p>原子性（Atomicity）是多线程编程中的一个重要概念，它指的是一个操作是不可分割的，要么全部执行，要么全部不执行。如果一个操作是原子性的，那么在多线程环境下，其他线程无法在执行该操作的过程中干扰或修改其状态，从而确保操作的一致性和完整性。</p></blockquote><p>验证示例代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证 volatile 不保证变量操作的原子性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicityDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>{</span><br><span class="line">        inc++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException{</span><br><span class="line">        <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numIteration</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(numThreads);</span><br><span class="line"></span><br><span class="line">        <span class="type">VolatileAtomicityDemo</span> <span class="variable">volatileAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileAtomicityDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numThreads; i++){</span><br><span class="line">            threadPool.execute(() -&gt; {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; numIteration; j++){</span><br><span class="line">                    volatileAtomicityDemo.increase();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 1.5 秒，保证上面的程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">15000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"共有%d个线程，每个线程迭代%d次。本应增长%d次！\n"</span>,</span><br><span class="line">                numThreads, numIteration, numThreads * numIteration);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"实际增长次数为：%d\n"</span>, inc);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共有5个线程，每个线程迭代500次。本应增长2500次！</span><br><span class="line">实际增长次数为：2417</span><br></pre></td></tr></tbody></table></figure><p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但真正运行了上面的代码之后，你会发现很多时候结果都小于 <code>2500</code>。</p><p>也就说明，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500=2500。</p><p>事实上，<code>inc++</code> 是一个复合操作，包括三步：</p><ol><li>读取 inc 的值。</li><li>对 inc 加 1。</li><li>将 inc 的值写回内存。</li></ol><p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p><ol><li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code>的值并对其进行修改（+1），再将<code>inc</code> 的值写回内存。</li><li>线程 2 操作完毕后，线程 1 对 <code>inc</code>的值进行修改（+1），再将<code>inc</code> 的值写回内存。</li></ol><p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p><p>其实，如果想要保证上面的代码运行正确也非常简单，利用 <code>synchronized</code>、<code>Lock</code>或者<code>AtomicInteger</code>都可以。</p><h1>synchronized</h1><p><code>synchronized</code> 是 Java 中的一个关键字，中文意思为“同步”、“协调”，主要解决的是多个线程之间访问资源的<strong>同步性</strong>，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h2 id="具体使用场景">具体使用场景</h2><h3 id="实例方法与静态方法">实例方法与静态方法</h3><p>在Java中，方法可以分为两大类：实例方法和静态方法。这两种方法有不同的特点和用途。</p><ol><li>实例方法（Instance Method）：<ul><li>实例方法是与对象实例相关联的方法。</li><li>它可以访问和操作对象的实例变量（成员变量）。</li><li>实例方法必须通过对象调用，因为它们依赖于对象的状态。</li><li>通常用于封装对象的行为和操作。</li></ul></li></ol><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> {</span><br><span class="line">    String model;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Starting the "</span> + model + <span class="string">" car."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        myCar.model = <span class="string">"Toyota"</span>;</span><br><span class="line">        myCar.start(); <span class="comment">// 调用实例方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的示例中，<code>start</code> 是一个实例方法，它操作了 <code>Car</code> 类的实例变量 <code>model</code>，并且必须通过 <code>myCar</code> 实例调用。</p><ol start="2"><li><p>静态方法（Static Method）：</p><ul><li><p>静态方法与类相关联，而不是与对象实例相关联。</p></li><li><p>它不可以访问对象的实例变量，因为它与特定实例无关。</p></li><li><p>静态方法可以直接通过类名调用，无需创建对象。</p></li><li><p>通常用于执行与类相关的操作，不依赖于特定实例。</p></li></ul></li></ol><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> MathUtils.add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用静态方法</span></span><br><span class="line">        System.out.println(<span class="string">"Result: "</span> + result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的示例中，<code>add</code> 是一个静态方法，它与特定的对象实例无关，可以直接通过类名 <code>MathUtils</code> 调用。</p><p>实例方法与<strong>对象实例</strong>相关联，可以访问实例变量，静态方法与<strong>类</strong>相关联，不依赖于对象实例，不能访问实例变量。</p><h3 id="synchronized修饰实例方法">synchronized修饰实例方法</h3><p>给<strong>当前对象实例</strong>加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="synchronized修饰静态方法">synchronized修饰静态方法</h3><p>给<strong>当前类</strong>加锁，会作用于类的<strong>所有对象实例</strong> ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p><p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="synchronized修饰代码块">synchronized修饰代码块</h3><p>对括号里<strong>指定的对象/类</strong>加锁：</p><ul><li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li></ul><blockquote><p><strong>构造方法不能使用 synchronized 关键字修饰。</strong> 因为构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p></blockquote><h2 id="synchronized-保证操作的可见性">synchronized 保证操作的可见性</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedVisibilityDemo</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">()</span>{</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">readData</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">SynchronizedVisibilityDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedVisibilityDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="comment">// 保证让读线程先运行</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">            System.out.printf(<span class="string">"Data is %s, ready to write to %s.\n"</span>, demo.flag, !demo.flag);</span><br><span class="line">            demo.writeData();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>){</span><br><span class="line">                <span class="comment">// 等待数据变为 true</span></span><br><span class="line">                <span class="keyword">if</span> (demo.readData()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"Data is true now!"</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        readerThread.start();</span><br><span class="line">        writerThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这个示例中，假如不加 <code>synchronized</code> 关键字，写线程对 <code>flag</code> 的操作对于读线程来说是不可见的，读线程会一直等待下去。</p><h2 id="synchronized-保证操作的原子性">synchronized 保证操作的原子性</h2><p>与 <code>volatile</code> 的验证方法相似。不加 <code>synchronized</code> 修饰，结果可能为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共有5个线程，每个线程迭代1000次。增长后 Counter 应为 5000！</span><br><span class="line">实际 Counter: 4395</span><br></pre></td></tr></tbody></table></figure><p>测试代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedAtomicityDemo</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>{</span><br><span class="line">        counter++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numIteration</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(numThreads);</span><br><span class="line"></span><br><span class="line">        <span class="type">SynchronizedAtomicityDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedAtomicityDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numThreads; i++) {</span><br><span class="line">            threadPool.execute(() -&gt; {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; numIteration; j++) {</span><br><span class="line">                    demo.increase();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池并等待所有任务完成</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">termination</span> <span class="operator">=</span> threadPool.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"共有%d个线程，每个线程迭代%d次。增长后 Counter 应为 %d！\n"</span>,</span><br><span class="line">                numThreads, numIteration, numThreads * numIteration);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"实际 Counter: "</span> + demo.getCounter());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="synchronized-底层原理">synchronized 底层原理</h2><h3 id="对于修饰代码块的情况">对于修饰代码块的情况</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCodeBlockDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>){</span><br><span class="line">            System.out.println(<span class="string">"Synchronized 代码块"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">SynchronizedCodeBlockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedCodeBlockDemo</span>();</span><br><span class="line">        demo.method();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>将代码使用<code>javac</code>编译，之后再执行<code>javap -c -s -v -l SynchronizedCodeBlockDemo.class</code> 命令后，可以看到 <code>method</code> 方法反编译的结果：</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231027134827905.png" alt="image-20231027134827905"></p><p><strong>解读</strong>：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void method();：这是方法的定义，名称为method，没有参数，返回类型为void，并且被声明为public。</span><br><span class="line"></span><br><span class="line">descriptor: ()V：这部分描述了方法的描述符。()表示方法没有参数，V表示返回类型为void。</span><br><span class="line"></span><br><span class="line">flags: (0x0001) ACC_PUBLIC：这是方法的修饰符，表示这个方法是public的。</span><br><span class="line"></span><br><span class="line">Code:：以下是方法的字节码指令。</span><br><span class="line"></span><br><span class="line">stack=2, locals=3, args_size=1：这是方法执行时的堆栈深度、本地变量数和参数数量的信息。</span><br><span class="line"></span><br><span class="line">0: aload_0：加载对象引用到操作数栈上。</span><br><span class="line"></span><br><span class="line">1: dup：复制栈顶的值并将副本压入栈。</span><br><span class="line"></span><br><span class="line">2: astore_1：将栈顶的值存储到局部变量1中。</span><br><span class="line"></span><br><span class="line">3: monitorenter：进入对象监视器（锁定对象），用于同步块的开始。</span><br><span class="line"></span><br><span class="line">4: getstatic #7：从静态字段#7（可能是java/lang/System.out的字段）获取一个值。</span><br><span class="line"></span><br><span class="line">7: ldc #13：将常量#13（可能是字符串常量"Synchronized 代码块"）加载到操作数栈上。</span><br><span class="line"></span><br><span class="line">9: invokevirtual #15：调用虚拟方法#15（可能是java/io/PrintStream.println）。</span><br><span class="line"></span><br><span class="line">12: aload_1：将局部变量1加载到栈上。</span><br><span class="line"></span><br><span class="line">13: monitorexit：退出对象监视器，用于同步块的结束。</span><br><span class="line"></span><br><span class="line">14: goto 22：跳转到第22条指令。</span><br><span class="line"></span><br><span class="line">17: astore_2：将栈顶的异常对象存储到局部变量2中。</span><br><span class="line"></span><br><span class="line">18: aload_1：将局部变量1加载到栈上。</span><br><span class="line"></span><br><span class="line">19: monitorexit：再次尝试退出对象监视器，用于异常处理。</span><br><span class="line"></span><br><span class="line">20: aload_2：将异常对象加载到栈上。</span><br><span class="line"></span><br><span class="line">21: athrow：抛出异常。</span><br><span class="line"></span><br><span class="line">22: return：返回指令，方法执行结束。</span><br><span class="line"></span><br><span class="line">Exception table:：这是异常处理表，描述了哪些异常在哪些范围内被处理。</span><br><span class="line"></span><br><span class="line">LineNumberTable:：这是行号表，指明了字节码指令和源代码之间的对应关系。</span><br><span class="line"></span><br><span class="line">LocalVariableTable:：这是本地变量表，列出了本地变量的信息。</span><br></pre></td></tr></tbody></table></figure><p>需要注意 <code>Code</code> 部分的第3、13、19，这表明 <code>synchronized</code>  同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放</p><h3 id="对于修饰方法的情况">对于修饰方法的情况</h3><p>同样的方式操作以下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMethodDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"Synchronized 方法"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">SynchronizedMethodDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedMethodDemo</span>();</span><br><span class="line">        demo.method();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231027135643151.png" alt="image-20231027135643151"></p><p>与修饰代码块相对比， <code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁</p><blockquote><p><code>flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED</code>：这是方法的修饰符，表示这个方法是<code>public</code>的，并且使用了<code>synchronized</code>修饰符。</p></blockquote><p><strong><code>volatile</code> 与 <code>synchronized</code> 的本质都是对对象监视器 monitor 的获取。</strong></p><h1>synchronized 和 volatile 的区别</h1><ul><li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Synchronized&lt;/code&gt;和&lt;code&gt;Volatile&lt;/code&gt;是两个在Java中用于处理多线程编程的关键字，它们分别用于实现&lt;strong&gt;线程同步&lt;/strong&gt;和&lt;strong&gt;确保可见性&lt;/strong&gt;。在Java多线程编程中，二者</summary>
      
    
    
    
    <category term="Java手账本" scheme="http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="并发编程" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java线程" scheme="http://example.com/tags/Java%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LC热题100-无重复字符的最长子串</title>
    <link href="http://example.com/2023/10/24/2023-10-24-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/24/2023-10-24-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-24T11:40:12.465Z</published>
    <updated>2023-10-24T13:21:23.472Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串</a></p></blockquote><h1>思路</h1><p>首先确定整体思路：滑动窗口。需要考虑的点：</p><ol><li>窗口内是什么？</li><li>何时调整窗口大小？</li><li>如何调整窗口大小？</li></ol><h1>解题方法</h1><h2 id="窗口的表示">窗口的表示</h2><p>窗口内表示的应该是连续的无重复字符的子串，窗口的长度也就代表了子串的长度。</p><p>窗口的左端：设计为left索引<br>窗口的右端：逐渐向后遍历的指针（索引）</p><h2 id="何时调整窗口大小？">何时调整窗口大小？</h2><p>只要窗口内的元素无重复，$left$ 就不动，索引一直往后遍历；</p><p>一旦出现索引到的元素重复了，就需要调整窗口，使得始终满足：<strong>窗口内的元素是不重复的。</strong></p><h2 id="如何调整窗口大小？">如何调整窗口大小？</h2><p>窗口是通过 $left$ 指针来调整的，那么如何调整 $left$ 指针呢？</p><p>$left$ 移动应该遵循的规律是：一旦出现重复的元素，$left$ 移动到<strong>窗口内重复元素的下一位</strong>。</p><p>举两个例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：[abcabcbb]</span><br></pre></td></tr></tbody></table></figure><p>首次出现重复的字符是 <code>a</code>，对应索引为 3，此时 $left$  还是0，窗口内元素为 <code>abc</code>，窗口内重复的元素的索引是 0，$left$ 更新为 $0+1$，即 $left$ 指向了<code>b</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：[abcbbcbb]</span><br></pre></td></tr></tbody></table></figure><p>此时首次出现重复的字符就变成了 <code>b</code>，对应索引为 3，此时 $left$  还是0，窗口内元素为 <code>abc</code>，窗口内重复的元素的索引是 1，$left$ 更新为 $1+1$，即 $left$ 指向了<code>c</code>。</p><h2 id="方法有了，怎么实现定位？">方法有了，怎么实现定位？</h2><p>上面的思路中，$left$ 怎么实现精确、快速的定位很重要！总不能在窗口内遍历一遍吧？（似乎也不是不行）但是这样的方式时间复杂度会提高，而且这样是相对位置，处理起来也比较麻烦。</p><p>此时，我们需要一个数据结构，能够同时记录 <code>元素值</code>和<code>元素索引</code>，并且，<code>元素值</code>最好是不重复的。<code>HashMap</code> 就很合适，而且还能快速查找是否窗口内出现重复的字符。</p><h2 id="Map如何更新？">Map如何更新？</h2><p>出现重复后，更新为最新的$ &lt;字符,索引&gt;$ 对。</p><h1>复杂度</h1><ul><li>时间复杂度:</li></ul><blockquote><p>添加时间复杂度, 示例： $O(n)$</p></blockquote><ul><li>空间复杂度:</li></ul><blockquote><p>添加空间复杂度, 示例： $O(n)$</p></blockquote><h1>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                       .::::.</span></span><br><span class="line"><span class="comment">//                     .::::::::.</span></span><br><span class="line"><span class="comment">//                    :::::::::::</span></span><br><span class="line"><span class="comment">//                 ..:::::::::::'</span></span><br><span class="line"><span class="comment">//              '::::::::::::'</span></span><br><span class="line"><span class="comment">//                .::::::::::</span></span><br><span class="line"><span class="comment">//           '::::::::::::::..</span></span><br><span class="line"><span class="comment">//                ..::::::::::::.</span></span><br><span class="line"><span class="comment">//              ``::::::::::::::::</span></span><br><span class="line"><span class="comment">//               ::::``:::::::::'        .:::.</span></span><br><span class="line"><span class="comment">//              ::::'   ':::::'       .::::::::.</span></span><br><span class="line"><span class="comment">//            .::::'      ::::     .:::::::'::::.</span></span><br><span class="line"><span class="comment">//           .:::'       :::::  .:::::::::' ':::::.</span></span><br><span class="line"><span class="comment">//          .::'        :::::.:::::::::'      ':::::.</span></span><br><span class="line"><span class="comment">//         .::'         ::::::::::::::'         ``::::.</span></span><br><span class="line"><span class="comment">//     ...:::           ::::::::::::'              ``::.</span></span><br><span class="line"><span class="comment">//    ```` ':.          ':::::::::'                  ::::..</span></span><br><span class="line"><span class="comment">//                       '.:::::'                    ':'````..</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.length() == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch)){</span><br><span class="line">                <span class="comment">// 调整 left 的位置</span></span><br><span class="line">                left = Math.max(left, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            curLen = i - left + <span class="number">1</span>;</span><br><span class="line">            maxLen = maxLen &gt; curLen?maxLen:curLen;</span><br><span class="line">            map.put(ch, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/&quot;&gt;3. 无重复字符的最长子串&lt;/a</summary>
      
    
    
    
    <category term="刷题日记" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="NowCoder" scheme="http://example.com/tags/NowCoder/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LC热题100-</title>
    <link href="http://example.com/2023/10/23/2023-10-23-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/23/2023-10-23-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-23T00:12:00.152Z</published>
    <updated>2023-10-23T02:38:38.223Z</updated>
    
    <content type="html"><![CDATA[<h1>字母异位词分组</h1><blockquote><p><a href="https://www.nowcoder.com/share/jump/8214310031698025039598">NC294-字母异位词分组</a></p><p><a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&amp;envId=top-100-liked">LC49-字母异位词分组</a></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> {</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        }</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;List&lt;String&gt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span>(String str: strs){</span><br><span class="line">            <span class="type">String</span> <span class="variable">keyStr</span> <span class="operator">=</span> convertToKey(str);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(keyStr)){</span><br><span class="line">                map.put(keyStr, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            }</span><br><span class="line">            map.get(keyStr).add(str);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convertToKey</span><span class="params">(String str)</span>{</span><br><span class="line">        <span class="type">char</span>[] charArr = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(charArr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArr);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;字母异位词分组&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/share/jump/8214310031698025039598&quot;&gt;NC294-字母异位词分组&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="刷题日记" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="NowCoder" scheme="http://example.com/tags/NowCoder/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>hexo渲染的页面不支持emoji表情</title>
    <link href="http://example.com/2023/10/21/2023-10-21-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81emoji%E8%A1%A8%E6%83%85%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/10/21/2023-10-21-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81emoji%E8%A1%A8%E6%83%85%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-20T16:14:29.704Z</published>
    <updated>2023-10-20T16:38:14.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1906785">https://cloud.tencent.com/developer/article/1906785</a></p></blockquote><h1>更换Markdown引擎</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save </span><br><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></tbody></table></figure><h1>修改<code>_config.yml</code>配置</h1><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span></span><br></pre></td></tr></tbody></table></figure><h1>emoji在哪儿找？</h1><ol><li><a href="https://wallpapers.com/emoji">https://wallpapers.com/emoji</a></li><li><a href="https://sunhwee.com/posts/a927e90e.html#toc-heading-1">https://sunhwee.com/posts/a927e90e.html#toc-heading-1</a></li><li>…</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1906785&quot;&gt;https://cloud.tencent.com/developer/article/1906785&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="随机BUG" scheme="http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
    <category term="emoji" scheme="http://example.com/tags/emoji/"/>
    
  </entry>
  
  <entry>
    <title>理清 Java 容器（集合）</title>
    <link href="http://example.com/2023/10/20/2023-10-20-%E7%90%86%E6%B8%85%20Java%20%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <id>http://example.com/2023/10/20/2023-10-20-%E7%90%86%E6%B8%85%20Java%20%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/</id>
    <published>2023-10-20T09:13:55.270Z</published>
    <updated>2023-10-22T14:46:43.519Z</updated>
    
    <content type="html"><![CDATA[<h1>Java容器概述</h1><p>Java中的容器，也就是Java 集合，是一套用于存储和组织数据的对象。容器类提供了一种将多个对象集合在一起的方式，并提供了一组方法来管理和操作这些对象。</p><h2 id="为什么要使用Java容器？">为什么要使用Java容器？</h2><p>当我们需要存储一组类型相同的数据时，<strong>数组</strong>是最常用且最基本的容器之一。但是，在实际开发中，存储的数据类型多种多样且数量不确定，使用数组存储对象就会存在一些不足之处。与数组相比，Java 容器提供了更灵活、更有效的方法来存储多个数据对象。Java 容器框架中的各种容器类和接口可以存储不同<strong>类型和数量</strong>的对象，同时还具有多样化的操作方式。</p><p>相较于数组，Java 容器的优势有：</p><ul><li>大小可变</li><li>支持泛型</li><li>具有内建算法</li></ul><p>总的来说，Java 容器提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p><h2 id="Java-容器概览">Java 容器概览</h2><p>Java容器主要派生自两大接口：<code>Collection</code>接口和<code>Map</code>接口。前者主要用于存放单一元素，后者则主要用于存放键值对。对于<code>Collection</code>接口，其有三个主要的子接口：<code>List</code>接口、<code>Queue</code>接口、<code>Set</code>接口。Java容器的系统结构可参考下图：</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E7%BB%9F.png" alt="java容器系统"></p><blockquote><p>分享来源：<a href="https://www.processon.com/view/616d69c3e0b34d7c7dba91f7?fromnew=1">processon-java集合系统</a>。</p></blockquote><p><strong>List, Set, Queue, Map对比</strong></p><table><thead><tr><th>接口</th><th>主要用途</th><th style="text-align:center">元素是否有序</th><th style="text-align:center">元素是否可重复</th></tr></thead><tbody><tr><td>List</td><td>处理顺序相关问题</td><td style="text-align:center"><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align:center"><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr><tr><td>Set</td><td>注重独一无二</td><td style="text-align:center"></td><td style="text-align:center"><span class="github-emoji"><span>✖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2716.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr><tr><td>Queue</td><td>排队功能相关</td><td style="text-align:center"><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align:center"><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr><tr><td>Map</td><td>基于key进行搜索</td><td style="text-align:center"></td><td style="text-align:center">key：<span class="github-emoji"><span>✖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2716.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  value:<span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr><tr><td></td><td></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h1>List</h1><p>List接口是用来处理顺序相关问题的很好的工具，其特点是存储的元素是有序的、可重复的。List接口最常用的实现类包括了 <code>LinkedList</code>、<code>ArrayList</code>、<code>Stack</code>以及<code>Vector</code>等，其中<code>Stack</code>类是<code>Vector</code>类的子类。</p><p>List的JDK源码为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; </span><br></pre></td></tr></tbody></table></figure><h2 id="底层数据结构">底层数据结构</h2><ul><li><p><code>ArrayList</code>：<code>ArrayList</code>是一个可以<strong>动态增长</strong>的数组，其底层数据结构是 <code>Object[]</code>数组，在JDK源码中有如下的定义（已省略javadoc）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br></pre></td></tr></tbody></table></figure><blockquote><p>在Java中，<code>transient</code> 关键字用于修饰类的<strong>实例变量</strong>。当一个实例变量被标记为 <code>transient</code> 时，它告诉Java的序列化机制不要将该变量的值持久化（即不要将其写入对象的序列化表示中），而只序列化对象的其他部分。这在对象序列化和反序列化时非常有用。</p></blockquote></li><li><p><code>LinkedList</code>：该类继承了<code>AbstractSequentialList</code>抽象类，底层的数据结构是双向链表，使用泛型定义链表节点，JDK源码（JDK17）为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>Vector</code>：该类的底层数据结构同样为<code>Object[]</code>数组，JDK源码中的定义为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>Stack</code>：继承了<code>Vector</code>类，底层的数据结构与<code>Vector</code>一致。</p></li></ul><h2 id="ArrayList">ArrayList</h2><blockquote><p>推荐阅读这位大佬的文章：<a href="https://juejin.cn/post/7288963211071094842">我说ArrayList初始容量是10，面试官让我回去等通知</a>。</p></blockquote><h3 id="ArrayList-v-s-Array">ArrayList v.s. Array</h3><blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>此处的 Array 指的是普通数组，而非 <code>java.lang</code>、<code>java.sql</code> 中封装的Array类。</p></blockquote><p><code>ArrayList</code> 是一个可动态增长的数组，内部基于了动态数组实现，相较于 <code>Array</code> ，在使用上更加灵活。二者的主要区别有：</p><ul><li><p><code>ArrayList</code> 会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能再改变其长度。</p></li><li><p><code>ArrayList</code> 中只能存储对象。对于基本类型（int、double、boolean等）数据，需要使用其对应的包装类（如 int – &gt; Integer、double --&gt; Double、boolean --&gt; Boolean 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</p></li><li><p><code>ArrayList</code> 支持插入、删除、遍历常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</p></li><li><p><code>ArrayList</code> 中使用泛型来根据需要确定存储数据的类型，确保了类型安全。<code>Array</code> 无此特性。</p></li><li><p><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</p><blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>并不是说  ArrayList 创建时不能指定。特定情景下，指定大小可以减少容量重新分配的频率。示例代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始容量为1000</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>); </span><br></pre></td></tr></tbody></table></figure></blockquote></li></ul><p>关于二者的示例可参考以下代码：</p><p><code>Array</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 初始化一个长度为4的String数组,两种初始化方式</span></span><br><span class="line">        String[] strArr1 = <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"Amazing"</span>, <span class="string">"Java"</span>, <span class="string">"Container"</span>, <span class="string">"!"</span>};</span><br><span class="line">        String[] strArr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下标访问为数组赋值，arraycopy方法</span></span><br><span class="line">        System.arraycopy(strArr1, <span class="number">0</span>, strArr2, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(strArr2));   <span class="comment">// [Amazing, Java, Container, !]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改元素的值</span></span><br><span class="line">        strArr2[<span class="number">0</span>] = <span class="string">"Plain"</span>;</span><br><span class="line">        System.out.println(Arrays.toString(strArr2));   <span class="comment">// [Plain, Java, Container, !]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除数组中的元素，假设删除 “Container”，需要手动移动后面的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; strArr2.length - <span class="number">1</span>; i++) {</span><br><span class="line">            strArr2[i] = strArr2[i+<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        strArr2[strArr2.length - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(Arrays.toString(strArr2));   <span class="comment">// [Plain, Java, !, null]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>ArrayList</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 初始化一个 String 类型的 ArrayList</span></span><br><span class="line">        ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">"Amazing"</span>, <span class="string">"Java"</span>, <span class="string">"Container"</span>, <span class="string">"!"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到 ArrayList 中</span></span><br><span class="line">        strList.add(<span class="string">"Yeah"</span>);</span><br><span class="line">        System.out.println(strList);    <span class="comment">// [Amazing, Java, Container, !, Yeah]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 ArrayList 中的元素</span></span><br><span class="line">        strList.set(<span class="number">0</span>, <span class="string">"Plain"</span>);</span><br><span class="line">        System.out.println(strList);    <span class="comment">// [Plain, Java, Container, !, Yeah]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 ArrayList 中的元素</span></span><br><span class="line">        strList.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(strList);    <span class="comment">// [Java, Container, !, Yeah]</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="ArrayList-v-s-Vector">ArrayList v.s. Vector</h3><ol><li>线程安全</li></ol><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</li><li><code>Vector</code> 是线程安全的，它的方法都经过同步处理，可以在多线程环境中使用而无需额外的同步措施。然而，这也会导致 <code>Vector</code> 在性能上相对较慢，因为同步操作会带来额外的开销。</li></ul><ol start="2"><li>扩容机制</li></ol><ul><li><code>ArrayList</code> 的扩容机制是不同步的，即在需要扩容时，它会创建一个新的数组，并将元素从旧数组复制到新数组。这可以在某些情况下导致不同步问题，但在单线程环境中通常性能较好。</li><li><code>Vector</code> 的扩容机制是同步的，确保只有一个线程可以进行扩容操作。这也可能导致性能问题，特别是在高度并发的情况下。</li></ul><p>此外，<code>Vector</code> 是Java早期版本提供的，它的设计考虑了线程安全，但在现代Java编程中，通常更推荐使用其他集合类，如 <code>ArrayList</code> 和 <code>Collections</code> 工具类，来处理线程安全问题。Vector通常被认为是一种遗留的数据结构。</p><h3 id="ArrayList插入和删除元素的时间复杂度">ArrayList插入和删除元素的时间复杂度</h3><ul><li><p><strong>头部插入/删除</strong></p><p>当在头部插入元素时，需要将现有的元素向后移动，以便为新元素腾出空间。这涉及到将所有元素都向后移动一个位置。</p><p>时间复杂度为：O(n)，其中n是ArrayList中的元素数量。</p></li><li><p><strong>尾部插入/删除</strong></p><p>在ArrayList的尾部插入元素是比较高效的，因为不需要移动其他元素。时间复杂度：平均情况为O(1)，即常数时间。</p><p>但在某些情况下，可能需要重新分配内部数组，如当内部数组的容量不足时，需要进行重新分配和复制元素的操作。这会引入O(n)的时间复杂度，其中n是ArrayList的容量。这种情况下会偶尔发生，大部分时间都是O(1)。</p></li><li><p><strong>指定位置插入/删除</strong></p><p>当在ArrayList的中间或指定位置插入元素时，需要将插入点之后的元素向后移动，以便为新元素腾出空间。时间复杂度平均情况为O(n)。</p></li></ul><h3 id="ArrayList源码浅析">ArrayList源码浅析</h3><p>前文提及，<code>ArrayList</code> 的底层是数组队列，实现了一个动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。</p><h4 id="实现与继承关系">实现与继承关系</h4><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。可参考 JDK 源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></tbody></table></figure><p>具体类的实现、继承关系可视化如下图。</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/ArrayList%E7%B1%BB%E5%9B%BE.png" alt="ArrayList类图"></p><p>从定义中可以得出以下信息：</p><ul><li><p>指定了泛型类型参数 <code>E</code>，这表示 ArrayList 可以存储任意类型的对象。</p></li><li><p>实现了 List 接口，这意味着它遵循 List 接口中定义的方法和行为。List 接口表示一个有序的集合，可以包含重复元素。</p></li><li><p>实现了 RandomAccess 接口，这是一个标记接口，用于指示 ArrayList 支持随机访问（通过索引访问元素）。由于 ArrayList 是一个动态数组，它能够以常数时间复杂度（O(1)）进行随机访问。</p></li><li><p>实现了 Cloneable 接口，这意味着可以使用 <code>clone()</code> 方法来创建 ArrayList 的副本。</p><blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>clone()</code> 方法返回的是浅拷贝，所以元素本身不会被复制，只是引用会被复制。</p></blockquote></li><li><p>实现了 <code>Serializable</code> 接口，这使得它可以被序列化为字节流，以便在网络传输或保存到文件中。这允许将 ArrayList 对象持久化。</p></li></ul><h4 id="初始化方法-扩容机制">初始化方法&amp;扩容机制</h4><blockquote><p>推荐阅读这位大佬的文章：<a href="https://juejin.cn/post/7288963211071094842">我说ArrayList初始容量是10，面试官让我回去等通知</a>。</p></blockquote><p>ArrayList 给出了种初始化方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享的空数组实例,用于默认大小的空实例。 将其与EMPTY_ELEMENTDATA区分开来,便于了解当添加第一个元素时需要膨胀多少</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 非私有以简化嵌套类访问</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> {</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">  *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) {</span><br><span class="line">            elementData = a;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用ArrayList的无参构造方法 <code>new ArraryList&lt;&gt;()</code> 的时候，只是初始化了一个空对象，并没有指定数组大小，所以初始容量是零。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</p><h2 id="LinkedList">LinkedList</h2><h3 id="LinkedList-v-s-ArrayList">LinkedList v.s.  ArrayList</h3><table><thead><tr><th>对比维度</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>内部实现</td><td>动态 <code>Object</code> 数组</td><td>双向链表</td></tr><tr><td>线程安全</td><td>不同步，线程不安全</td><td>不同步，线程不安全</td></tr><tr><td>插入删除操作</td><td>效率取决于操作位置</td><td>插入和删除操作通常更高效</td></tr><tr><td>随机访问</td><td>支持高效的随机访问</td><td>不支持高效的随机访问</td></tr><tr><td>空间开销</td><td>通常具有<strong>较小的</strong>空间开销</td><td>通常具有<strong>较大的</strong>空间开销</td></tr><tr><td>迭代</td><td>数组连续存储的性质，迭代更快</td><td>迭代较慢</td></tr></tbody></table><blockquote><ul><li>因为 <code>ArrayList</code>只需要存储<strong>元素</strong>和数组的一些<strong>元数据</strong>（如容量），空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间；而 <code>LinkedList</code> 需要存储每个元素以及两个指向前一个和后一个元素的引用（指针），空间开销会比 <code>ArrayList</code> 大</li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li></ul></blockquote><h3 id="LinkedList源码浅析">LinkedList源码浅析</h3><h4 id="实现与继承关系-2">实现与继承关系</h4><p>JDK中 <code>LinkedList</code> 类的定义源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></tbody></table></figure><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。此外，<code>LinkedList</code> 实现了4个接口：<code>List</code>、<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code>。类图可视化为：</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/LinkedList%E7%B1%BB%E5%9B%BE.png" alt="LinkedList类图"></p><p><code>LinkedList</code> 实现的接口中，<code>List</code>、<code>Cloneable</code>、<code>Serializable</code> 与ArrayList一样，不再赘述；</p><p>此外，<code>LinkedList</code> 实现了 <code>Deque</code> 接口，这是双端队列（Double-ended Queue）的接口，它表示具有队列和栈的行为。<code>LinkedList</code> 可以被用作队列和栈，支持在队列的两端进行插入和删除操作。</p><blockquote><p><code>LikedList</code> 作为栈和队列使用可参考：<a href="https://liangshoux.github.io/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">Java中的栈与队列</a>。</p></blockquote><h4 id="元素定义">元素定义</h4><p><code>LinkedList</code> 中的元素是通过内部静态类 <code>Node</code> 定义的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="初始化方法">初始化方法</h4><p><code>LinkedList</code> 中有设计了两种构造方法：一个无参构造函数、一个有参构造函数，具体源码为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的链表对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li><code>this()</code> 表明在有参构造时，调用了类的另一个构造函数，即无参数构造函数。这意味着在创建 LinkedList 对象时，首先会调用无参数构造函数来初始化对象。</li><li><code>addAll</code> 方法是类内实现的方法，作用为将集合 <code>c</code> 中的元素添加到当前 <code>LinkedList</code> 对象中。</li></ul></blockquote><h4 id="常用方法总结">常用方法总结</h4><table><thead><tr><th>操作</th><th>方法</th><th>简述</th><th>备注</th></tr></thead><tbody><tr><td>插入</td><td><code>add(E e)</code></td><td>在尾部插入元素</td><td><code>linkLast(E e)</code></td></tr><tr><td></td><td><code>add(int index, E element)</code></td><td>在指定位置插入元素</td><td><code>linkLast(E e)</code> &amp; <code>linkBefore(E e, Node&lt;E&gt; succ)</code></td></tr><tr><td>获取元素</td><td><code>getFirst()</code></td><td>获取链表的第一个元素</td><td><code>LinkedList.first</code></td></tr><tr><td></td><td><code>getLast()</code></td><td>获取链表的最后一个元素</td><td><code>LinkedList.last</code></td></tr><tr><td></td><td><code>get(int index)</code></td><td>获取链表指定位置的元素</td><td><code>node&lt;index&gt;</code></td></tr><tr><td>删除元素</td><td><code>removeFirst()</code></td><td>删除并返回链表的第一个元素</td><td><code>unlinkFirst&lt;Node&lt;E&gt;&gt;</code></td></tr><tr><td></td><td><code>removeLast()</code></td><td>删除并返回链表的最后一个元素</td><td><code>unlinkLast&lt;Node&lt;E&gt;&gt;</code></td></tr><tr><td></td><td><code>remove(E e)</code></td><td>删除链表中首次出现的指定元素，如果不存在该元素则返回 false</td><td><code>unlink&lt;Node&lt;E&gt;&gt;</code></td></tr><tr><td></td><td><code>remove(int index)</code></td><td>删除指定索引处的元素，并返回该元素的值</td><td><code>unlink&lt;Node&lt;E&gt;&gt;</code></td></tr><tr><td></td><td><code>void clear()</code></td><td>移除此链表中的所有元素</td><td></td></tr><tr><td>迭代器</td><td><code>ListItr</code></td><td>实现了<code>ListIterator&lt;E&gt;</code>接口，是能够使用<code>for-each</code>遍历的核心</td><td></td></tr></tbody></table><h4 id="demo">demo</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建 LinkedList 对象</span></span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到链表末尾</span></span><br><span class="line">        list.add(<span class="string">"apple"</span>);</span><br><span class="line">        list.add(<span class="string">"banana"</span>);</span><br><span class="line">        list.add(<span class="string">"pear"</span>);</span><br><span class="line">        System.out.println(<span class="string">"链表内容："</span> + list);     <span class="comment">// [apple, banana, pear]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">"orange"</span>);</span><br><span class="line">        System.out.println(<span class="string">"链表内容："</span> + list);     <span class="comment">// [apple, orange, banana, pear]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定位置的元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"索引为 2 的元素："</span> + fruit);   <span class="comment">// banana</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指定位置的元素</span></span><br><span class="line">        list.set(<span class="number">3</span>, <span class="string">"grape"</span>);</span><br><span class="line">        System.out.println(<span class="string">"链表内容："</span> + list);     <span class="comment">// [apple, orange, banana, grape]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"链表内容："</span> + list);     <span class="comment">// [orange, banana, grape]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除第一个出现的指定元素</span></span><br><span class="line">        list.remove(<span class="string">"banana"</span>);</span><br><span class="line">        System.out.println(<span class="string">"链表内容："</span> + list);     <span class="comment">// [orange, grape]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取链表的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        System.out.println(<span class="string">"链表长度："</span> + size);     <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空链表</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">"清空后的链表："</span> + list);   <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Vector-Stack">Vector &amp; Stack</h2><p>可参考：<a href="https://liangshoux.github.io/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">Java中的栈与队列</a></p><h1>Set</h1><p>Set在数学中是集合的意思，<code>Set</code>接口组织数据的特点是<strong>注重独一无二的性质</strong>，存储的元素不可重复的。</p><h2 id="底层数据结构-2">底层数据结构</h2><ul><li><p><code>HashSet</code>：HashSet 的特点是<strong>无序性</strong>和<strong>唯一性</strong>，底层采用了<code>HashMap</code>来存储数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>LinkedHashSet</code>：HashSet的子类，内部实现通过<code>LinkedHashMap</code>，通过<code>supper</code>调用父类的构造方法，HashSet中定义的源码为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) {</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>TreeSet</code>：区别于<code>HashSet</code>，TreeSet的特点是<strong>有序</strong>且<strong>唯一</strong>的，底层采用了红黑树的数据结构实现。实际上，JDK17中，TreeSet类实现的是<code>NavigableMap</code> 接口，而后者继承了<code>SortedMap</code>接口。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">    </span><br><span class="line"><span class="comment">// NavigableSet接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">SortedMap</span>&lt;K,V&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="HashSet">HashSet</h2><h2 id="LinkedHashSet">LinkedHashSet</h2><h2 id="TreeSet">TreeSet</h2><h1>Queue</h1><p>Queue（队列）中，按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><h2 id="底层数据结构-3">底层数据结构</h2><ul><li><code>PriorityQueue</code>：底层是使用 <code>Object[]</code> 数组来实现小顶堆。</li><li><code>DelayQueue</code>：<code>PriorityQueue</code>。</li><li><code>ArrayDeque</code>:：可扩容动态双向数组。</li></ul><h1>Map</h1><p>使用键值对（key-value）存储，类似于数学上的函数的一个key对应唯一value的关系，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p><h2 id="底层数据结构-4">底层数据结构</h2><p><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p><p><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</p><p><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java容器概述&lt;/h1&gt;
&lt;p&gt;Java中的容器，也就是Java 集合，是一套用于存储和组织数据的对象。容器类提供了一种将多个对象集合在一起的方式，并提供了一组方法来管理和操作这些对象。&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用Java容器？&quot;&gt;为什么要使用Java容器？&lt;</summary>
      
    
    
    
    <category term="Java手账本" scheme="http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 常识？我咋不知道</title>
    <link href="http://example.com/2023/10/19/2023-10-19-%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%E5%B8%B8%E8%AF%86/"/>
    <id>http://example.com/2023/10/19/2023-10-19-%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%E5%B8%B8%E8%AF%86/</id>
    <published>2023-10-19T15:51:41.429Z</published>
    <updated>2023-10-20T08:56:14.096Z</updated>
    
    <content type="html"><![CDATA[<h1>Java SE，Java EE &amp; Java ME？</h1><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/Java技术平台关系图.png" alt="Java技术平台关系图" style="zoom:67%;"><p>有没有想过，同样是Java，会不会存在不同的版本 or anything else？事实上，为了使软件开发人员、服务提供商和设备生产商可以针对特定的市场进行开发，SUN公司将Java划分为三个技术平台：</p><ul><li>Java SE：Standard Edition（标准版）</li><li>Java EE：Enterprise Edition（商业版）</li><li>Java ME：Micro Edition（小型版）</li></ul><h2 id="Java-SE">Java SE</h2><p>全称为Java Platform Standard Edition，这是Java 平台标准版，包含标准的 JVM和标准库，更具体地说，包括了 Java 核心的类库，如集合、IO、数据库连接以及网络编程等。</p><p>JavaSE 是Java 编程语言的基础，三个核心平台中的核心部分，Java EE 和 Java ME 都是从 JavaSE的基础上发展而来的</p><p>JavaSE是为开发<strong>普通桌面</strong>和<strong>商务应用程序</strong>提供的解决方案。</p><h2 id="Java-EE">Java EE</h2><p>全称是 Java Platform Enterprise Edition，Java 平台企业版，建立在 Java SE 的基础上，并加入了大量的 API 和库，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。</p><p>Java EE是进一步学习Web应用所必须的，Spring等框架都是Java EE开源生态系统的一部分。</p><p>JavaEE 是为开发<strong>企业级应用程序</strong>提供的解决方案。</p><h2 id="Java-ME">Java ME</h2><p>全称是 Java Platform Micro Edition，Java平台小型版，是一个针对 <strong>嵌入式设备</strong> 的 “瘦身版”，要用于小型数字电子设备上软件程序的开发，例如家用电器的智能化、联网功能等。</p><p>此外，JavaME提供了HTTP等高级Internet协议，使移动电话能以Client/ Server方式直接访问 Internet的全部信息，提供最效率的无线交流。</p><p>JavaME 是为开发电子消费产品和嵌入式设备提供的解决方案。然而Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，只需要了解即可。</p><h1>JDK，JVM &amp; JRE？</h1><blockquote><p>Java文档官网：<a href="https://docs.oracle.com/en/java/index.html">https://docs.oracle.com/en/java/index.html</a></p></blockquote><p>立即推(张宇老师口吻)：这题我会！事实上，这个问题倒是比较容易理解。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/jdk&amp;jvm.png" alt="jdk&amp;jvm" style="zoom:67%;"><blockquote><p>详细信息可参考：<a href="https://www.oracle.com/java/technologies/platform-glance.html">官方架构图</a>。</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/java8-conceptual-design.jpg" alt="img"></p></blockquote><h2 id="JVM-JIT">JVM &amp; JIT</h2><p>JVM 即 Java 虚拟机，是运⾏ Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。</p><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时⽐较⾼效</p><p>⽽且，由于字节码并不针对⼀种特定的机器，因此，Java 程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。</p></blockquote><p>Java 程序从源代码到编译运⾏⼀般需要经历以下的过程：</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/Java%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java源码编译运行过程"></p><blockquote><p>事实上，可以运行在 Java 虚拟机上的语言除了 Java外还有很多，如Groovy(.groovy)、Kotlin(.kt)、JRuby(.rb)、Clojure(.clj)等，它们编译运行的过程大致相似，经过对应的编译器编译为 .class字节码文件。</p></blockquote><p>这里需要格外注意的是 <code>.class --&gt; 机器码</code> 这⼀步。在这⼀步 JVM 类加载器⾸先加载字节码⽂件，然后通过 <strong>解释器</strong> 逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐较慢。⽽且，有些⽅法和代码块是经常需要被调⽤的(也就是所谓的热点代码)，所以后⾯引进了 JIT （Just in Time Compilation）编译器，⽽ JIT 属于运⾏时编译。当 JIT 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。⽽我们知道，机器码的运⾏效率肯定是⾼于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><p>于是引入 JIT 后，程序从源代码到编译运⾏经历的过程具体为：</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/Java%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B-JIT.png" alt="Java源码编译运行过程-JIT"></p><h2 id="JDK-JRE">JDK &amp; JRE</h2><p>JDK 是 Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</p><p>如果只是为了运⾏⼀下 Java 程序的话，只需要安装 JRE 就可以了。如果需要进⾏⼀些Java 编程⽅⾯的⼯作，那么就需要安装 JDK 了。</p><blockquote><p>这也不是绝对的。有时，即使不打算在计算机上进⾏任何 Java 开发，仍然需要安装 JDK。例如，如果要使⽤ JSP 部署 Web 应⽤程序，那么从技术上讲，只是在应⽤程序服务器中运⾏ Java 程序。</p><p>但是因为应⽤程序服务器会将 JSP 转换为 Java servlet，并且需要使⽤ JDK 来编译 servlet，还是需要安装JDK</p></blockquote><h1>编译与解释并存？</h1><p>参考JVM部分，可知 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p><h1>AOT &amp; JIT？</h1><blockquote><p>可参考：<a href="https://www.modb.pro/db/190497">理解Java的JIT和AOT</a>，<a href="https://juejin.cn/post/7184712312983388217#heading-0">JIT v.s. AOT in Java</a>。</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/jit-vs-aot.png" alt="jit-vs-aot"></p></blockquote><p>JIT是Just-In-Time的首字母缩写，指程序<strong>运行期间</strong>发生的编译行为。</p><ul><li>JIT多伴随解释器，因为解释型语言是按行解释执行，JIT将“常用”功能编译为机器码，需要时直接执行，减少解释时间；</li><li><em>例如：Python(pypy)，新版Javascript、Ruby、Php解释器；</em></li></ul><p>AOT是Ahead-Of-Time的首字母缩写，指程序<strong>运行之前</strong>发生的编译行为。</p><ul><li>对于编译型语言，AOT啥也不是，本身就是先编译后执行，但对于解释型语言，AOT提前“预见”热点功能，并编译为机器码，同样减少解释时间；</li><li><em>例如：C，C++，Rust，Go，Java AOT；</em></li></ul><p>AOP是JDK 9 引入了一种新的编译模式，主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java SE，Java EE &amp;amp; Java ME？&lt;/h1&gt;
&lt;img src=&quot;https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/Java技术平台关系图.png&quot; alt=&quot;Java技术平台关系</summary>
      
    
    
    
    <category term="Java手账本" scheme="http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>链表刷题—Java版</title>
    <link href="http://example.com/2023/10/17/2023-10-17-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E2%80%94Java%E7%89%88/"/>
    <id>http://example.com/2023/10/17/2023-10-17-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E2%80%94Java%E7%89%88/</id>
    <published>2023-10-17T12:07:36.377Z</published>
    <updated>2023-10-20T06:44:40.896Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1>前言</h1><p>链表是通过<strong>指针</strong>串联在一起的<strong>线性结构</strong>，指针是其中的一个重要部分。简单了解指针的概念：</p><blockquote><p>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。</p></blockquote><p>就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var-name</span><br></pre></td></tr></tbody></table></figure><p>在C/C++等语言中，都显式地定义了指针用于直接访问内存地址的机制，然而学习 Java 的人或多或少都听说过“Java没有指针”。</p><p>Java的设计目标之一是提供一种更安全和易于学习的编程语言。为了实现这一目标，Java采用了一种自动内存管理的方式，即垃圾回收机制。Java引入了<strong>引用</strong>（reference）的概念，但不允许直接访问内存地址。这意味着在Java中，并不能像C或C++中那样使用指针来操作内存。这种设计决策有助于减少内存管理错误和提高安全性。关于更多Java指针的理解，可参考 <a href="https://zhuanlan.zhihu.com/p/131612029">知乎专栏—Java真的没有“指针”吗？</a>。</p><p>关于链表的基础理论，本文不再赘述，可参考：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录-链表基础理论</a>。</p><p>Java 链表的实现方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>设计链表</h1><blockquote><p>题目链接：</p><p><a href="https://leetcode.cn/problems/design-linked-list/">LC707. 设计链表</a></p></blockquote><h1>移除链表元素</h1><blockquote><p>题目链接：</p><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">LC203. 移除链表元素</a>;</p><p><a href="https://www.nowcoder.com/share/jump/8214310031697562609849">BM9删除链表的倒数第n个节点</a></p></blockquote><p>因为是单链表，从前往后遍历，假如当前访问结点的 val 是要移除的，无法很好地定位到当前节点的前一个节点；另外就是需要考虑头结点可能为需要移除的结点的情况。综合来看，可以有三种移除方式：不设置 pre 节点和虚拟节点、仅设置pre节点、同时设置pre节点和虚拟节点。</p><h2 id="LC203">LC203</h2><h3 id="不设置-pre-节点和-虚拟节点">不设置 pre 节点和 虚拟节点</h3><p>分两步考虑：首先处理掉头结点需要移除的情况，之后判断 curr.next 节点是否需要移除。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val){</span><br><span class="line">            <span class="comment">// 处理头结点要移除的情况</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>){</span><br><span class="line">            <span class="comment">// curr的下一个节点</span></span><br><span class="line">            <span class="keyword">while</span>(curr.next != <span class="literal">null</span> &amp;&amp; curr.next.val == val){</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            }</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="仅设置pre节点">仅设置pre节点</h3><p>同上一种方式，首先处理掉头结点需要移除的情况，之后使用 pre 节点指向 curr 的前一个节点，遍历中只需要关注 curr 节点的 val。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val){</span><br><span class="line">            <span class="comment">// 处理头结点要移除的情况</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">if</span>(curr.val == val){</span><br><span class="line">                pre.next = curr.next;                </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                pre = pre.next;              </span><br><span class="line">            }</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="同时设置-pre-节点和-虚拟节点">同时设置 pre 节点和 虚拟节点</h3><p>这样做的好处在于，移除头结点和普通节点的逻辑可以统一，即原链表的所有节点就都可以按照统一的方式进行移除，使用 dummy.next 定位头结点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">       <span class="comment">// 设置虚拟节点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(curr != <span class="literal">null</span>){</span><br><span class="line">           <span class="keyword">if</span>(curr.val == val){</span><br><span class="line">               pre.next = curr.next;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">else</span>{</span><br><span class="line">               pre = curr;</span><br><span class="line">           }</span><br><span class="line">           curr = curr.next;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="BM9">BM9</h2><h3 id="index定位">index定位</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 确定链表的长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            len++;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> len - n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>){</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定位到要移除的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; index; i++){</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="滑动窗口">滑动窗口</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 向前移动 first 指针，使 first和 second 之间的间隔为n个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) {</span><br><span class="line">            first = first.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 同时移动 first 和 second</span></span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span>) {</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        }</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1>翻转链表</h1><blockquote><p>题目链接：</p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">LC206 反转链表</a>。</p></blockquote><p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p><p>接下来，就是循环走以上代码逻辑了，继续移动pre和cur指针。</p><p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>){</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>链表相交</h1><h1>环形链表</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;链表是通过&lt;strong&gt;指针&lt;/strong&gt;串联在一起的&lt;strong&gt;线性结构&lt;/strong&gt;，指针是其中的一个重要部分。简单了解指针的概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指针是一个变量，其值为另一个变量</summary>
      
    
    
    
    <category term="刷题日记" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="NowCoder" scheme="http://example.com/tags/NowCoder/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL—— 基础理论概念</title>
    <link href="http://example.com/2023/10/17/2023-10-17-MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/10/17/2023-10-17-MySQL%E5%9F%BA%E7%A1%80/</id>
    <published>2023-10-17T01:01:41.415Z</published>
    <updated>2023-10-17T03:57:40.032Z</updated>
    
    <content type="html"><![CDATA[<h1>MySQL概述</h1><h2 id="1-数据库相关概念">1. 数据库相关概念</h2><p>首先辨析三个概念：数据库、数据库管理系统、SQL</p><table><thead><tr><th>名称</th><th>含义</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>存储数据的仓库，数据是有组织地进行存储</td><td>DataBase(DB)</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System(DBMS)</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong></td><td>Structured Query Language(SQL)</td></tr></tbody></table><p>各大主流 DBMS 的排名参考 <a href="https://db-engines.com/en/ranking">DB-Engines Ranking</a>，</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231017092505034.png" alt="image-20231017092505034"></p><ul><li>Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。</li><li>MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。</li><li>SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。</li><li>PostgreSQL：开源免费的中小型数据库。</li><li>DB2：IBM公司的大型收费数据库产品。</li><li>SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。</li></ul><p>而不论我们使用的是上面的哪一个关系型数据库，最终在操作时，都是使用SQL语言来进行统一操作，因为SQL语言，是操作关系型数据库的 <strong>统一标准</strong> 。</p><h2 id="2-MySQL数据库">2. MySQL数据库</h2><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/%E4%B8%8B%E8%BD%BD.png" alt="MySQL"></p><p>官网地址： <a href="https://www.mysql.com/">https://www.mysql.com/</a></p><p>MySQL官方提供了两种不同的版本：</p><ul><li><p>社区版本（MySQL Community Server）</p><p>免费， MySQL不提供任何技术支持</p></li><li><p>商业版本（MySQL Enterprise Edition）</p><p>收费，可以使用30天，官方提供技术支持</p></li></ul><p><strong>安装与配置</strong>教程参考 <a href="https://zhuanlan.zhihu.com/p/37152572">知乎-smi安装</a>、<a href="https://www.cnblogs.com/GCTTT/p/17321192.html">博客园-压缩包安装</a>。</p><h2 id="3-数据模型">3. 数据模型</h2><h3 id="1-关系型数据库-RDBMS">1) 关系型数据库(RDBMS)</h3><p>概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p><p>所谓二维表，指的是由行和列组成的表，类似于Excel表格数据，有表头、有列、有行，还可以通过一列关联另外一个表格中的某一列数据。上述的MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。</p><p>特点：</p><ul><li>使用表存储数据，格式统一，便于维护。</li><li>使用SQL语言操作，标准统一，使用方便。</li></ul><h3 id="2-数据模型">2) 数据模型</h3><p>MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构如图:</p><p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231017100042364.png" alt="image-20231017100042364"></p><ul><li>可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。</li><li>可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。</li><li>一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录</li></ul><h1>SQL</h1><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong> 。</p><h2 id="1-SQL通用语法">1. SQL通用语法</h2><ol><li>SQL语句可以单行或多行书写，以分号结尾;</li><li>SQL语句可以使用空格/缩进来增强语句的可读性;</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写;</li><li>注释：</li><li>单行注释：-- 注释内容 或 # 注释内容</li><li>多行注释：/* 注释内容 */</li></ol><h2 id="2-SQL分类">2. SQL分类</h2><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的</td></tr></tbody></table><h2 id="3-DDL——数据定义语言">3. DDL——数据定义语言</h2><p>Data Definition Language  数据定义语言，用来定义数据库对象(数据库，表，字段)</p><h3 id="数据库操作">数据库操作</h3><ol><li>查询所有数据库</li><li>查询当前数据库</li><li>创建数据库</li><li>删除数据库</li><li>切换数据库</li></ol><h3 id="表操作">表操作</h3><h4 id="查询创建">查询创建</h4><ol><li>查询当前所有表</li><li>查看指定表结构</li><li>查询指定表的建表语句</li><li>创建表结构</li></ol><h4 id="MySQL的数据类型">MySQL的数据类型</h4><p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><ol><li><p>数值类型</p><table><thead><tr><th>类型</th><th>大小(BYTE)</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>(-128,127)</td><td>…</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2</td><td>(-32768,32768)</td><td>…</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>(-8388608,8388607)</td><td>…</td><td>大整数值</td></tr><tr><td>INT/INTEGER</td><td>4</td><td>(-2^31, 2^31-1)</td><td>…</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8</td><td>(-2^63, 2^63-1)</td><td>…</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4</td><td>…</td><td>…</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8</td><td>…</td><td>…</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>依赖于精度M和标度D的值</td><td>…</td><td>小数值</td></tr></tbody></table></li><li><p>字符串类型</p><table><thead><tr><th>类型</th><th>大小(byte)</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINITEXT</td><td>0-255</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65535</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65535</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16777215</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MIDEUMTEXT</td><td>0-16777215</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4294967295</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4294967295</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- 1) 用户名 username ------&gt; 长度不定，最长不会超过50</span><br><span class="line">username varchar(50)</span><br><span class="line"></span><br><span class="line">--- 2) 性别  gender   ------&gt; 存储值，不是男就是女</span><br><span class="line">gender   char(1)</span><br><span class="line"></span><br><span class="line">--- 3) 手机号 phone   ------&gt; 固定长度11（仅限国内移动手机号）</span><br><span class="line">phone    char(11)</span><br></pre></td></tr></tbody></table></figure></li><li><p>日期时间类型</p><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>DATA</td><td>3</td><td></td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td></td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td></td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td></td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td></td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table></li></ol><h2 id="4-DML">4. DML</h2><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE）</li><li>删除数据（DELETE）</li></ul><h2 id="5-DQL">5. DQL</h2><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。</p><p>查询关键字: SELECT</p><p>在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。</p><h2 id="6-DCL">6. DCL</h2><p>DCL英文全称是<strong>Data Control Language</strong>(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。</p><h1>函数</h1><p>MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="字符串函数">字符串函数</h2><h3 id="内置函数一览">内置函数一览</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …sn)</td><td>字符串拼接，将s1，s2，… sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str, N, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><h3 id="演示用例">演示用例</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--- concat</span><br><span class="line">select concat("Hello", "World");</span><br><span class="line"></span><br><span class="line">--- lower &amp; upper</span><br><span class="line">select lower("Hello");</span><br><span class="line">select upper('Hello');</span><br><span class="line"></span><br><span class="line">--- lpad &amp; rpad</span><br><span class="line">select lpad('01', 5, '-');</span><br><span class="line">select rpad('01', 5, '-');</span><br><span class="line"></span><br><span class="line">--- trim去除空格</span><br><span class="line">select trim(' Hello MySQL ');</span><br><span class="line"></span><br><span class="line">--- substring</span><br><span class="line">select substring('Hello MySQL',1,5);</span><br></pre></td></tr></tbody></table></figure><h2 id="数值函数">数值函数</h2><h3 id="内置函数一览-2">内置函数一览</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h3 id="演示用例-2">演示用例</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--- ceil &amp; floor</span><br><span class="line">select ceil(1.1);</span><br><span class="line">select flooor(1.9);</span><br><span class="line"></span><br><span class="line">--- mod</span><br><span class="line">select mod(7,4);</span><br><span class="line"></span><br><span class="line">--- rand</span><br><span class="line">select rand();</span><br><span class="line"></span><br><span class="line">--- round</span><br><span class="line">select round(3.344, 2);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">通过数据库的函数，生成一个六位数的随机验证码。</span><br><span class="line">思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0</span><br><span class="line">*/</span><br><span class="line">select lpad(round(rand()*1000000 , 0), 6, '0');</span><br></pre></td></tr></tbody></table></figure><h2 id="日期函数">日期函数</h2><h2 id="流程函数">流程函数</h2><h1>约束</h1><h1>多表查询</h1><h1>事务</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MySQL概述&lt;/h1&gt;
&lt;h2 id=&quot;1-数据库相关概念&quot;&gt;1. 数据库相关概念&lt;/h2&gt;
&lt;p&gt;首先辨析三个概念：数据库、数据库管理系统、SQL&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;简称&lt;/th&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="后端" scheme="http://example.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java中的栈与队列</title>
    <link href="http://example.com/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2023-10-16T05:12:04.799Z</published>
    <updated>2023-10-20T06:41:20.189Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要记述 Java在实践中如何使用栈，关于栈与队列的基础知识点本文不再赘述，可参考 <a href="http://data.biancheng.net/view/169.html">编程帮-栈</a>、<a href="http://data.biancheng.net/view/300.html">编程帮-队列</a>。</p></blockquote><h1>栈</h1><h2 id="标准库-java-util-Stack-实现">标准库 <code>java.util.Stack</code> 实现</h2><p>在 <code>java.util</code> 中封装了 Stack 类，其继承自Vector类，定义了push、pop、peek、empty、search五个操作对Vector进行了扩展，JDK源码（已省去jdoc）如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Vector</span>&lt;E&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">push</span><span class="params">(E item)</span> {</span><br><span class="line">        addElement(item);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="type">int</span>     <span class="variable">len</span> <span class="operator">=</span> size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span>     <span class="variable">len</span> <span class="operator">=</span> size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(Object o)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1224463164541339165L</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Deque接口实现">Deque接口实现</h2><p>在Java中，栈可以使用<code>java.util.Stack</code>类实现，也可以使用 <code>java.util.LinkedList</code> 结合<code>push</code>和<code>pop</code>操作来实现自定义的栈。通常，建议使用 <code>Deque </code>接口中的 <code>LinkedList</code> 实现来代替<code>java.util.Stack</code>，因为后者是基于向量的数据结构，性能较差。</p><p>示例代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackByDeque</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(top + <span class="string">" "</span> + stack.size());</span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，值得注意的是 <code>LinkedList</code> 类。<code>LinkedList</code>是Java中的一个双向链表实现，它继承自<code>AbstractSequentialList</code>类，并实现了<code>List</code>和<code>Deque</code>接口，同时提供了双向链表的功能。JDK中的源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    ...</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure><p><code>LinkedList</code> 类有以下的特点：</p><ol><li><strong>双向链表</strong>: <code>LinkedList</code>是基于双向链表数据结构的实现，每个元素都被包装在一个节点中，而每个节点都包含指向前一个节点和后一个节点的引用。这使得在链表中插入和删除元素的操作非常高效，因为只需要调整节点的引用，而不需要移动其他元素。</li><li><strong>实现了List接口</strong>: <code>LinkedList</code>实现了<code>List</code>接口，这意味着它可以像<code>ArrayList</code>一样用于存储有序的元素集合，支持随机访问、按索引插入和删除元素。与<code>ArrayList</code>不同，<code>LinkedList</code>在插入和删除操作上通常更高效，但在随机访问上性能较差。</li><li><strong>实现了Deque接口</strong>: <code>LinkedList</code>还实现了<code>Deque</code>接口，这使得它可以被用作双端队列（double-ended queue）。您可以在队列的前端和后端进行插入和删除操作，支持先进先出（FIFO）和后进先出（LIFO）等不同的数据操作模式。</li><li><strong>适合用于栈和队列</strong>: 由于<code>LinkedList</code>支持双向操作，它特别适合用作栈和队列的基础数据结构。您可以使用<code>push</code>和<code>pop</code>操作来实现栈，使用<code>offer</code>和<code>poll</code>操作来实现队列。</li><li><strong>非线程安全</strong>: 与<code>ArrayList</code>不同，<code>LinkedList</code>是非线程安全的，这意味着在多线程环境下需要进行额外的同步处理，或者使用<code>java.util.concurrent</code>包中的并发数据结构来保证线程安全。</li><li><strong>动态大小</strong>: <code>LinkedList</code>的大小是动态的，它会根据需要动态分配内存。这意味着它可以容纳任意数量的元素，但需要根据实际使用情况分配和释放内存，可能会引入一些内存管理开销。</li></ol><p><code>LinkedList</code>是一个灵活的双向链表实现，适合用于需要频繁插入和删除操作的情况，以及栈和队列等数据结构的实现。但需要注意，对于需要随机访问的情况，<code>ArrayList</code>通常更为高效。</p><h2 id="自定义实现">自定义实现</h2><h3 id="1-使用数组">1. 使用数组</h3><p>可以使用数组来实现栈，通过维护一个指向栈顶元素的指针（通常称为top），以及数组来存储栈的元素。当进行<code>push</code>和<code>pop</code>操作时，相应地更新栈顶指针和数组元素。这种实现方式的优点是简单，但需要注意数组大小的限制。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;   <span class="comment">// 栈的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;       <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;   <span class="comment">// 存储元素的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> {</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="built_in">this</span>.top = -<span class="number">1</span>; <span class="comment">// 栈开始时为空</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否已满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            System.out.println(<span class="string">"栈已满，无法入栈"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        stack[++top] = item;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            System.out.println(<span class="string">"栈为空，无法出栈"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回一个特定的值表示栈为空</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack[top--];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            System.out.println(<span class="string">"栈为空，无法查看栈顶元素"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回一个特定的值表示栈为空</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"栈顶元素："</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            System.out.println(<span class="string">"出栈元素："</span> + stack.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="2-使用链表">2. 使用链表:</h3><p>类似于使用数组，您可以使用链表来实现栈。链表的头节点可以充当栈顶，而<code>push</code>和<code>pop</code>操作将在链表头部进行。这种实现方式通常不会受到数组大小的限制，并且在动态大小方面更加灵活。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListStack</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top; <span class="comment">// 栈顶节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; {</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> {</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span> {</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(item);</span><br><span class="line">        newNode.next = top;</span><br><span class="line">        top = newNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"栈为空，无法出栈"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"栈为空，无法查看栈顶元素"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> top.data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        LinkedListStack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"栈顶元素："</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            System.out.println(<span class="string">"出栈元素："</span> + stack.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="3-使用单链表节点">3. 使用单链表节点</h3><p>如果不需要支持<code>pop</code>操作，只需要实现<code>push</code>和<code>peek</code>，您可以使用单链表节点来创建一个简化的栈。每个节点包含数据和一个指向下一个节点的引用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedListStack</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top; <span class="comment">// 栈顶节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; {</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> {</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span> {</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(item);</span><br><span class="line">        newNode.next = top;</span><br><span class="line">        top = newNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"栈为空，无法出栈"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"栈为空，无法查看栈顶元素"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> top.data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SingleLinkedListStack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">SingleLinkedListStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"栈顶元素："</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            System.out.println(<span class="string">"出栈元素："</span> + stack.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="4-使用双链表节点">4. 使用双链表节点</h3><p>如果需要支持<code>pop</code>操作和更高效的<code>pop</code>和<code>peek</code>操作，可以使用双链表节点来实现栈。这种实现方式允许从栈顶和栈底执行<code>pop</code>和<code>peek</code>操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListStack</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top; <span class="comment">// 栈顶节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; {</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; prev;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> {</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span> {</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="literal">null</span>) {</span><br><span class="line">            newNode.next = top;</span><br><span class="line">            top.prev = newNode;</span><br><span class="line">        }</span><br><span class="line">        top = newNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"栈为空，无法出栈"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="literal">null</span>) {</span><br><span class="line">            top.prev = <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"栈为空，无法查看栈顶元素"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> top.data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        DoubleLinkedListStack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">DoubleLinkedListStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"栈顶元素："</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            System.out.println(<span class="string">"出栈元素："</span> + stack.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>自定义栈的实现方式可以根据特定需求选择，但需要注意线程安全和性能方面的考虑。</p><h1>队列</h1><h2 id="java-util-Queue-接口实现"><code>java.util.Queue</code> 接口实现</h2><p>Java提供了<code>java.util.Queue</code>接口，是队列的标准接口。可以使用不同的实现类来创建队列，包括：</p><ul><li><code>java.util.LinkedList</code>：基于双向链表的实现，支持先进先出（FIFO）操作。</li><li><code>java.util.PriorityQueue</code>：优先级队列的实现，元素按照优先级顺序排列。</li></ul><p>以下使用<code>java.util.LinkedList</code>来实现队列。<code>offer</code>方法用于将元素入队列，<code>poll</code>方法用于出队列。由于<code>LinkedList</code>实现了<code>Queue</code>接口，可以方便地使用它来实现队列的操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueByLinkedList</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入对列</span></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        queue.offer(<span class="number">2</span>);</span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            System.out.println(<span class="string">"出队元素： "</span> + queue.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>PriorityQueue</code>是一个优先级队列，它根据元素的优先级来排列队列中的元素。较小的元素具有较高的优先级。使用<code>offer</code>方法入队列，<code>poll</code>方法出队列，优先级较高的元素会首先被出队列。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueByPriorityQueue</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入对列</span></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        queue.offer(<span class="number">2</span>);</span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()){</span><br><span class="line">            System.out.println(<span class="string">"出队元素： "</span> + queue.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="使用-java-util-concurrent-包中的队列">使用 <code>java.util.concurrent</code> 包中的队列</h2><p>Java的<code>java.util.concurrent</code>包提供了多线程安全的队列实现，用于多线程环境。一些常见的实现包括：</p><ul><li><code>java.util.concurrent.LinkedBlockingQueue</code>：基于链表的阻塞队列。</li><li><code>java.util.concurrent.ArrayBlockingQueue</code>：基于数组的阻塞队列。</li><li><code>java.util.concurrent.PriorityBlockingQueue</code>：多线程安全的优先级队列。</li></ul><h2 id="自定义队列">自定义队列</h2><p>此外，还可以使用数组或链表等数据结构来自定义队列的实现，根据特定需求创建自己的队列类。这通常需要额外的编程工作，但可以满足特定场景的需求。</p><h1>总结</h1><p>本文总结了Java中栈和队列的几种实现方式:</p><ol><li>栈的实现:<ul><li>使用Java标准库中的Stack类</li><li>使用Deque接口中的LinkedList实现栈操作</li><li>自定义数组栈、链表栈、单链表栈、双链表栈</li></ul></li><li>队列的实现:<ul><li>使用Java标准库中的Queue接口及其实现类LinkedList、PriorityQueue</li><li>使用java.util.concurrent包下的阻塞队列</li><li>自定义使用数组或链表实现的队列</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要记述 Java在实践中如何使用栈，关于栈与队列的基础知识点本文不再赘述，可参考 &lt;a href=&quot;http://data.biancheng.net/view/169.html&quot;&gt;编程帮-栈&lt;/a&gt;、&lt;a href=&quot;http://data</summary>
      
    
    
    
    <category term="Java手账本" scheme="http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>hexo渲染的页面不支持mermaid语法</title>
    <link href="http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/</id>
    <published>2023-10-15T22:09:15.568Z</published>
    <updated>2023-10-15T22:40:11.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mermaid 的介绍和使用请参考  <a href="https://zhuanlan.zhihu.com/p/172635547">这篇文章</a> 和 <a href="https://mermaid.js.org/intro/">官方文档</a>。</p></blockquote><h1>hexo渲染的页面不支持mermaid语法问题</h1><h2 id="问题背景">问题背景</h2><p>在typora编写的Markdown文件能很好地渲染 mermaid 流程图，然而使用 hexo 部署后却不能渲染，只能显示出 mermaid 代码。</p><h2 id="解决方案">解决方案</h2><p>从 <a href="https://hexo.io/plugins/">hexo插件官网</a> 找到对应的插件 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams</a>，参照 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams</a> 官方给出的环境配置方法进行配置。</p><ol><li><p>安装插件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-mermaid-diagrams</span><br><span class="line">// or</span><br><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改配置文件</p><p>同时修改根目录和themes目录下的 <code>_config.yml</code> 文件，加上以下内容：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">"7.1.2"</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在pug或js中包含mermaid.js</p><p>笔者使用的主题是 pure，在 <code>themes\pure\layout\_commons</code> 路径下的 <code>footer.ejs</code> 中添加如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.mermaid.enable) { %&gt;</span><br><span class="line">  &lt;script src='https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) {</span><br><span class="line">      mermaid.initialize({theme: 'forest'});</span><br><span class="line">    }</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;% } %&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>具体情况请参考 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">hexo-filter-mermaid-diagrams官方说明 </a>。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;mermaid 的介绍和使用请参考  &lt;a href=&quot;https://zhuanlan.zhihu.com/p/172635547&quot;&gt;这篇文章&lt;/a&gt; 和 &lt;a href=&quot;https://mermaid.js.org/intro/&quot;&gt;官方文档&lt;</summary>
      
    
    
    
    <category term="随机BUG" scheme="http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
    <category term="mermaid" scheme="http://example.com/tags/mermaid/"/>
    
  </entry>
  
  <entry>
    <title>二叉树基本定义以及遍历方法</title>
    <link href="http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</id>
    <published>2023-10-15T16:52:39.418Z</published>
    <updated>2023-10-20T06:44:51.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自程序员Carl的 <a href="https://programmercarl.com/">代码随想录</a>。</p></blockquote><p>[toc]</p><h1>二叉树的基本定义</h1><h2 id="二叉树的种类">二叉树的种类</h2><p>解题过程中二叉树有两种主要的形式：<strong>满二叉树</strong>和<strong>完全二叉树</strong>。</p><h3 id="满二叉树">满二叉树</h3><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树，如下图所示。</p><blockquote><p>文章中使用了画图功能，使用方式参考 <a href="https://zhuanlan.zhihu.com/p/172635547">这篇文章</a>， mermaid语法请参考 <a href="https://mermaid.js.org/intro/">官方文档</a>。</p></blockquote><pre class="mermaid">graph TDA--&gt;BA--&gt;CB--&gt;DB--&gt;EC--&gt;FC--&gt;GD--&gt;HD--&gt;IE--&gt;JE--&gt;KF--&gt;LF--&gt;MG--&gt;NG--&gt;O</pre><h3 id="完全二叉树">完全二叉树</h3><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。如下面的两个是完全二叉树：</p><pre class="mermaid">graph TDA--&gt;BA--&gt;CB--&gt;DB--&gt;EC--&gt;FC--&gt;GD--&gt;HD--&gt;IE--&gt;J</pre><pre class="mermaid">graph TDA--&gt;BA--&gt;CB--&gt;DB--&gt;EC--&gt;FC--&gt;GD--&gt;HD--&gt;IE--&gt;JE--&gt;K</pre><p>而下面一个就不是完全二叉树：</p><pre class="mermaid">graph TDA--&gt;BA--&gt;CB--&gt;DB--&gt;EC--&gt;FC--&gt;GD--&gt;HD--&gt;IE--&gt;NullE--&gt;K</pre><blockquote><p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系</strong></p></blockquote><h3 id="二叉搜索树">二叉搜索树</h3><p>相比于前面介绍的没有数值的树，二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>例如下面这两棵树都是搜索树</p><pre class="mermaid">graph TD10--&gt;610--&gt;166--&gt;36--&gt;916--&gt;1416--&gt;19</pre><pre class="mermaid">graph TD10--&gt;610--&gt;Null6--&gt;36--&gt;9</pre><h3 id="平衡二叉搜索树">平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。例如：</p><pre class="mermaid">graph TD10--&gt;610--&gt;166--&gt;36--&gt;9</pre><pre class="mermaid">graph TD10--&gt;610--&gt;166--&gt;36--&gt;916--&gt;1416--&gt;19</pre><blockquote><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是$log\ n$，</p><p>注意这里不包括unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表</p></blockquote><h2 id="二叉树的存储方式">二叉树的存储方式</h2><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p><p>链式存储比较直观，即给每个节点设置左指针和有指针，分别指向左子树和右子树。</p><p>如何顺序存储呢？其实就是用数组来存储二叉树，顺序存储的方式如图：</p><pre class="mermaid">graph TDa--&gt;ba--&gt;cb--&gt;db--&gt;ec--&gt;fc--&gt;g</pre><p>对应的存储数组为：<code>[a,b,c,d,e,f,g]</code>，下标对应 0-6。</p><p>顺序存储的遍历方式：</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><h2 id="二叉树的遍历方式">二叉树的遍历方式</h2><blockquote><p>注意总结做题的框架！！</p></blockquote><p>关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。</p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候还会介绍到。</p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>在深度优先遍历中：有三个顺序，前中后序遍历。<strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，因此只需要记住： 前中后序指的就是中间节点的位置。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>例如对于下面的图，前中后序遍历的顺序依次是：</p><ul><li>前序（DLR）：abdecfg</li><li>中序（LDR）：dbeafcg</li><li>后序（LRD）：debfgca</li></ul><pre class="mermaid">graph TDa--&gt;ba--&gt;cb--&gt;db--&gt;ec--&gt;fc--&gt;g</pre><p>最后是二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p><p>前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><h2 id="二叉树的代码实现">二叉树的代码实现</h2><blockquote><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p><p>因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++代码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) {}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() {}</span><br><span class="line">    TreeNode(<span class="type">int</span> val) { <span class="built_in">this</span>.val = val; }</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>二叉树的递归遍历</h1><h2 id="递归的三要素">递归的三要素</h2><p>本部分将介绍前后中序的递归写法。首先确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><h2 id="题目链接及题解">题目链接及题解</h2><ol><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LC144_二叉树的前序遍历</a><ol><li>确定递归函数的参数和返回值。预设代码给出了preorderTraversal函数，其参数为 TreeNode类型的root节点，返回List&lt;Integer&gt;类型。实现递归函数preorder，该函数主要实现对二叉树的遍历，并把遍历结果插入result向量中，返回值为void；参数需要两个：当前的结点和result向量</li><li>确定终止条件：当前结点为 null 时递归终止</li><li>单层递归逻辑：DLR</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定参数：当前节点 和 result List</span></span><br><span class="line">    <span class="comment">// 返回值： void</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>{</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 单层递归逻辑：DLR</span></span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        preorder(curr.left, result);</span><br><span class="line">        preorder(curr.right, result);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LC94_二叉树的中序遍历</a></li></ol><blockquote><p>原理&amp;思路同上一题</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRD</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>{</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        postorder(curr.left, result);</span><br><span class="line">        postorder(curr.right, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LC145_二叉树的后序遍历</a></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>{</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        inorder(curr.left, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        inorder(curr.right, result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.nowcoder.com/share/jump/8214310031697402552220">BM24 二叉树的中序遍历</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] resultArr = result.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode curr, List&lt;Integer&gt; result)</span>{</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        inorder(curr.left, result);</span><br><span class="line">        result.add(curr.val);</span><br><span class="line">        inorder(curr.right, result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.nowcoder.com/share/jump/8214310031697403236272">BM25 二叉树的后序遍历</a></p><p><a href="https://www.nowcoder.com/share/jump/8214310031697403428551">BM23 二叉树的前序遍历</a></p><h1>二叉树的迭代遍历</h1><blockquote><p>见 <a href="https://programmercarl.com/">代码随想录</a>。</p></blockquote><h2 id="迭代法遍历的基本原理">迭代法遍历的基本原理</h2><blockquote><p>此部分建议细读 <a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">代码随想录-二叉树的迭代遍历</a> 理解迭代遍历的基本原理。</p></blockquote><h2 id="统一迭代方法">统一迭代方法</h2><p>迭代法实现的先中后序，其实风格并不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。</p><p>经过实践会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。</p><p>统一写法的基本思路是：<strong>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记</strong>。</p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">            st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">            st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">            st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">            node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）         </span></span><br><span class="line">                               </span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>二叉树的层序遍历</h1><h2 id="基本原理">基本原理</h2><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="102二叉树的层序遍历"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 102.二叉树的层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) {</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        }</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun02</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) {</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="literal">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="literal">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="题目链接">题目链接</h2><ol><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LC102. 二叉树的层序遍历</a>；</li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LC107. 二叉树的层序遍历 II</a>；</li><li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">LC199. 二叉树的右视图</a>；</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文来自程序员Carl的 &lt;a href=&quot;https://programmercarl.com/&quot;&gt;代码随想录&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;二叉树的基本定义&lt;/h1&gt;
&lt;h2 id=&quot;二叉树的种</summary>
      
    
    
    
    <category term="刷题日记" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="NowCoder" scheme="http://example.com/tags/NowCoder/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/10/15/2023-10-15-hello-world/"/>
    <id>http://example.com/2023/10/15/2023-10-15-hello-world/</id>
    <published>2023-10-14T16:08:56.164Z</published>
    <updated>2023-10-14T16:04:19.185Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建GitHub Page-Jekyll篇</title>
    <link href="http://example.com/2023/10/13/2023-10-13-%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/"/>
    <id>http://example.com/2023/10/13/2023-10-13-%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/</id>
    <published>2023-10-13T09:25:37.729Z</published>
    <updated>2023-10-20T06:46:27.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述">一、概述</h2><blockquote><p>emoji 好看吗？<a href="https://sunhwee.com/posts/a927e90e.html#toc-heading-3">这里 </a>有很多哦</p></blockquote><p>应该没有一个开发人员不向往有一个自己的个人网页吧？<span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>这个主页怎么搭建呢？事实上，网络上有很多将搭建个人博客网站的项目，这样当然是好的，可是似乎需要自己搞一台服务器啊？如果服务器过期了，网站是不是就404了呢？<span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>那能不能不用自己租服务器，快乐当白嫖怪呢？GitHub表示：宝宝，还没想起来我吗？<span class="github-emoji"><span>😤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f624.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😘</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>不会前端咋办？当然是本着<strong>将白嫖进行到底</strong>的原则啦！看这里<span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="http://jekyllthemes.org/">Jekyll 模板</a><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。</p><h2 id="二、Windows环境配置">二、Windows环境配置</h2><ul><li>Ruby (ruby -v)</li><li>RubyGems (gem -v)</li><li>Gcc &amp; make (gcc -v | g++ -v | make -v )</li><li>Git (git --version)</li></ul><h3 id="配置Gcc、make环境">配置Gcc、make环境</h3><blockquote><p>参考：</p><ol><li><a href="https://blog.csdn.net/qq_42544728/article/details/128037835">Gcc、g++安装</a>；</li><li><a href="https://tehub.com/a/aCYp1uw0tG">make安装</a>。</li></ol></blockquote><h3 id="安装-Ruby-和-Jekyll">安装 Ruby 和 Jekyll</h3><blockquote><p>参考 <a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a> 。</p></blockquote><h4 id="通过-RubyInstaller-安装">通过 RubyInstaller 安装</h4><p>Windows上安装Ruby和Jekyll最简单的方法是 <a href="https://rubyinstaller.org/">RubyInstaller</a>，RubyInstaller是一个基于windows的比较完备的安装程序，包括Ruby语言、执行环境、重要文档等等。</p><p>官方配置中介绍的是 RubyInstaller-2.4及更新版本，直接选择最新的安装包。</p><p>详细步骤：</p><ol><li><p>从 <a href="https://rubyinstaller.org/downloads/">RubyInstaller Downloads</a> 下载并安装 Ruby+Devkit 版本。使用默认选项进行安装；</p></li><li><p>在安装向导的最后阶段运行 <code>ridk install</code> 步骤。这是安装带有本地扩展的 gem 所需要的。可以在 <a href="https://github.com/oneclick/rubyinstaller2#using-the-installer-on-a-target-system">RubyInstaller Documentation</a> 中找到更多相关信息。从选项中选择 <code>MSYS2 and MINGW development tool chain</code> ；</p></li><li><p>从开始菜单打开一个新的命令提示窗口，这样对 PATH 环境变量的更改就会生效。使用命令 <code>gem Install Jekyll Bundler</code> 安装Jekyll和Bundler；</p><blockquote><p>注意：此处需将 Ruby gem的源换回国内源，<a href="https://mirrors.tuna.tsinghua.edu.cn/help/rubygems/">清华镜像源操作方法</a>。</p></blockquote></li><li><p>查看Jekyll 是否正确安装：<code>jekyll -v</code>；</p></li></ol><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 55%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013174616311.png" alt="Image 1" style="width: 100%;">        <p>RubyInstaller Downloads页面</p>    </div>    <div style="width: 40%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013175724296.png" alt="Image 2" style="width: 100%;">        <p>安装向导完成页面</p>    </div></div><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 50%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013175756189.png" alt="Image 1" style="width: 100%;">        <p>运行 ridk install</p>    </div>    <div style="width: 50%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013180247061.png" alt="Image 2" style="width: 100%;">        <p>ridk install 运行完成</p>    </div></div><div style="display: flex; flex-wrap: wrap; justify-content: space-between;">    <div style="width: 60%;">        <img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013181646903.png" alt="Image 1" style="width: 100%;">        <p>检查Jekyll是否成功安装</p>    </div>    <div style="width: 40%;">        <img src="" alt="Image 2" style="width: 100%;">        <p></p>    </div></div><h4 id="通过bash安装">通过bash安装</h4><blockquote><p>参考 <a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a> ，此处不再尝试</p></blockquote><h2 id="三、配置个人主页">三、配置个人主页</h2><p>根据自己选择的 <a href="http://jekyllthemes.org/">Jekyll 模板</a>，进行后续配置。以 <a href="https://chirpy.cotes.page/posts/getting-started/">Chirpy</a> 模板为例。</p><h3 id="1-创建仓库-准备模板源码">1. 创建仓库 + 准备模板源码</h3><p>首先创建名为 <code>username.github.io</code> 的远程仓库，并clone到本地。</p><blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> username不是你的昵称 or 你自己的名字。</p><p><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> username是你的github账户名，要严格保持一致</p></blockquote><p>下载 <a href="http://jekyllthemes.org/themes/jekyll-theme-chirpy/">Chripy</a> 的源码，解压到clone的本地文件夹目录下，使用 <code>bundle install</code> 构建本地环境。</p><blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 记住将 <code>Gemfile</code> 中的 source 替换为 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/rubygems/">清华镜像源</a>。</p></blockquote><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013215146729.png" alt="image-20231013215146729" style="zoom: 50%;"><h3 id="2-部署个人主页">2. 部署个人主页</h3><h4 id="修改配置文件">修改配置文件</h4><p>部署前，配置 <code>_config.yml</code> 中的 <code>url</code>，填写为仓库地址。</p><blockquote><p><strong>Before the deployment begins, check out the file<code>_config.yml</code>and make sure the<code>url</code>is configured correctly.</strong> Furthermore, if you prefer the <a href="https://link.zhihu.com/?target=https%3A//help.github.com/en/github/working-with-github-pages/about-github-pages%23types-of-github-pages-sites">project site</a> and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than<strong>GitHub Pages</strong>, remember to change the<code>baseurl</code>to your project name that starts with a slash, e.g,<code>/project-name</code>.</p></blockquote><h4 id="使用Github-Action部署个人主页。">使用Github Action部署个人主页。</h4><ol><li><p>首先在仓库设置页(Settings)-&gt;Pages-&gt;Build and deployment从下拉菜单中选择Github Actions。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013220645578.png" alt="image-20231013220645578" style="zoom: 50%;"><blockquote><ol><li>Browse to your repository on GitHub. Select the tab <em>Settings</em>, then click <em>Pages</em> in the left navigation bar. Then, in the <strong>Source</strong> section (under <em>Build and deployment</em>), select <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow"><strong>GitHub Actions</strong></a> from the dropdown menu.</li></ol></blockquote></li><li><p>然后把本地修改commit并提交到Github远程仓库上，可以触发<code>Github Action</code>的<code>Build and deployment</code>工作流进行部署。如果没有自动触发，可以手动点击<code>Build and Deploy</code>进行部署。</p><blockquote><ol start="2"><li>Push any commits to GitHub to trigger the <em>Actions</em> workflow. In the <em>Actions</em> tab of your repository, you should see the workflow <em>Build and Deploy</em> running. Once the build is complete and successful, the site will be deployed automatically.</li></ol></blockquote></li><li><p>等待一段时间后，在 Actions 页查看部署情况。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013224102256.png" alt="image-20231013224102256" style="zoom:67%;"></li><li><p>可能的错误</p></li></ol><h4 id="可选-手动构建和配置">(可选)手动构建和配置</h4><blockquote><p>不再演示，可参考 <a href="https://chirpy.cotes.page/posts/getting-started/">官方文档</a>。</p></blockquote><h4 id="本地运行Jekyll项目">本地运行Jekyll项目</h4><p>在项目路径下使用命令 <code>bundle exec jekyll serve</code>，即可在 Web 浏览器中导航到 <code>http://localhost:4000</code> 浏览本地项目。</p><img src="https://typora-1308640872.cos.ap-beijing.myqcloud.com/img/image-20231013230309002.png" alt="image-20231013230309002" style="zoom: 50%;"><h2 id="参考文章">参考文章</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/641525444">知乎-春枫禾旭 的博客</a>；</li><li><a href="https://docs.github.com/zh/pages/getting-started-with-github-pages">GitHub Page中文教程</a>；</li><li><a href="http://jekyllthemes.org/">Jekyll 模板主页</a>；</li><li><a href="https://jekyllrb.com/docs/installation/windows/">Jekyll 官方环境配置指南</a>；</li><li><a href="https://chirpy.cotes.page/posts/getting-started/">Chirpy官方文档</a> ；</li><li><a href="https://sunhwee.com/posts/a927e90e.html#toc-heading-3">emoji小基地</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;emoji 好看吗？&lt;a href=&quot;https://sunhwee.com/posts/a927e90e.html#toc-heading-3&quot;&gt;这里 &lt;/a&gt;有很多哦&lt;/p&gt;
&lt;/blockquo</summary>
      
    
    
    
    <category term="工具库" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
    
    <category term="Github" scheme="http://example.com/tags/Github/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
</feed>
