{"meta":{"title":"Liangshou","subtitle":"","description":"","author":"Liangshou","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"about","date":"2023-10-15T08:26:48.000Z","updated":"2023-10-15T08:26:48.224Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-10-15T08:28:18.437Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"关于Java 容器","slug":"2023-10-20-关于Java集合","date":"2023-10-20T09:13:55.270Z","updated":"2023-10-20T15:30:39.172Z","comments":true,"path":"2023/10/20/2023-10-20-关于Java集合/","link":"","permalink":"http://example.com/2023/10/20/2023-10-20-%E5%85%B3%E4%BA%8EJava%E9%9B%86%E5%90%88/","excerpt":"","text":"Java容器概述Java中的容器，也就是Java 集合，是一套用于存储和组织数据的对象。容器类提供了一种将多个对象集合在一起的方式，并提供了一组方法来管理和操作这些对象。 Java容器主要派生自两大接口：Collection接口和Map接口。前者主要用于存放单一元素，后者则主要用于存放键值对。对于Collection接口，其有三个主要的子接口：List接口、Queue接口、Set接口。Java容器的系统结构可参考下图： 分享来源：processon-java集合系统。 List, Set, Queue, Map 概述ListList接口是用来处理顺序相关问题的很好的工具，其特点是存储的元素是有序的、可重复的。List接口最常用的实现类包括了 LinkedList、ArrayList、Stack以及Vector等，其中Stack类是Vector类的子类。 List的JDK源码为： 1public interface List&lt;E&gt; extends Collection&lt;E&gt; 底层数据结构 ArrayList：ArrayList是一个可以动态增长的数组，其底层数据结构是 Object[]数组，在JDK源码中有如下的定义（已省略javadoc）： 12345private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData; 在Java中，transient 关键字用于修饰类的实例变量。当一个实例变量被标记为 transient 时，它告诉Java的序列化机制不要将该变量的值持久化（即不要将其写入对象的序列化表示中），而只序列化对象的其他部分。这在对象序列化和反序列化时非常有用。 LinkedList：该类继承了AbstractSequentialList抽象类，底层的数据结构是双向链表，使用泛型定义链表节点，JDK源码（JDK17）为： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Vector：该类的底层数据结构同样为Object[]数组，JDK源码中的定义为： 123protected Object[] elementData;protected int elementCount; Stack：继承了Vector类，底层的数据结构与Vector一致。 SetSet在数学中是集合的意思，Set接口组织数据的特点是注重独一无二的性质，存储的元素不可重复的。 底层数据结构 HashSet：HashSet 的特点是无序性和唯一性，底层采用了HashMap来存储数据。 123private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object(); LinkedHashSet：HashSet的子类，内部实现通过LinkedHashMap，通过supper调用父类的构造方法，HashSet中定义的源码为： 123HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; TreeSet：区别于HashSet，TreeSet的特点是有序且唯一的，底层采用了红黑树的数据结构实现。实际上，JDK17中，TreeSet类实现的是NavigableMap 接口，而后者继承了SortedMap接口。 123456// TreeSet类public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable // NavigableSet接口public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; QueueQueue（队列）中，按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。 底层数据结构 PriorityQueue：底层是使用 Object[] 数组来实现小顶堆。 DelayQueue：PriorityQueue。 ArrayDeque:：可扩容动态双向数组。 Map使用键值对（key-value）存储，类似于数学上的函数的一个key对应唯一value的关系，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 底层数据结构HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。 TreeMap：红黑树（自平衡的排序二叉树）。","categories":[{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java 常识？我咋不知道","slug":"2023-10-19-我不知道的Java常识","date":"2023-10-19T15:51:41.429Z","updated":"2023-10-20T08:56:14.096Z","comments":true,"path":"2023/10/19/2023-10-19-我不知道的Java常识/","link":"","permalink":"http://example.com/2023/10/19/2023-10-19-%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%E5%B8%B8%E8%AF%86/","excerpt":"","text":"Java SE，Java EE &amp; Java ME？ 有没有想过，同样是Java，会不会存在不同的版本 or anything else？事实上，为了使软件开发人员、服务提供商和设备生产商可以针对特定的市场进行开发，SUN公司将Java划分为三个技术平台： Java SE：Standard Edition（标准版） Java EE：Enterprise Edition（商业版） Java ME：Micro Edition（小型版） Java SE全称为Java Platform Standard Edition，这是Java 平台标准版，包含标准的 JVM和标准库，更具体地说，包括了 Java 核心的类库，如集合、IO、数据库连接以及网络编程等。 JavaSE 是Java 编程语言的基础，三个核心平台中的核心部分，Java EE 和 Java ME 都是从 JavaSE的基础上发展而来的 JavaSE是为开发普通桌面和商务应用程序提供的解决方案。 Java EE全称是 Java Platform Enterprise Edition，Java 平台企业版，建立在 Java SE 的基础上，并加入了大量的 API 和库，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE是进一步学习Web应用所必须的，Spring等框架都是Java EE开源生态系统的一部分。 JavaEE 是为开发企业级应用程序提供的解决方案。 Java ME全称是 Java Platform Micro Edition，Java平台小型版，是一个针对 嵌入式设备 的 “瘦身版”，要用于小型数字电子设备上软件程序的开发，例如家用电器的智能化、联网功能等。 此外，JavaME提供了HTTP等高级Internet协议，使移动电话能以Client&#x2F; Server方式直接访问 Internet的全部信息，提供最效率的无线交流。 JavaME 是为开发电子消费产品和嵌入式设备提供的解决方案。然而Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，只需要了解即可。 JDK，JVM &amp; JRE？ Java文档官网：https://docs.oracle.com/en/java/index.html 立即推(张宇老师口吻)：这题我会！事实上，这个问题倒是比较容易理解。 详细信息可参考：官方架构图。 JVM &amp; JITJVM 即 Java 虚拟机，是运⾏ Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。 在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时⽐较⾼效 ⽽且，由于字节码并不针对⼀种特定的机器，因此，Java 程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。 Java 程序从源代码到编译运⾏⼀般需要经历以下的过程： 事实上，可以运行在 Java 虚拟机上的语言除了 Java外还有很多，如Groovy(.groovy)、Kotlin(.kt)、JRuby(.rb)、Clojure(.clj)等，它们编译运行的过程大致相似，经过对应的编译器编译为 .class字节码文件。 这里需要格外注意的是 .class --&gt; 机器码 这⼀步。在这⼀步 JVM 类加载器⾸先加载字节码⽂件，然后通过 解释器 逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐较慢。⽽且，有些⽅法和代码块是经常需要被调⽤的(也就是所谓的热点代码)，所以后⾯引进了 JIT （Just in Time Compilation）编译器，⽽ JIT 属于运⾏时编译。当 JIT 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。⽽我们知道，机器码的运⾏效率肯定是⾼于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 于是引入 JIT 后，程序从源代码到编译运⾏经历的过程具体为： JDK &amp; JREJDK 是 Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。 JRE 是 Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。 如果只是为了运⾏⼀下 Java 程序的话，只需要安装 JRE 就可以了。如果需要进⾏⼀些Java 编程⽅⾯的⼯作，那么就需要安装 JDK 了。 这也不是绝对的。有时，即使不打算在计算机上进⾏任何 Java 开发，仍然需要安装 JDK。例如，如果要使⽤ JSP 部署 Web 应⽤程序，那么从技术上讲，只是在应⽤程序服务器中运⾏ Java 程序。 但是因为应⽤程序服务器会将 JSP 转换为 Java servlet，并且需要使⽤ JDK 来编译 servlet，还是需要安装JDK 编译与解释并存？参考JVM部分，可知 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。 AOT &amp; JIT？ 可参考：理解Java的JIT和AOT，JIT v.s. AOT in Java。 JIT是Just-In-Time的首字母缩写，指程序运行期间发生的编译行为。 JIT多伴随解释器，因为解释型语言是按行解释执行，JIT将“常用”功能编译为机器码，需要时直接执行，减少解释时间； 例如：Python(pypy)，新版Javascript、Ruby、Php解释器； AOT是Ahead-Of-Time的首字母缩写，指程序运行之前发生的编译行为。 对于编译型语言，AOT啥也不是，本身就是先编译后执行，但对于解释型语言，AOT提前“预见”热点功能，并编译为机器码，同样减少解释时间； 例如：C，C++，Rust，Go，Java AOT； AOP是JDK 9 引入了一种新的编译模式，主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。","categories":[{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"链表刷题—Java版","slug":"2023-10-17-链表刷题—Java版","date":"2023-10-17T12:07:36.377Z","updated":"2023-10-20T06:44:40.896Z","comments":true,"path":"2023/10/17/2023-10-17-链表刷题—Java版/","link":"","permalink":"http://example.com/2023/10/17/2023-10-17-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E2%80%94Java%E7%89%88/","excerpt":"","text":"[toc] 前言链表是通过指针串联在一起的线性结构，指针是其中的一个重要部分。简单了解指针的概念： 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。 就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： 1type *var-name 在C&#x2F;C++等语言中，都显式地定义了指针用于直接访问内存地址的机制，然而学习 Java 的人或多或少都听说过“Java没有指针”。 Java的设计目标之一是提供一种更安全和易于学习的编程语言。为了实现这一目标，Java采用了一种自动内存管理的方式，即垃圾回收机制。Java引入了引用（reference）的概念，但不允许直接访问内存地址。这意味着在Java中，并不能像C或C++中那样使用指针来操作内存。这种设计决策有助于减少内存管理错误和提高安全性。关于更多Java指针的理解，可参考 知乎专栏—Java真的没有“指针”吗？。 关于链表的基础理论，本文不再赘述，可参考：代码随想录-链表基础理论。 Java 链表的实现方式： 12345678910111213141516171819202122public class ListNode &#123; // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() &#123; &#125; // 节点的构造函数(有一个参数) public ListNode(int val) &#123; this.val = val; &#125; // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 设计链表 题目链接： LC707. 设计链表 移除链表元素 题目链接： LC203. 移除链表元素; BM9删除链表的倒数第n个节点 因为是单链表，从前往后遍历，假如当前访问结点的 val 是要移除的，无法很好地定位到当前节点的前一个节点；另外就是需要考虑头结点可能为需要移除的结点的情况。综合来看，可以有三种移除方式：不设置 pre 节点和虚拟节点、仅设置pre节点、同时设置pre节点和虚拟节点。 LC203不设置 pre 节点和 虚拟节点分两步考虑：首先处理掉头结点需要移除的情况，之后判断 curr.next 节点是否需要移除。 12345678910111213141516171819class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; while(head != null &amp;&amp; head.val == val)&#123; // 处理头结点要移除的情况 head = head.next; &#125; ListNode curr = head; while(curr != null)&#123; // curr的下一个节点 while(curr.next != null &amp;&amp; curr.next.val == val)&#123; curr.next = curr.next.next; &#125; curr = curr.next; &#125; return head; &#125;&#125; 仅设置pre节点同上一种方式，首先处理掉头结点需要移除的情况，之后使用 pre 节点指向 curr 的前一个节点，遍历中只需要关注 curr 节点的 val。 123456789101112131415161718192021222324252627class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; while(head != null &amp;&amp; head.val == val)&#123; // 处理头结点要移除的情况 head = head.next; &#125; if(head == null)&#123; return null; &#125; ListNode curr = head.next; ListNode pre = head; while(curr != null)&#123; if(curr.val == val)&#123; pre.next = curr.next; &#125; else&#123; pre = pre.next; &#125; curr = curr.next; &#125; return head; &#125;&#125; 同时设置 pre 节点和 虚拟节点这样做的好处在于，移除头结点和普通节点的逻辑可以统一，即原链表的所有节点就都可以按照统一的方式进行移除，使用 dummy.next 定位头结点。 12345678910111213141516171819202122class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head == null)&#123; return null; &#125; // 设置虚拟节点 ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode curr = head; while(curr != null)&#123; if(curr.val == val)&#123; pre.next = curr.next; &#125; else&#123; pre = curr; &#125; curr = curr.next; &#125; return dummy.next; &#125;&#125; BM9index定位123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; /** * * @param head ListNode类 * @param n int整型 * @return ListNode类 */ public ListNode removeNthFromEnd (ListNode head, int n) &#123; if(n == 0)&#123; return head; &#125; // 确定链表的长度 ListNode cur = head; int len = 0; while(cur != null)&#123; cur = cur.next; len++; &#125; cur = head; int index = len - n; if(index == 0)&#123; head = head.next; return head; &#125; // 定位到要移除的结点 for(int i = 1; i &lt; index; i++)&#123; cur = cur.next; &#125; cur.next = cur.next.next; return head; &#125;&#125; 滑动窗口1234567891011121314151617public ListNode removeNthFromEnd (ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // 向前移动 first 指针，使 first和 second 之间的间隔为n个节点 for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // 同时移动 first 和 second while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next; &#125; 翻转链表 题目链接： LC206 反转链表。 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。 然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。 为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。 接下来，就是循环走以上代码逻辑了，继续移动pre和cur指针。 最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。 1234567891011121314151617181920class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode pre = null; ListNode cur = head; ListNode tmp = null; while(cur != null)&#123; tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; &#125; return pre; &#125;&#125; 链表相交环形链表","categories":[{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"MySQL—— 基础理论概念","slug":"2023-10-17-MySQL基础","date":"2023-10-17T01:01:41.415Z","updated":"2023-10-17T03:57:40.032Z","comments":true,"path":"2023/10/17/2023-10-17-MySQL基础/","link":"","permalink":"http://example.com/2023/10/17/2023-10-17-MySQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"MySQL概述1. 数据库相关概念首先辨析三个概念：数据库、数据库管理系统、SQL 名称 含义 简称 数据库 存储数据的仓库，数据是有组织地进行存储 DataBase(DB) 数据库管理系统 操纵和管理数据库的大型软件 DataBase Management System(DBMS) SQL 操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 Structured Query Language(SQL) 各大主流 DBMS 的排名参考 DB-Engines Ranking， Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。 MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。 SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。 PostgreSQL：开源免费的中小型数据库。 DB2：IBM公司的大型收费数据库产品。 SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。 而不论我们使用的是上面的哪一个关系型数据库，最终在操作时，都是使用SQL语言来进行统一操作，因为SQL语言，是操作关系型数据库的 统一标准 。 2. MySQL数据库 官网地址： https://www.mysql.com/ MySQL官方提供了两种不同的版本： 社区版本（MySQL Community Server） 免费， MySQL不提供任何技术支持 商业版本（MySQL Enterprise Edition） 收费，可以使用30天，官方提供技术支持 安装与配置教程参考 知乎-smi安装、博客园-压缩包安装。 3. 数据模型1) 关系型数据库(RDBMS)概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 所谓二维表，指的是由行和列组成的表，类似于Excel表格数据，有表头、有列、有行，还可以通过一列关联另外一个表格中的某一列数据。上述的MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。 特点： 使用表存储数据，格式统一，便于维护。 使用SQL语言操作，标准统一，使用方便。 2) 数据模型MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构如图: 可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。 可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录 SQL全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 。 1. SQL通用语法 SQL语句可以单行或多行书写，以分号结尾; SQL语句可以使用空格&#x2F;缩进来增强语句的可读性; MySQL数据库的SQL语句不区分大小写，关键字建议使用大写; 注释： 单行注释：– 注释内容 或 # 注释内容 多行注释：&#x2F;* 注释内容 *&#x2F; 2. SQL分类SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的 3. DDL——数据定义语言Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) 数据库操作 查询所有数据库 查询当前数据库 创建数据库 删除数据库 切换数据库 表操作查询创建 查询当前所有表 查看指定表结构 查询指定表的建表语句 创建表结构 MySQL的数据类型MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。 数值类型 类型 大小(BYTE) 有符号(SIGNED)范围 无符号(UNSIGNED)范围 描述 TINYINT 1 (-128,127) … 小整数值 SMALLINT 2 (-32768,32768) … 大整数值 MEDIUMINT 3 (-8388608,8388607) … 大整数值 INT&#x2F;INTEGER 4 (-2^31, 2^31-1) … 大整数值 BIGINT 8 (-2^63, 2^63-1) … 极大整数值 FLOAT 4 … … 单精度浮点数值 DOUBLE 8 … … 双精度浮点数值 DECIMAL 依赖于精度M和标度D的值 … 小数值 字符串类型 类型 大小(byte) 描述 CHAR 0-255 定长字符串(需要指定长度) VARCHAR 0-65535 变长字符串(需要指定长度) TINYBLOB 0-255 不超过255个字符的二进制数据 TINITEXT 0-255 短文本字符串 BLOB 0-65535 二进制形式的长文本数据 TEXT 0-65535 长文本数据 MEDIUMBLOB 0-16777215 二进制形式的中等长度文本数据 MIDEUMTEXT 0-16777215 中等长度文本数据 LONGBLOB 0-4294967295 二进制形式的极大文本数据 LONGTEXT 0-4294967295 极大文本数据 char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。 12345678--- 1) 用户名 username ------&gt; 长度不定，最长不会超过50username varchar(50)--- 2) 性别 gender ------&gt; 存储值，不是男就是女gender char(1)--- 3) 手机号 phone ------&gt; 固定长度11（仅限国内移动手机号）phone char(11) 日期时间类型 类型 大小 范围 格式 描述 DATA 3 YYYY-MM-DD 日期值 TIME 3 HH:MM:SS 时间值或持续时间 YEAR 1 YYYY 年份值 DATETIME 8 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 4. DMLDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。 添加数据（INSERT） 修改数据（UPDATE） 删除数据（DELETE） 5. DQLDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。 查询关键字: SELECT 在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。 6. DCLDCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。 函数MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。 字符串函数内置函数一览 函数 功能 CONCAT(s1, s2, …sn) 字符串拼接，将s1，s2，… sn拼接成一个字符串 LOWER(str) 将字符串str全部转为小写 UPPER(str) 将字符串str全部转为大写 LPAD(str, N, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 演示用例12345678910111213141516--- concatselect concat(&quot;Hello&quot;, &quot;World&quot;);--- lower &amp; upperselect lower(&quot;Hello&quot;);select upper(&#x27;Hello&#x27;);--- lpad &amp; rpadselect lpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);select rpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);--- trim 去除空格select trim(&#x27; Hello MySQL &#x27;);--- substringselect substring(&#x27;Hello MySQL&#x27;,1,5); 数值函数内置函数一览 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) 返回x&#x2F;y的模 RAND() 返回0~1内的随机数 ROUND(x,y) 求参数x的四舍五入的值，保留y位小数 演示用例123456789101112131415161718--- ceil &amp; floorselect ceil(1.1);select flooor(1.9);--- modselect mod(7,4);--- randselect rand();--- roundselect round(3.344, 2);/* 通过数据库的函数，生成一个六位数的随机验证码。 思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0*/select lpad(round(rand()*1000000 , 0), 6, &#x27;0&#x27;); 日期函数流程函数约束多表查询事务","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Java中的栈与队列","slug":"2023-10-16-Java中的栈与队列","date":"2023-10-16T05:12:04.799Z","updated":"2023-10-20T06:41:20.189Z","comments":true,"path":"2023/10/16/2023-10-16-Java中的栈与队列/","link":"","permalink":"http://example.com/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"本文主要记述 Java在实践中如何使用栈，关于栈与队列的基础知识点本文不再赘述，可参考 编程帮-栈、编程帮-队列。 栈标准库 java.util.Stack 实现在 java.util 中封装了 Stack 类，其继承自Vector类，定义了push、pop、peek、empty、search五个操作对Vector进行了扩展，JDK源码（已省去jdoc）如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; public Stack() &#123; &#125; // ... public E push(E item) &#123; addElement(item); return item; &#125; // ... public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; // ... public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; // ... public boolean empty() &#123; return size() == 0; &#125; // ... public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1; &#125; /** use serialVersionUID from JDK 1.0.2 for interoperability */ @java.io.Serial private static final long serialVersionUID = 1224463164541339165L;&#125; Deque接口实现在Java中，栈可以使用java.util.Stack类实现，也可以使用 java.util.LinkedList 结合push和pop操作来实现自定义的栈。通常，建议使用 Deque 接口中的 LinkedList 实现来代替java.util.Stack，因为后者是基于向量的数据结构，性能较差。 示例代码： 12345678910public class StackByDeque &#123; public static void main(String[] args) &#123; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); stack.push(1); stack.push(2); int top = stack.pop(); System.out.println(top + &quot; &quot; + stack.size()); &#125; &#125; 其中，值得注意的是 LinkedList 类。LinkedList是Java中的一个双向链表实现，它继承自AbstractSequentialList类，并实现了List和Deque接口，同时提供了双向链表的功能。JDK中的源码如下： 1234567891011121314151617public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; /** * Pointer to first node. */ transient Node&lt;E&gt; first; /** * Pointer to last node. */ transient Node&lt;E&gt; last; ... LinkedList 类有以下的特点： 双向链表: LinkedList是基于双向链表数据结构的实现，每个元素都被包装在一个节点中，而每个节点都包含指向前一个节点和后一个节点的引用。这使得在链表中插入和删除元素的操作非常高效，因为只需要调整节点的引用，而不需要移动其他元素。 实现了List接口: LinkedList实现了List接口，这意味着它可以像ArrayList一样用于存储有序的元素集合，支持随机访问、按索引插入和删除元素。与ArrayList不同，LinkedList在插入和删除操作上通常更高效，但在随机访问上性能较差。 实现了Deque接口: LinkedList还实现了Deque接口，这使得它可以被用作双端队列（double-ended queue）。您可以在队列的前端和后端进行插入和删除操作，支持先进先出（FIFO）和后进先出（LIFO）等不同的数据操作模式。 适合用于栈和队列: 由于LinkedList支持双向操作，它特别适合用作栈和队列的基础数据结构。您可以使用push和pop操作来实现栈，使用offer和poll操作来实现队列。 非线程安全: 与ArrayList不同，LinkedList是非线程安全的，这意味着在多线程环境下需要进行额外的同步处理，或者使用java.util.concurrent包中的并发数据结构来保证线程安全。 动态大小: LinkedList的大小是动态的，它会根据需要动态分配内存。这意味着它可以容纳任意数量的元素，但需要根据实际使用情况分配和释放内存，可能会引入一些内存管理开销。 LinkedList是一个灵活的双向链表实现，适合用于需要频繁插入和删除操作的情况，以及栈和队列等数据结构的实现。但需要注意，对于需要随机访问的情况，ArrayList通常更为高效。 自定义实现1. 使用数组可以使用数组来实现栈，通过维护一个指向栈顶元素的指针（通常称为top），以及数组来存储栈的元素。当进行push和pop操作时，相应地更新栈顶指针和数组元素。这种实现方式的优点是简单，但需要注意数组大小的限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ArrayStack &#123; private int maxSize; // 栈的最大容量 private int top; // 栈顶指针 private int[] stack; // 存储元素的数组 public ArrayStack(int maxSize) &#123; this.maxSize = maxSize; this.stack = new int[maxSize]; this.top = -1; // 栈开始时为空 &#125; // 判断栈是否为空 public boolean isEmpty() &#123; return top == -1; &#125; // 判断栈是否已满 public boolean isFull() &#123; return top == maxSize - 1; &#125; // 入栈 public void push(int item) &#123; if (isFull()) &#123; System.out.println(&quot;栈已满，无法入栈&quot;); return; &#125; stack[++top] = item; &#125; // 出栈 public int pop() &#123; if (isEmpty()) &#123; System.out.println(&quot;栈为空，无法出栈&quot;); return -1; // 返回一个特定的值表示栈为空 &#125; return stack[top--]; &#125; // 查看栈顶元素 public int peek() &#123; if (isEmpty()) &#123; System.out.println(&quot;栈为空，无法查看栈顶元素&quot;); return -1; // 返回一个特定的值表示栈为空 &#125; return stack[top]; &#125; public static void main(String[] args) &#123; ArrayStack stack = new ArrayStack(5); stack.push(1); stack.push(2); stack.push(3); System.out.println(&quot;栈顶元素：&quot; + stack.peek()); while (!stack.isEmpty()) &#123; System.out.println(&quot;出栈元素：&quot; + stack.pop()); &#125; &#125;&#125; 2. 使用链表:类似于使用数组，您可以使用链表来实现栈。链表的头节点可以充当栈顶，而push和pop操作将在链表头部进行。这种实现方式通常不会受到数组大小的限制，并且在动态大小方面更加灵活。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class LinkedListStack&lt;T&gt; &#123; private Node&lt;T&gt; top; // 栈顶节点 private static class Node&lt;T&gt; &#123; T data; Node&lt;T&gt; next; public Node(T data) &#123; this.data = data; &#125; &#125; // 判断栈是否为空 public boolean isEmpty() &#123; return top == null; &#125; // 入栈 public void push(T item) &#123; Node&lt;T&gt; newNode = new Node&lt;&gt;(item); newNode.next = top; top = newNode; &#125; // 出栈 public T pop() &#123; if (isEmpty()) &#123; throw new IllegalStateException(&quot;栈为空，无法出栈&quot;); &#125; T data = top.data; top = top.next; return data; &#125; // 查看栈顶元素 public T peek() &#123; if (isEmpty()) &#123; throw new IllegalStateException(&quot;栈为空，无法查看栈顶元素&quot;); &#125; return top.data; &#125; public static void main(String[] args) &#123; LinkedListStack&lt;Integer&gt; stack = new LinkedListStack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); System.out.println(&quot;栈顶元素：&quot; + stack.peek()); while (!stack.isEmpty()) &#123; System.out.println(&quot;出栈元素：&quot; + stack.pop()); &#125; &#125;&#125; 3. 使用单链表节点如果不需要支持pop操作，只需要实现push和peek，您可以使用单链表节点来创建一个简化的栈。每个节点包含数据和一个指向下一个节点的引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SingleLinkedListStack&lt;T&gt; &#123; private Node&lt;T&gt; top; // 栈顶节点 private static class Node&lt;T&gt; &#123; T data; Node&lt;T&gt; next; public Node(T data) &#123; this.data = data; &#125; &#125; // 判断栈是否为空 public boolean isEmpty() &#123; return top == null; &#125; // 入栈 public void push(T item) &#123; Node&lt;T&gt; newNode = new Node&lt;&gt;(item); newNode.next = top; top = newNode; &#125; // 出栈 public T pop() &#123; if (isEmpty()) &#123; throw new IllegalStateException(&quot;栈为空，无法出栈&quot;); &#125; T data = top.data; top = top.next; return data; &#125; // 查看栈顶元素 public T peek() &#123; if (isEmpty()) &#123; throw new IllegalStateException(&quot;栈为空，无法查看栈顶元素&quot;); &#125; return top.data; &#125; public static void main(String[] args) &#123; SingleLinkedListStack&lt;Integer&gt; stack = new SingleLinkedListStack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); System.out.println(&quot;栈顶元素：&quot; + stack.peek()); while (!stack.isEmpty()) &#123; System.out.println(&quot;出栈元素：&quot; + stack.pop()); &#125; &#125;&#125; 4. 使用双链表节点如果需要支持pop操作和更高效的pop和peek操作，可以使用双链表节点来实现栈。这种实现方式允许从栈顶和栈底执行pop和peek操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class DoubleLinkedListStack&lt;T&gt; &#123; private Node&lt;T&gt; top; // 栈顶节点 private static class Node&lt;T&gt; &#123; T data; Node&lt;T&gt; prev; Node&lt;T&gt; next; public Node(T data) &#123; this.data = data; &#125; &#125; // 判断栈是否为空 public boolean isEmpty() &#123; return top == null; &#125; // 入栈 public void push(T item) &#123; Node&lt;T&gt; newNode = new Node&lt;&gt;(item); if (top != null) &#123; newNode.next = top; top.prev = newNode; &#125; top = newNode; &#125; // 出栈 public T pop() &#123; if (isEmpty()) &#123; throw new IllegalStateException(&quot;栈为空，无法出栈&quot;); &#125; T data = top.data; top = top.next; if (top != null) &#123; top.prev = null; &#125; return data; &#125; // 查看栈顶元素 public T peek() &#123; if (isEmpty()) &#123; throw new IllegalStateException(&quot;栈为空，无法查看栈顶元素&quot;); &#125; return top.data; &#125; public static void main(String[] args) &#123; DoubleLinkedListStack&lt;Integer&gt; stack = new DoubleLinkedListStack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); System.out.println(&quot;栈顶元素：&quot; + stack.peek()); while (!stack.isEmpty()) &#123; System.out.println(&quot;出栈元素：&quot; + stack.pop()); &#125; &#125;&#125; 自定义栈的实现方式可以根据特定需求选择，但需要注意线程安全和性能方面的考虑。 队列java.util.Queue 接口实现Java提供了java.util.Queue接口，是队列的标准接口。可以使用不同的实现类来创建队列，包括： java.util.LinkedList：基于双向链表的实现，支持先进先出（FIFO）操作。 java.util.PriorityQueue：优先级队列的实现，元素按照优先级顺序排列。 以下使用java.util.LinkedList来实现队列。offer方法用于将元素入队列，poll方法用于出队列。由于LinkedList实现了Queue接口，可以方便地使用它来实现队列的操作 123456789101112131415public class QueueByLinkedList &#123; public static void main(String[] args) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 入对列 queue.offer(1); queue.offer(2); queue.offer(3); // 出队列 while (!queue.isEmpty())&#123; System.out.println(&quot;出队元素： &quot; + queue.poll()); &#125; &#125;&#125; PriorityQueue是一个优先级队列，它根据元素的优先级来排列队列中的元素。较小的元素具有较高的优先级。使用offer方法入队列，poll方法出队列，优先级较高的元素会首先被出队列。 123456789101112131415public class QueueByPriorityQueue &#123; public static void main(String[] args) &#123; Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); // 入对列 queue.offer(1); queue.offer(2); queue.offer(3); // 出队列 while (!queue.isEmpty())&#123; System.out.println(&quot;出队元素： &quot; + queue.poll()); &#125; &#125;&#125; 使用 java.util.concurrent 包中的队列Java的java.util.concurrent包提供了多线程安全的队列实现，用于多线程环境。一些常见的实现包括： java.util.concurrent.LinkedBlockingQueue：基于链表的阻塞队列。 java.util.concurrent.ArrayBlockingQueue：基于数组的阻塞队列。 java.util.concurrent.PriorityBlockingQueue：多线程安全的优先级队列。 自定义队列此外，还可以使用数组或链表等数据结构来自定义队列的实现，根据特定需求创建自己的队列类。这通常需要额外的编程工作，但可以满足特定场景的需求。 总结本文总结了Java中栈和队列的几种实现方式: 栈的实现: 使用Java标准库中的Stack类 使用Deque接口中的LinkedList实现栈操作 自定义数组栈、链表栈、单链表栈、双链表栈 队列的实现: 使用Java标准库中的Queue接口及其实现类LinkedList、PriorityQueue 使用java.util.concurrent包下的阻塞队列 自定义使用数组或链表实现的队列","categories":[{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"hexo渲染的页面不支持mermaid语法","slug":"2023-10-16-hexo部署的页面不支持mermaid语法","date":"2023-10-15T22:09:15.568Z","updated":"2023-10-15T22:40:11.489Z","comments":true,"path":"2023/10/16/2023-10-16-hexo部署的页面不支持mermaid语法/","link":"","permalink":"http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/","excerpt":"","text":"mermaid 的介绍和使用请参考 这篇文章 和 官方文档。 hexo渲染的页面不支持mermaid语法问题问题背景在typora编写的Markdown文件能很好地渲染 mermaid 流程图，然而使用 hexo 部署后却不能渲染，只能显示出 mermaid 代码。 解决方案从 hexo插件官网 找到对应的插件 hexo-filter-mermaid-diagrams，参照 hexo-filter-mermaid-diagrams 官方给出的环境配置方法进行配置。 安装插件 123yarn add hexo-filter-mermaid-diagrams// ornpm install hexo-filter-mermaid-diagrams 修改配置文件 同时修改根目录和themes目录下的 _config.yml 文件，加上以下内容： 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 在pug或js中包含mermaid.js 笔者使用的主题是 pure，在 themes\\pure\\layout\\_commons 路径下的 footer.ejs 中添加如下代码： 12345678&lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; 具体情况请参考 hexo-filter-mermaid-diagrams官方说明 。","categories":[{"name":"随机BUG","slug":"随机BUG","permalink":"http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"mermaid","slug":"mermaid","permalink":"http://example.com/tags/mermaid/"}]},{"title":"二叉树基本定义以及遍历方法","slug":"2023-10-16-二叉树基本概念与遍历方法","date":"2023-10-15T16:52:39.418Z","updated":"2023-10-20T06:44:51.934Z","comments":true,"path":"2023/10/16/2023-10-16-二叉树基本概念与遍历方法/","link":"","permalink":"http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"本文来自程序员Carl的 代码随想录。 [toc] 二叉树的基本定义二叉树的种类解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。 满二叉树满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树，如下图所示。 文章中使用了画图功能，使用方式参考 这篇文章， mermaid语法请参考 官方文档。 graph TD A-->B A-->C B-->D B-->E C-->F C-->G D-->H D-->I E-->J E-->K F-->L F-->M G-->N G-->O 完全二叉树完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。如下面的两个是完全二叉树： graph TD A-->B A-->C B-->D B-->E C-->F C-->G D-->H D-->I E-->J graph TD A-->B A-->C B-->D B-->E C-->F C-->G D-->H D-->I E-->J E-->K 而下面一个就不是完全二叉树： graph TD A-->B A-->C B-->D B-->E C-->F C-->G D-->H D-->I E-->Null E-->K 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系 二叉搜索树相比于前面介绍的没有数值的树，二叉搜索树是有数值的了，二叉搜索树是一个有序树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 例如下面这两棵树都是搜索树 graph TD 10-->6 10-->16 6-->3 6-->9 16-->14 16-->19 graph TD 10-->6 10-->Null 6-->3 6-->9 平衡二叉搜索树平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。例如： graph TD 10-->6 10-->16 6-->3 6-->9 graph TD 10-->6 10-->16 6-->3 6-->9 16-->14 16-->19 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是$log\\ n$， 注意这里不包括unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表 二叉树的存储方式二叉树可以链式存储，也可以顺序存储。 那么链式存储方式就用指针， 顺序存储的方式就是用数组。 顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。 链式存储比较直观，即给每个节点设置左指针和有指针，分别指向左子树和右子树。 如何顺序存储呢？其实就是用数组来存储二叉树，顺序存储的方式如图： graph TD a-->b a-->c b-->d b-->e c-->f c-->g 对应的存储数组为：[a,b,c,d,e,f,g]，下标对应 0-6。 顺序存储的遍历方式： 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。 二叉树的遍历方式 注意总结做题的框架！！ 关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。 二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 这两种遍历是图论中最基本的两种遍历方式，后面在介绍图论的时候还会介绍到。 那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 在深度优先遍历中：有三个顺序，前中后序遍历。这里前中后，其实指的就是中间节点的遍历顺序，因此只需要记住： 前中后序指的就是中间节点的位置。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 例如对于下面的图，前中后序遍历的顺序依次是： 前序（DLR）：abdecfg 中序（LDR）：dbeafcg 后序（LRD）：debfgca graph TD a-->b a-->c b-->d b-->e c-->f c-->g 最后是二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。 前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。 而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树的代码实现 在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。 因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！ 1234567// C++代码struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; 1234567891011121314// java 代码public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 二叉树的递归遍历递归的三要素本部分将介绍前后中序的递归写法。首先确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！ 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 题目链接及题解 LC144_二叉树的前序遍历 确定递归函数的参数和返回值。预设代码给出了preorderTraversal函数，其参数为 TreeNode类型的root节点，返回List&lt;Integer&gt;类型。实现递归函数preorder，该函数主要实现对二叉树的遍历，并把遍历结果插入result向量中，返回值为void；参数需要两个：当前的结点和result向量 确定终止条件：当前结点为 null 时递归终止 单层递归逻辑：DLR 12345678910111213141516171819202122class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); preorder(root, result); return result; &#125; // 确定参数：当前节点 和 result List // 返回值： void public void preorder(TreeNode curr, List&lt;Integer&gt; result)&#123; // 终止条件 if(curr == null)&#123; return; &#125; // 单层递归逻辑：DLR result.add(curr.val); preorder(curr.left, result); preorder(curr.right, result); &#125;&#125; LC94_二叉树的中序遍历 原理&amp;思路同上一题 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); postorder(root, result); return result; &#125; // LRD public void postorder(TreeNode curr, List&lt;Integer&gt; result)&#123; if(curr == null)&#123; return; &#125; postorder(curr.left, result); postorder(curr.right, result); result.add(curr.val); &#125;&#125; LC145_二叉树的后序遍历 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorder(root, result); return result; &#125; public void inorder(TreeNode curr, List&lt;Integer&gt; result)&#123; if(curr == null)&#123; return; &#125; inorder(curr.left, result); result.add(curr.val); inorder(curr.right, result); &#125;&#125; BM24 二叉树的中序遍历 12345678910111213141516171819202122232425262728public class Solution &#123; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return int整型一维数组 */ public int[] inorderTraversal (TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorder(root, result); int[] resultArr = result.stream().mapToInt(i -&gt; i).toArray(); return resultArr; &#125; public void inorder(TreeNode curr, List&lt;Integer&gt; result)&#123; if(curr == null)&#123; return; &#125; inorder(curr.left, result); result.add(curr.val); inorder(curr.right, result); &#125;&#125; BM25 二叉树的后序遍历 BM23 二叉树的前序遍历 二叉树的迭代遍历 见 代码随想录。 迭代法遍历的基本原理 此部分建议细读 代码随想录-二叉树的迭代遍历 理解迭代遍历的基本原理。 统一迭代方法迭代法实现的先中后序，其实风格并不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。 经过实践会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。 统一写法的基本思路是：将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。 如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法 12345678910111213141516171819202122232425// 前序class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.peek(); if (node != null) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425// 中序class Solution &#123;public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.peek(); if (node != null) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 &#125; &#125; return result;&#125;&#125; 12345678910111213141516171819202122232425// 后序class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.peek(); if (node != null) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 &#125; &#125; return result; &#125;&#125; 二叉树的层序遍历基本原理层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。 而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。 使用队列实现二叉树广度优先遍历，动画如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 102.二叉树的层序遍历class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; //checkFun01(root,0); checkFun02(root); return resList; &#125; //DFS--递归方式 public void checkFun01(TreeNode node, Integer deep) &#123; if (node == null) return; deep++; if (resList.size() &lt; deep) &#123; //当层级增加时，list的Item也增加，利用list的索引值进行层级界定 List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;(); resList.add(item); &#125; resList.get(deep - 1).add(node.val); checkFun01(node.left, deep); checkFun01(node.right, deep); &#125; //BFS--迭代方式--借助队列 public void checkFun02(TreeNode node) &#123; if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) &#123; List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) &#123; TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; &#125; resList.add(itemList); &#125; &#125;&#125; 题目链接 LC102. 二叉树的层序遍历； LC107. 二叉树的层序遍历 II； LC199. 二叉树的右视图；","categories":[{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Hello World","slug":"2023-10-15-hello-world","date":"2023-10-14T16:08:56.164Z","updated":"2023-10-14T16:04:19.185Z","comments":true,"path":"2023/10/15/2023-10-15-hello-world/","link":"","permalink":"http://example.com/2023/10/15/2023-10-15-hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"搭建GitHub Page-Jekyll篇","slug":"2023-10-13-搭建GitHub主页-jekyll篇","date":"2023-10-13T09:25:37.729Z","updated":"2023-10-20T06:46:27.904Z","comments":true,"path":"2023/10/13/2023-10-13-搭建GitHub主页-jekyll篇/","link":"","permalink":"http://example.com/2023/10/13/2023-10-13-%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/","excerpt":"","text":"一、概述 emoji 好看吗？这里 有很多哦 应该没有一个开发人员不向往有一个自己的个人网页吧？:smirk: 这个主页怎么搭建呢？事实上，网络上有很多将搭建个人博客网站的项目，这样当然是好的，可是似乎需要自己搞一台服务器啊？如果服务器过期了，网站是不是就404了呢？:thinking: 那能不能不用自己租服务器，快乐当白嫖怪呢？GitHub表示：宝宝，还没想起来我吗？:triumph::kissing_heart: 不会前端咋办？当然是本着将白嫖进行到底的原则啦！看这里:point_right: Jekyll 模板:point_left:。 二、Windows环境配置 Ruby (ruby -v) RubyGems (gem -v) Gcc &amp; make (gcc -v | g++ -v | make -v ) Git (git –version) 配置Gcc、make环境 参考： Gcc、g++安装； make安装。 安装 Ruby 和 Jekyll 参考 Jekyll 官方环境配置指南 。 通过 RubyInstaller 安装Windows上安装Ruby和Jekyll最简单的方法是 RubyInstaller，RubyInstaller是一个基于windows的比较完备的安装程序，包括Ruby语言、执行环境、重要文档等等。 官方配置中介绍的是 RubyInstaller-2.4及更新版本，直接选择最新的安装包。 详细步骤： 从 RubyInstaller Downloads 下载并安装 Ruby+Devkit 版本。使用默认选项进行安装； 在安装向导的最后阶段运行 ridk install 步骤。这是安装带有本地扩展的 gem 所需要的。可以在 RubyInstaller Documentation 中找到更多相关信息。从选项中选择 MSYS2 and MINGW development tool chain ； 从开始菜单打开一个新的命令提示窗口，这样对 PATH 环境变量的更改就会生效。使用命令 gem Install Jekyll Bundler 安装Jekyll和Bundler； 注意：此处需将 Ruby gem的源换回国内源，清华镜像源操作方法。 查看Jekyll 是否正确安装：jekyll -v； RubyInstaller Downloads页面 安装向导完成页面 运行 ridk install ridk install 运行完成 检查Jekyll是否成功安装 通过bash安装 参考 Jekyll 官方环境配置指南 ，此处不再尝试 三、配置个人主页根据自己选择的 Jekyll 模板，进行后续配置。以 Chirpy 模板为例。 1. 创建仓库 + 准备模板源码首先创建名为 username.github.io 的远程仓库，并clone到本地。 :warning: username不是你的昵称 or 你自己的名字。 :heavy_check_mark: username是你的github账户名，要严格保持一致 下载 Chripy 的源码，解压到clone的本地文件夹目录下，使用 bundle install 构建本地环境。 :warning: 记住将 Gemfile 中的 source 替换为 清华镜像源。 2. 部署个人主页修改配置文件部署前，配置 _config.yml 中的 url，填写为仓库地址。 Before the deployment begins, check out the file_config.ymland make sure theurlis configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other thanGitHub Pages, remember to change thebaseurlto your project name that starts with a slash, e.g,/project-name. 使用Github Action部署个人主页。 首先在仓库设置页(Settings)-&gt;Pages-&gt;Build and deployment从下拉菜单中选择Github Actions。 Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar. Then, in the Source section (under Build and deployment), select GitHub Actions from the dropdown menu. 然后把本地修改commit并提交到Github远程仓库上，可以触发Github Action的Build and deployment工作流进行部署。如果没有自动触发，可以手动点击Build and Deploy进行部署。 Push any commits to GitHub to trigger the Actions workflow. In the Actions tab of your repository, you should see the workflow Build and Deploy running. Once the build is complete and successful, the site will be deployed automatically. 等待一段时间后，在 Actions 页查看部署情况。 可能的错误 (可选)手动构建和配置 不再演示，可参考 官方文档。 本地运行Jekyll项目在项目路径下使用命令 bundle exec jekyll serve，即可在 Web 浏览器中导航到 http://localhost:4000 浏览本地项目。 参考文章 知乎-春枫禾旭 的博客； GitHub Page中文教程； Jekyll 模板主页； Jekyll 官方环境配置指南； Chirpy官方文档 ； emoji小基地","categories":[{"name":"工具库","slug":"工具库","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E5%BA%93/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]}],"categories":[{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"},{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"随机BUG","slug":"随机BUG","permalink":"http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"},{"name":"工具库","slug":"工具库","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E5%BA%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"mermaid","slug":"mermaid","permalink":"http://example.com/tags/mermaid/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"}]}