{"meta":{"title":"Liangshou","subtitle":"","description":"","author":"Liangshou","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"about","date":"2023-10-15T08:26:48.000Z","updated":"2023-10-15T08:26:48.224Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-10-15T08:28:18.437Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"LC热题100-前缀和+哈希表","slug":"2023-10-25-刷题笔记","date":"2023-10-25T15:43:31.248Z","updated":"2023-10-25T16:13:26.437Z","comments":true,"path":"2023/10/25/2023-10-25-刷题笔记/","link":"","permalink":"http://example.com/2023/10/25/2023-10-25-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"题目链接：和为k的子数组 参见：力扣官方题解 链接：https://leetcode.cn/problems/subarray-sum-equals-k/ 12345678910111213141516171819202122232425262728class Solution { public int subarraySum(int[] nums, int k) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(0, 1); int res = 0; int left = 0; int right = 0; int n = nums.length; int[] pre = new int[n]; pre[0] = nums[0]; for(int i = 1; i &lt; n; i++){ pre[i] = pre[i - 1] + nums[i]; } for(int i = 0; i &lt; n; i++){ if(map.containsKey(pre[i] - k)){ res += map.get(pre[i] - k); } map.put(pre[i], map.getOrDefault(pre[i], 0) + 1); } return res; }}","categories":[{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"你好，volatile！你好，synchronized！","slug":"2023-10-25-volatile与synchronized","date":"2023-10-25T12:18:17.726Z","updated":"2023-10-27T06:55:42.890Z","comments":true,"path":"2023/10/25/2023-10-25-volatile与synchronized/","link":"","permalink":"http://example.com/2023/10/25/2023-10-25-volatile%E4%B8%8Esynchronized/","excerpt":"","text":"Synchronized和Volatile是两个在Java中用于处理多线程编程的关键字，它们分别用于实现线程同步和确保可见性。在Java多线程编程中，二者是互补的存在，而不是对立的存在。 volatile 在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 指令重排 在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。 什么是指令重排？ 简单来说，就是指在程序中写的代码，在执行时并不一定按照写的顺序。 Java指令重排是一种编译器和JVM（Java虚拟机）优化技术，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入的代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，并确保这一结果和顺序执行结果是一致的，但是这个过程并不保证各个语句计算的先后顺序和输入代码中的顺序一致。这就是指令重排序。 什么时候会发生指令重排？ 编译器重排：编译器在生成字节码或本机代码时可能会重新排列指令，以优化执行路径。这种重排通常是在不改变程序语义的前提下进行的。 处理器重排：现代处理器通常具有多级流水线，它们可以重新排列执行指令以充分利用硬件资源。处理器重排是在指令级别进行的，它不会改变程序的语义，但可能会影响线程之间的可见性。 JVM重排：JVM也可能会重新排列Java字节码指令以提高性能。这种重排也是在不改变程序语义的前提下进行的。 一个指令重排的复现案例 定义四个静态变量x,y,a,b，每次循环时让他们都等于0，接着用两个线程，第一个线程执行a=1;x=b;第二个线程执行b=1;y=a。 从逻辑上来讲，这段程序应该有3个结果： 当第一个线程执行到a=1的时候，第二个线程执行到了b=1，最后x=1，y=1； 当第一个线程执行完，第二个线程才刚开始，最后x=0，y=1； 当第二个线程执行完，第一个线程才开始，最后x=1，y=0； 理论上无论怎么样都不可能x=0,y=0; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class VolatileReOrderDemo { private static int x = 0, y = 0; private static int a = 0, b = 0; public static void main(String[] args) throws InterruptedException{ int i = 0; do { i++; x = 0; y = 0; a = 0; b = 0; // 开两个线程，第一个线程执行 a=1；x=b； 第二个线程执行 b=1;y=a Thread thread1 = new Thread(new Runnable() { @Override public void run() { // 线程1会比线程2先执行，因此用nanoTime让线程1等待线程2 0.01毫秒 shortWait(1000); a = 1; x = b; } }); Thread thread2 = new Thread(new Runnable() { @Override public void run() { b = 1; y = a; } }); thread1.start(); thread2.start(); thread1.join(); thread2.join(); // 两个线程都执行完成后拼接结果 String result = String.format(\"第 %d 次执行:\\tx=%d\\ty=%d\", i, x, y); System.out.println(result); } while (x != 0 || y != 0); } /** * 使用了一个循环来等待一段时间，但不涉及锁或通知机制。它不会释放锁，也不会等待其他线程的通知。 * 仅用于简单的等待一段时间，而不是线程之间的协作。 * * @param interval 等待的时间间隔 */ public static void shortWait(long interval){ long start = System.nanoTime(); long end; do { end = System.nanoTime(); }while (start + interval &gt;= end); }} 实际上，当程序运行几万或几十几百万次后，会出现x=0,y=0;的结果： 12345第 4870627 次执行: x=0 y=1第 4870628 次执行: x=0 y=1第 4870629 次执行: x=0 y=1第 4870630 次执行: x=0 y=1第 4870631 次执行: x=0 y=0 这就是因为指令被重排序了，x=b先于a=1执行，y=a先于b=1执行。 volatile 禁止指令重排 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。 内存屏障 是一个CPU的指令，它可以保证特定操作的执行顺序。 volatile关键字确保了禁止特定类型的指令重排。在volatile变量的读操作和写操作周围，编译器和处理器会添加内存屏障（Memory Barrier），确保写操作不会被重排到读操作之前，也不会被重排到读操作之后。这意味着其他线程在读取volatile变量时，将看到写操作的结果，而不会看到它们之间的重排序。 单例模式：一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点以获取该实例。单例模式通常用于那些需要在应用程序中全局共享一个实例的情况，以确保该实例在整个应用程序生命周期内只被创建一次。 12345678910111213141516171819202122232425/** * 双重校验锁实现对象单例 */public class Singleton { private volatile static Singleton uniqueInstance; private Singleton(){ } public static Singleton getUniqueInstance(){ // 判断是否已经实例化过，没有实例化过才进入加锁代码 if(uniqueInstance == null){ // 类对象加锁 synchronized (Singleton.class){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } } } return uniqueInstance; }} uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 volatile保证变量的可见性 设计如下的程序验证： 123456789101112131415161718192021222324252627282930313233343536373839404142public class VolatileVisibilityDemo { private volatile boolean flag = false; public void toggleFlag(){ // 修改 flag 的值 flag = !flag; } public boolean isFlag(){ // 读取 flag return flag; } public static void main(String[] args) { VolatileVisibilityDemo example = new VolatileVisibilityDemo(); // 线程 A：修改flag Thread threadA = new Thread(() -&gt; { try { Thread.sleep(1000); // 让 B 线程有足够的时间启动 } catch (InterruptedException e) { e.printStackTrace(); throw new RuntimeException(e); } example.toggleFlag(); System.out.println(\"Flag has been set to true\"); }); // 线程 B：检查flag的值 Thread threadB = new Thread(() -&gt; { while (!example.isFlag()){ // 等待 flag 变成 true } System.out.println(\"Flag is now true\"); }); threadA.start(); threadB.start(); }} 在这个示例中，有两个线程，线程A负责修改flag的值为true，而线程B负责检查flag的值是否为true。由于flag被声明为volatile，线程B能够立即看到线程A对flag的修改，因此线程B将在flag变为true后输出相应的信息。 如果将flag声明为非volatile的话，线程B可能会永远等待下去，因为不保证可见性，线程B无法及时获取到线程A对flag的修改。这就是volatile关键字的作用，确保变量的可见性，适用于需要跨线程通信的情况。 volatile不保证原子性 volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。 原子性（Atomicity）是多线程编程中的一个重要概念，它指的是一个操作是不可分割的，要么全部执行，要么全部不执行。如果一个操作是原子性的，那么在多线程环境下，其他线程无法在执行该操作的过程中干扰或修改其状态，从而确保操作的一致性和完整性。 验证示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 验证 volatile 不保证变量操作的原子性 */public class VolatileAtomicityDemo { public volatile static int inc = 0; public void increase(){ inc++; } public static void main(String[] args) throws InterruptedException{ int numThreads = 5; int numIteration = 500; ExecutorService threadPool = Executors.newFixedThreadPool(numThreads); VolatileAtomicityDemo volatileAtomicityDemo = new VolatileAtomicityDemo(); for (int i = 0; i &lt; numThreads; i++){ threadPool.execute(() -&gt; { for (int j = 0; j &lt; numIteration; j++){ volatileAtomicityDemo.increase(); } }); } // 等待 1.5 秒，保证上面的程序执行完成 Thread.sleep(15000); System.out.printf(\"共有%d个线程，每个线程迭代%d次。本应增长%d次！\\n\", numThreads, numIteration, numThreads * numIteration); System.out.printf(\"实际增长次数为：%d\\n\", inc); threadPool.shutdown(); }} 输出为： 12共有5个线程，每个线程迭代500次。本应增长2500次！实际增长次数为：2417 正常情况下，运行上面的代码理应输出 2500。但真正运行了上面的代码之后，你会发现很多时候结果都小于 2500。 也就说明，如果 volatile 能保证 inc++ 操作的原子性的话。每个线程中对 inc 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500=2500。 事实上，inc++ 是一个复合操作，包括三步： 读取 inc 的值。 对 inc 加 1。 将 inc 的值写回内存。 volatile 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现： 线程 1 对 inc 进行读取操作之后，还未对其进行修改。线程 2 又读取了 inc的值并对其进行修改（+1），再将inc 的值写回内存。 线程 2 操作完毕后，线程 1 对 inc的值进行修改（+1），再将inc 的值写回内存。 这也就导致两个线程分别对 inc 进行了一次自增操作后，inc 实际上只增加了 1。 其实，如果想要保证上面的代码运行正确也非常简单，利用 synchronized、Lock或者AtomicInteger都可以。 synchronized synchronized 是 Java 中的一个关键字，中文意思为“同步”、“协调”，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 具体使用场景 实例方法与静态方法 在Java中，方法可以分为两大类：实例方法和静态方法。这两种方法有不同的特点和用途。 实例方法（Instance Method）： 实例方法是与对象实例相关联的方法。 它可以访问和操作对象的实例变量（成员变量）。 实例方法必须通过对象调用，因为它们依赖于对象的状态。 通常用于封装对象的行为和操作。 例子： 123456789101112131415public class Car { String model; public void start() { System.out.println(\"Starting the \" + model + \" car.\"); }}public class Main { public static void main(String[] args) { Car myCar = new Car(); myCar.model = \"Toyota\"; myCar.start(); // 调用实例方法 }} 在上面的示例中，start 是一个实例方法，它操作了 Car 类的实例变量 model，并且必须通过 myCar 实例调用。 静态方法（Static Method）： 静态方法与类相关联，而不是与对象实例相关联。 它不可以访问对象的实例变量，因为它与特定实例无关。 静态方法可以直接通过类名调用，无需创建对象。 通常用于执行与类相关的操作，不依赖于特定实例。 例子： 123456789101112public class MathUtils { public static int add(int a, int b) { return a + b; }}public class Main { public static void main(String[] args) { int result = MathUtils.add(5, 3); // 调用静态方法 System.out.println(\"Result: \" + result); }} 在上面的示例中，add 是一个静态方法，它与特定的对象实例无关，可以直接通过类名 MathUtils 调用。 实例方法与对象实例相关联，可以访问实例变量，静态方法与类相关联，不依赖于对象实例，不能访问实例变量。 synchronized修饰实例方法 给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 。 123synchronized void method() { ...} synchronized修饰静态方法 给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。 这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。 123synchronized static void method() { ...} synchronized修饰代码块 对括号里指定的对象/类加锁： synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。 synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁 构造方法不能使用 synchronized 关键字修饰。 因为构造方法本身就属于线程安全的，不存在同步的构造方法一说。 synchronized 保证操作的可见性 1234567891011121314151617181920212223242526272829303132333435363738394041public class SynchronizedVisibilityDemo { private boolean flag = false; public synchronized void writeData(){ flag = true; } public synchronized boolean readData(){ return flag; } public static void main(String[] args) { SynchronizedVisibilityDemo demo = new SynchronizedVisibilityDemo(); Thread writerThread = new Thread(() -&gt; { // 保证让读线程先运行 try { Thread.sleep(1500); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.printf(\"Data is %s, ready to write to %s.\\n\", demo.flag, !demo.flag); demo.writeData(); }); Thread readerThread = new Thread(() -&gt; { while (true){ // 等待数据变为 true if (demo.readData()) break; } System.out.println(\"Data is true now!\"); }); readerThread.start(); writerThread.start(); }} 在这个示例中，假如不加 synchronized 关键字，写线程对 flag 的操作对于读线程来说是不可见的，读线程会一直等待下去。 synchronized 保证操作的原子性 与 volatile 的验证方法相似。不加 synchronized 修饰，结果可能为： 12共有5个线程，每个线程迭代1000次。增长后 Counter 应为 5000！实际 Counter: 4395 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738public class SynchronizedAtomicityDemo { private int counter = 0; public synchronized void increase(){ counter++; } public int getCounter(){ return counter; } public static void main(String[] args) throws InterruptedException { int numThreads = 5; int numIteration = 1000; ExecutorService threadPool = Executors.newFixedThreadPool(numThreads); SynchronizedAtomicityDemo demo = new SynchronizedAtomicityDemo(); for (int i = 0; i &lt; numThreads; i++) { threadPool.execute(() -&gt; { for (int j = 0; j &lt; numIteration; j++) { demo.increase(); } }); } // 关闭线程池并等待所有任务完成 threadPool.shutdown(); boolean termination = threadPool.awaitTermination(1, TimeUnit.MINUTES); System.out.printf(\"共有%d个线程，每个线程迭代%d次。增长后 Counter 应为 %d！\\n\", numThreads, numIteration, numThreads * numIteration); System.out.println(\"实际 Counter: \" + demo.getCounter()); }} synchronized 底层原理 对于修饰代码块的情况 12345678910111213public class SynchronizedCodeBlockDemo { public void method(){ synchronized (this){ System.out.println(\"Synchronized 代码块\"); } } public static void main(String[] args) { SynchronizedCodeBlockDemo demo = new SynchronizedCodeBlockDemo(); demo.method(); }} 将代码使用javac编译，之后再执行javap -c -s -v -l SynchronizedCodeBlockDemo.class 命令后，可以看到 method 方法反编译的结果： 解读： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void method();：这是方法的定义，名称为method，没有参数，返回类型为void，并且被声明为public。descriptor: ()V：这部分描述了方法的描述符。()表示方法没有参数，V表示返回类型为void。flags: (0x0001) ACC_PUBLIC：这是方法的修饰符，表示这个方法是public的。Code:：以下是方法的字节码指令。stack=2, locals=3, args_size=1：这是方法执行时的堆栈深度、本地变量数和参数数量的信息。0: aload_0：加载对象引用到操作数栈上。1: dup：复制栈顶的值并将副本压入栈。2: astore_1：将栈顶的值存储到局部变量1中。3: monitorenter：进入对象监视器（锁定对象），用于同步块的开始。4: getstatic #7：从静态字段#7（可能是java/lang/System.out的字段）获取一个值。7: ldc #13：将常量#13（可能是字符串常量\"Synchronized 代码块\"）加载到操作数栈上。9: invokevirtual #15：调用虚拟方法#15（可能是java/io/PrintStream.println）。12: aload_1：将局部变量1加载到栈上。13: monitorexit：退出对象监视器，用于同步块的结束。14: goto 22：跳转到第22条指令。17: astore_2：将栈顶的异常对象存储到局部变量2中。18: aload_1：将局部变量1加载到栈上。19: monitorexit：再次尝试退出对象监视器，用于异常处理。20: aload_2：将异常对象加载到栈上。21: athrow：抛出异常。22: return：返回指令，方法执行结束。Exception table:：这是异常处理表，描述了哪些异常在哪些范围内被处理。LineNumberTable:：这是行号表，指明了字节码指令和源代码之间的对应关系。LocalVariableTable:：这是本地变量表，列出了本地变量的信息。 需要注意 Code 部分的第3、13、19，这表明 synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 上面的字节码中包含一个 monitorenter 指令以及两个 monitorexit 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放 对于修饰方法的情况 同样的方式操作以下代码： 1234567891011public class SynchronizedMethodDemo { public synchronized void method(){ System.out.println(\"Synchronized 方法\"); } public static void main(String[] args) { SynchronizedMethodDemo demo = new SynchronizedMethodDemo(); demo.method(); }} 与修饰代码块相对比， synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁 flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED：这是方法的修饰符，表示这个方法是public的，并且使用了synchronized修饰符。 volatile 与 synchronized 的本质都是对对象监视器 monitor 的获取。 synchronized 和 volatile 的区别 volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。","categories":[{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Java线程","slug":"Java线程","permalink":"http://example.com/tags/Java%E7%BA%BF%E7%A8%8B/"}]},{"title":"LC热题100-无重复字符的最长子串","slug":"2023-10-24-刷题笔记","date":"2023-10-24T11:40:12.465Z","updated":"2023-10-24T13:21:23.472Z","comments":true,"path":"2023/10/24/2023-10-24-刷题笔记/","link":"","permalink":"http://example.com/2023/10/24/2023-10-24-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Problem: 3. 无重复字符的最长子串 思路 首先确定整体思路：滑动窗口。需要考虑的点： 窗口内是什么？ 何时调整窗口大小？ 如何调整窗口大小？ 解题方法 窗口的表示 窗口内表示的应该是连续的无重复字符的子串，窗口的长度也就代表了子串的长度。 窗口的左端：设计为left索引 窗口的右端：逐渐向后遍历的指针（索引） 何时调整窗口大小？ 只要窗口内的元素无重复，$left$ 就不动，索引一直往后遍历； 一旦出现索引到的元素重复了，就需要调整窗口，使得始终满足：窗口内的元素是不重复的。 如何调整窗口大小？ 窗口是通过 $left$ 指针来调整的，那么如何调整 $left$ 指针呢？ $left$ 移动应该遵循的规律是：一旦出现重复的元素，$left$ 移动到窗口内重复元素的下一位。 举两个例子： 1输入：[abcabcbb] 首次出现重复的字符是 a，对应索引为 3，此时 $left$ 还是0，窗口内元素为 abc，窗口内重复的元素的索引是 0，$left$ 更新为 $0+1$，即 $left$ 指向了b。 1输入：[abcbbcbb] 此时首次出现重复的字符就变成了 b，对应索引为 3，此时 $left$ 还是0，窗口内元素为 abc，窗口内重复的元素的索引是 1，$left$ 更新为 $1+1$，即 $left$ 指向了c。 方法有了，怎么实现定位？ 上面的思路中，$left$ 怎么实现精确、快速的定位很重要！总不能在窗口内遍历一遍吧？（似乎也不是不行）但是这样的方式时间复杂度会提高，而且这样是相对位置，处理起来也比较麻烦。 此时，我们需要一个数据结构，能够同时记录 元素值和元素索引，并且，元素值最好是不重复的。HashMap 就很合适，而且还能快速查找是否窗口内出现重复的字符。 Map如何更新？ 出现重复后，更新为最新的$ &lt;字符,索引&gt;$ 对。 复杂度 时间复杂度: 添加时间复杂度, 示例： $O(n)$ 空间复杂度: 添加空间复杂度, 示例： $O(n)$ Code []123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// .::::.// .::::::::.// :::::::::::// ..:::::::::::'// '::::::::::::'// .::::::::::// '::::::::::::::..// ..::::::::::::.// ``::::::::::::::::// ::::``:::::::::' .:::.// ::::' ':::::' .::::::::.// .::::' :::: .:::::::'::::.// .:::' ::::: .:::::::::' ':::::.// .::' :::::.:::::::::' ':::::.// .::' ::::::::::::::' ``::::.// ...::: ::::::::::::' ``::.// ```` ':. ':::::::::' ::::..// '.:::::' ':'````..class Solution { public int lengthOfLongestSubstring(String s) { if(s == null || s.length() == 0){ return 0; } int n = s.length(); int curLen = 0; int maxLen = 0; int left = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; n; i++){ char ch = s.charAt(i); if(map.containsKey(ch)){ // 调整 left 的位置 left = Math.max(left, map.get(ch) + 1); } curLen = i - left + 1; maxLen = maxLen &gt; curLen?maxLen:curLen; map.put(ch, i); } return maxLen; }}","categories":[{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"LC热题100-","slug":"2023-10-23-刷题笔记","date":"2023-10-23T00:12:00.152Z","updated":"2023-10-23T02:38:38.223Z","comments":true,"path":"2023/10/23/2023-10-23-刷题笔记/","link":"","permalink":"http://example.com/2023/10/23/2023-10-23-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"字母异位词分组 NC294-字母异位词分组 LC49-字母异位词分组 1234567891011121314151617181920212223242526class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { if(strs == null || strs.length == 0){ return new ArrayList&lt;&gt;(); } Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); // List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;List&lt;String&gt;&gt;(); for(String str: strs){ String keyStr = convertToKey(str); if(!map.containsKey(keyStr)){ map.put(keyStr, new ArrayList&lt;&gt;()); } map.get(keyStr).add(str); } return new ArrayList&lt;&gt;(map.values()); } public String convertToKey(String str){ char[] charArr = str.toCharArray(); Arrays.sort(charArr); return new String(charArr); }}","categories":[{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"hexo渲染的页面不支持emoji表情","slug":"2023-10-21-hexo部署的页面不支持emoji表情的问题","date":"2023-10-20T16:14:29.704Z","updated":"2023-10-20T16:38:14.498Z","comments":true,"path":"2023/10/21/2023-10-21-hexo部署的页面不支持emoji表情的问题/","link":"","permalink":"http://example.com/2023/10/21/2023-10-21-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81emoji%E8%A1%A8%E6%83%85%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"参考：https://cloud.tencent.com/developer/article/1906785 更换Markdown引擎 123npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save npm install markdown-it-emoji --save 修改_config.yml配置 1234567markdown: plugins: - markdown-it-footnote - markdown-it-sup - markdown-it-sub - markdown-it-abbr - markdown-it-emoji emoji在哪儿找？ https://wallpapers.com/emoji https://sunhwee.com/posts/a927e90e.html#toc-heading-1 …","categories":[{"name":"随机BUG","slug":"随机BUG","permalink":"http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"emoji","slug":"emoji","permalink":"http://example.com/tags/emoji/"}]},{"title":"理清 Java 容器（集合）","slug":"2023-10-20-理清 Java 容器（集合）","date":"2023-10-20T09:13:55.270Z","updated":"2023-10-22T14:46:43.519Z","comments":true,"path":"2023/10/20/2023-10-20-理清 Java 容器（集合）/","link":"","permalink":"http://example.com/2023/10/20/2023-10-20-%E7%90%86%E6%B8%85%20Java%20%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/","excerpt":"","text":"Java容器概述 Java中的容器，也就是Java 集合，是一套用于存储和组织数据的对象。容器类提供了一种将多个对象集合在一起的方式，并提供了一组方法来管理和操作这些对象。 为什么要使用Java容器？ 当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，在实际开发中，存储的数据类型多种多样且数量不确定，使用数组存储对象就会存在一些不足之处。与数组相比，Java 容器提供了更灵活、更有效的方法来存储多个数据对象。Java 容器框架中的各种容器类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。 相较于数组，Java 容器的优势有： 大小可变 支持泛型 具有内建算法 总的来说，Java 容器提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。 Java 容器概览 Java容器主要派生自两大接口：Collection接口和Map接口。前者主要用于存放单一元素，后者则主要用于存放键值对。对于Collection接口，其有三个主要的子接口：List接口、Queue接口、Set接口。Java容器的系统结构可参考下图： 分享来源：processon-java集合系统。 List, Set, Queue, Map对比 接口 主要用途 元素是否有序 元素是否可重复 List 处理顺序相关问题 ✔ ✔ Set 注重独一无二 ✖ Queue 排队功能相关 ✔ ✔ Map 基于key进行搜索 key：✖ value:✔ List List接口是用来处理顺序相关问题的很好的工具，其特点是存储的元素是有序的、可重复的。List接口最常用的实现类包括了 LinkedList、ArrayList、Stack以及Vector等，其中Stack类是Vector类的子类。 List的JDK源码为： 1public interface List&lt;E&gt; extends Collection&lt;E&gt; 底层数据结构 ArrayList：ArrayList是一个可以动态增长的数组，其底层数据结构是 Object[]数组，在JDK源码中有如下的定义（已省略javadoc）： 12345private static final Object[] EMPTY_ELEMENTDATA = {};private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};transient Object[] elementData; 在Java中，transient 关键字用于修饰类的实例变量。当一个实例变量被标记为 transient 时，它告诉Java的序列化机制不要将该变量的值持久化（即不要将其写入对象的序列化表示中），而只序列化对象的其他部分。这在对象序列化和反序列化时非常有用。 LinkedList：该类继承了AbstractSequentialList抽象类，底层的数据结构是双向链表，使用泛型定义链表节点，JDK源码（JDK17）为： 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} Vector：该类的底层数据结构同样为Object[]数组，JDK源码中的定义为： 123protected Object[] elementData;protected int elementCount; Stack：继承了Vector类，底层的数据结构与Vector一致。 ArrayList 推荐阅读这位大佬的文章：我说ArrayList初始容量是10，面试官让我回去等通知。 ArrayList v.s. Array ⚠此处的 Array 指的是普通数组，而非 java.lang、java.sql 中封装的Array类。 ArrayList 是一个可动态增长的数组，内部基于了动态数组实现，相较于 Array ，在使用上更加灵活。二者的主要区别有： ArrayList 会根据实际存储的元素动态地扩容或缩容，而 Array 被创建之后就不能再改变其长度。 ArrayList 中只能存储对象。对于基本类型（int、double、boolean等）数据，需要使用其对应的包装类（如 int – &gt; Integer、double --&gt; Double、boolean --&gt; Boolean 等）。Array 可以直接存储基本类型数据，也可以存储对象。 ArrayList 支持插入、删除、遍历常见操作，并且提供了丰富的 API 操作方法，比如 add()、remove()等。Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。 ArrayList 中使用泛型来根据需要确定存储数据的类型，确保了类型安全。Array 无此特性。 ArrayList创建时不需要指定大小，而Array创建时必须指定大小。 ⚠并不是说 ArrayList 创建时不能指定。特定情景下，指定大小可以减少容量重新分配的频率。示例代码： 12// 指定初始容量为1000ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(1000); 关于二者的示例可参考以下代码： Array： 123456789101112131415161718192021222324public class ArrayDemo { public static void main(String[] args) { // 初始化一个长度为4的String数组,两种初始化方式 String[] strArr1 = new String[]{\"Amazing\", \"Java\", \"Container\", \"!\"}; String[] strArr2 = new String[4]; // 下标访问为数组赋值，arraycopy方法 System.arraycopy(strArr1, 0, strArr2, 0, 4); System.out.println(Arrays.toString(strArr2)); // [Amazing, Java, Container, !] // 修改元素的值 strArr2[0] = \"Plain\"; System.out.println(Arrays.toString(strArr2)); // [Plain, Java, Container, !] // 删除数组中的元素，假设删除 “Container”，需要手动移动后面的元素 for (int i = 2; i &lt; strArr2.length - 1; i++) { strArr2[i] = strArr2[i+1]; } strArr2[strArr2.length - 1] = null; System.out.println(Arrays.toString(strArr2)); // [Plain, Java, !, null] }} ArrayList： 1234567891011121314151617181920public class ArrayListDemo { public static void main(String[] args) { // 初始化一个 String 类型的 ArrayList ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(Arrays.asList(\"Amazing\", \"Java\", \"Container\", \"!\")); // 添加元素到 ArrayList 中 strList.add(\"Yeah\"); System.out.println(strList); // [Amazing, Java, Container, !, Yeah] // 修改 ArrayList 中的元素 strList.set(0, \"Plain\"); System.out.println(strList); // [Plain, Java, Container, !, Yeah] // 删除 ArrayList 中的元素 strList.remove(0); System.out.println(strList); // [Java, Container, !, Yeah] }} ArrayList v.s. Vector 线程安全 ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 。 Vector 是线程安全的，它的方法都经过同步处理，可以在多线程环境中使用而无需额外的同步措施。然而，这也会导致 Vector 在性能上相对较慢，因为同步操作会带来额外的开销。 扩容机制 ArrayList 的扩容机制是不同步的，即在需要扩容时，它会创建一个新的数组，并将元素从旧数组复制到新数组。这可以在某些情况下导致不同步问题，但在单线程环境中通常性能较好。 Vector 的扩容机制是同步的，确保只有一个线程可以进行扩容操作。这也可能导致性能问题，特别是在高度并发的情况下。 此外，Vector 是Java早期版本提供的，它的设计考虑了线程安全，但在现代Java编程中，通常更推荐使用其他集合类，如 ArrayList 和 Collections 工具类，来处理线程安全问题。Vector通常被认为是一种遗留的数据结构。 ArrayList插入和删除元素的时间复杂度 头部插入/删除 当在头部插入元素时，需要将现有的元素向后移动，以便为新元素腾出空间。这涉及到将所有元素都向后移动一个位置。 时间复杂度为：O(n)，其中n是ArrayList中的元素数量。 尾部插入/删除 在ArrayList的尾部插入元素是比较高效的，因为不需要移动其他元素。时间复杂度：平均情况为O(1)，即常数时间。 但在某些情况下，可能需要重新分配内部数组，如当内部数组的容量不足时，需要进行重新分配和复制元素的操作。这会引入O(n)的时间复杂度，其中n是ArrayList的容量。这种情况下会偶尔发生，大部分时间都是O(1)。 指定位置插入/删除 当在ArrayList的中间或指定位置插入元素时，需要将插入点之后的元素向后移动，以便为新元素腾出空间。时间复杂度平均情况为O(n)。 ArrayList源码浅析 前文提及，ArrayList 的底层是数组队列，实现了一个动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。 实现与继承关系 ArrayList 继承于 AbstractList ，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。可参考 JDK 源码： 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 具体类的实现、继承关系可视化如下图。 从定义中可以得出以下信息： 指定了泛型类型参数 E，这表示 ArrayList 可以存储任意类型的对象。 实现了 List 接口，这意味着它遵循 List 接口中定义的方法和行为。List 接口表示一个有序的集合，可以包含重复元素。 实现了 RandomAccess 接口，这是一个标记接口，用于指示 ArrayList 支持随机访问（通过索引访问元素）。由于 ArrayList 是一个动态数组，它能够以常数时间复杂度（O(1)）进行随机访问。 实现了 Cloneable 接口，这意味着可以使用 clone() 方法来创建 ArrayList 的副本。 ⚠ clone() 方法返回的是浅拷贝，所以元素本身不会被复制，只是引用会被复制。 实现了 Serializable 接口，这使得它可以被序列化为字节流，以便在网络传输或保存到文件中。这允许将 ArrayList 对象持久化。 初始化方法&amp;扩容机制 推荐阅读这位大佬的文章：我说ArrayList初始容量是10，面试官让我回去等通知。 ArrayList 给出了种初始化方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 默认初始容量大小private static final int DEFAULT_CAPACITY = 10;// 用于空实例的共享空数组实例。private static final Object[] EMPTY_ELEMENTDATA = {};// 共享的空数组实例,用于默认大小的空实例。 将其与EMPTY_ELEMENTDATA区分开来,便于了解当添加第一个元素时需要膨胀多少private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};// // 存储元素的数组transient Object[] elementData; // 非私有以简化嵌套类访问/** * 带初始容量参数的构造函数。（用户自己指定容量） */public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } }/** * 默认构造函数，使用初始容量10构造一个空列表(无参数构造) */public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}/** *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 *如果指定的集合为null，throws NullPointerException。 */public ArrayList(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); if ((size = a.length) != 0) { if (c.getClass() == ArrayList.class) { elementData = a; } else { elementData = Arrays.copyOf(a, size, Object[].class); } } else { // replace with empty array. elementData = EMPTY_ELEMENTDATA; }} 调用ArrayList的无参构造方法 new ArraryList&lt;&gt;() 的时候，只是初始化了一个空对象，并没有指定数组大小，所以初始容量是零。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 LinkedList LinkedList v.s. ArrayList 对比维度 ArrayList LinkedList 内部实现 动态 Object 数组 双向链表 线程安全 不同步，线程不安全 不同步，线程不安全 插入删除操作 效率取决于操作位置 插入和删除操作通常更高效 随机访问 支持高效的随机访问 不支持高效的随机访问 空间开销 通常具有较小的空间开销 通常具有较大的空间开销 迭代 数组连续存储的性质，迭代更快 迭代较慢 因为 ArrayList只需要存储元素和数组的一些元数据（如容量），空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间；而 LinkedList 需要存储每个元素以及两个指向前一个和后一个元素的引用（指针），空间开销会比 ArrayList 大 LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o),remove(int index)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。 LinkedList源码浅析 实现与继承关系 JDK中 LinkedList 类的定义源码如下： 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList 继承了 AbstractSequentialList ，而 AbstractSequentialList 又继承于 AbstractList 。此外，LinkedList 实现了4个接口：List、Deque、Cloneable、Serializable。类图可视化为： LinkedList 实现的接口中，List、Cloneable、Serializable 与ArrayList一样，不再赘述； 此外，LinkedList 实现了 Deque 接口，这是双端队列（Double-ended Queue）的接口，它表示具有队列和栈的行为。LinkedList 可以被用作队列和栈，支持在队列的两端进行插入和删除操作。 LikedList 作为栈和队列使用可参考：Java中的栈与队列。 元素定义 LinkedList 中的元素是通过内部静态类 Node 定义的： 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } 初始化方法 LinkedList 中有设计了两种构造方法：一个无参构造函数、一个有参构造函数，具体源码为： 12345678910// 创建一个空的链表对象public LinkedList() {}// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c);} this() 表明在有参构造时，调用了类的另一个构造函数，即无参数构造函数。这意味着在创建 LinkedList 对象时，首先会调用无参数构造函数来初始化对象。 addAll 方法是类内实现的方法，作用为将集合 c 中的元素添加到当前 LinkedList 对象中。 常用方法总结 操作 方法 简述 备注 插入 add(E e) 在尾部插入元素 linkLast(E e) add(int index, E element) 在指定位置插入元素 linkLast(E e) &amp; linkBefore(E e, Node&lt;E&gt; succ) 获取元素 getFirst() 获取链表的第一个元素 LinkedList.first getLast() 获取链表的最后一个元素 LinkedList.last get(int index) 获取链表指定位置的元素 node&lt;index&gt; 删除元素 removeFirst() 删除并返回链表的第一个元素 unlinkFirst&lt;Node&lt;E&gt;&gt; removeLast() 删除并返回链表的最后一个元素 unlinkLast&lt;Node&lt;E&gt;&gt; remove(E e) 删除链表中首次出现的指定元素，如果不存在该元素则返回 false unlink&lt;Node&lt;E&gt;&gt; remove(int index) 删除指定索引处的元素，并返回该元素的值 unlink&lt;Node&lt;E&gt;&gt; void clear() 移除此链表中的所有元素 迭代器 ListItr 实现了ListIterator&lt;E&gt;接口，是能够使用for-each遍历的核心 demo 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LinkedListDemo { public static void main(String[] args) { // 创建 LinkedList 对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); // 添加元素到链表末尾 list.add(\"apple\"); list.add(\"banana\"); list.add(\"pear\"); System.out.println(\"链表内容：\" + list); // [apple, banana, pear] // 在指定位置插入元素 list.add(1, \"orange\"); System.out.println(\"链表内容：\" + list); // [apple, orange, banana, pear] // 获取指定位置的元素 String fruit = list.get(2); System.out.println(\"索引为 2 的元素：\" + fruit); // banana // 修改指定位置的元素 list.set(3, \"grape\"); System.out.println(\"链表内容：\" + list); // [apple, orange, banana, grape] // 删除指定位置的元素 list.remove(0); System.out.println(\"链表内容：\" + list); // [orange, banana, grape] // 删除第一个出现的指定元素 list.remove(\"banana\"); System.out.println(\"链表内容：\" + list); // [orange, grape] // 获取链表的长度 int size = list.size(); System.out.println(\"链表长度：\" + size); // 2 // 清空链表 list.clear(); System.out.println(\"清空后的链表：\" + list); // [] }} Vector &amp; Stack 可参考：Java中的栈与队列 Set Set在数学中是集合的意思，Set接口组织数据的特点是注重独一无二的性质，存储的元素不可重复的。 底层数据结构 HashSet：HashSet 的特点是无序性和唯一性，底层采用了HashMap来存储数据。 123private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object(); LinkedHashSet：HashSet的子类，内部实现通过LinkedHashMap，通过supper调用父类的构造方法，HashSet中定义的源码为： 123HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);} TreeSet：区别于HashSet，TreeSet的特点是有序且唯一的，底层采用了红黑树的数据结构实现。实际上，JDK17中，TreeSet类实现的是NavigableMap 接口，而后者继承了SortedMap接口。 123456// TreeSet类public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable // NavigableSet接口public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; HashSet LinkedHashSet TreeSet Queue Queue（队列）中，按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。 底层数据结构 PriorityQueue：底层是使用 Object[] 数组来实现小顶堆。 DelayQueue：PriorityQueue。 ArrayDeque:：可扩容动态双向数组。 Map 使用键值对（key-value）存储，类似于数学上的函数的一个key对应唯一value的关系，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 底层数据结构 HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。 TreeMap：红黑树（自平衡的排序二叉树）。","categories":[{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java 常识？我咋不知道","slug":"2023-10-19-我不知道的Java常识","date":"2023-10-19T15:51:41.429Z","updated":"2023-10-20T08:56:14.096Z","comments":true,"path":"2023/10/19/2023-10-19-我不知道的Java常识/","link":"","permalink":"http://example.com/2023/10/19/2023-10-19-%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%E5%B8%B8%E8%AF%86/","excerpt":"","text":"Java SE，Java EE &amp; Java ME？ 有没有想过，同样是Java，会不会存在不同的版本 or anything else？事实上，为了使软件开发人员、服务提供商和设备生产商可以针对特定的市场进行开发，SUN公司将Java划分为三个技术平台： Java SE：Standard Edition（标准版） Java EE：Enterprise Edition（商业版） Java ME：Micro Edition（小型版） Java SE 全称为Java Platform Standard Edition，这是Java 平台标准版，包含标准的 JVM和标准库，更具体地说，包括了 Java 核心的类库，如集合、IO、数据库连接以及网络编程等。 JavaSE 是Java 编程语言的基础，三个核心平台中的核心部分，Java EE 和 Java ME 都是从 JavaSE的基础上发展而来的 JavaSE是为开发普通桌面和商务应用程序提供的解决方案。 Java EE 全称是 Java Platform Enterprise Edition，Java 平台企业版，建立在 Java SE 的基础上，并加入了大量的 API 和库，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE是进一步学习Web应用所必须的，Spring等框架都是Java EE开源生态系统的一部分。 JavaEE 是为开发企业级应用程序提供的解决方案。 Java ME 全称是 Java Platform Micro Edition，Java平台小型版，是一个针对 嵌入式设备 的 “瘦身版”，要用于小型数字电子设备上软件程序的开发，例如家用电器的智能化、联网功能等。 此外，JavaME提供了HTTP等高级Internet协议，使移动电话能以Client/ Server方式直接访问 Internet的全部信息，提供最效率的无线交流。 JavaME 是为开发电子消费产品和嵌入式设备提供的解决方案。然而Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，只需要了解即可。 JDK，JVM &amp; JRE？ Java文档官网：https://docs.oracle.com/en/java/index.html 立即推(张宇老师口吻)：这题我会！事实上，这个问题倒是比较容易理解。 详细信息可参考：官方架构图。 JVM &amp; JIT JVM 即 Java 虚拟机，是运⾏ Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。 在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时⽐较⾼效 ⽽且，由于字节码并不针对⼀种特定的机器，因此，Java 程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。 Java 程序从源代码到编译运⾏⼀般需要经历以下的过程： 事实上，可以运行在 Java 虚拟机上的语言除了 Java外还有很多，如Groovy(.groovy)、Kotlin(.kt)、JRuby(.rb)、Clojure(.clj)等，它们编译运行的过程大致相似，经过对应的编译器编译为 .class字节码文件。 这里需要格外注意的是 .class --&gt; 机器码 这⼀步。在这⼀步 JVM 类加载器⾸先加载字节码⽂件，然后通过 解释器 逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐较慢。⽽且，有些⽅法和代码块是经常需要被调⽤的(也就是所谓的热点代码)，所以后⾯引进了 JIT （Just in Time Compilation）编译器，⽽ JIT 属于运⾏时编译。当 JIT 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。⽽我们知道，机器码的运⾏效率肯定是⾼于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 于是引入 JIT 后，程序从源代码到编译运⾏经历的过程具体为： JDK &amp; JRE JDK 是 Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。 JRE 是 Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。 如果只是为了运⾏⼀下 Java 程序的话，只需要安装 JRE 就可以了。如果需要进⾏⼀些Java 编程⽅⾯的⼯作，那么就需要安装 JDK 了。 这也不是绝对的。有时，即使不打算在计算机上进⾏任何 Java 开发，仍然需要安装 JDK。例如，如果要使⽤ JSP 部署 Web 应⽤程序，那么从技术上讲，只是在应⽤程序服务器中运⾏ Java 程序。 但是因为应⽤程序服务器会将 JSP 转换为 Java servlet，并且需要使⽤ JDK 来编译 servlet，还是需要安装JDK 编译与解释并存？ 参考JVM部分，可知 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。 AOT &amp; JIT？ 可参考：理解Java的JIT和AOT，JIT v.s. AOT in Java。 JIT是Just-In-Time的首字母缩写，指程序运行期间发生的编译行为。 JIT多伴随解释器，因为解释型语言是按行解释执行，JIT将“常用”功能编译为机器码，需要时直接执行，减少解释时间； 例如：Python(pypy)，新版Javascript、Ruby、Php解释器； AOT是Ahead-Of-Time的首字母缩写，指程序运行之前发生的编译行为。 对于编译型语言，AOT啥也不是，本身就是先编译后执行，但对于解释型语言，AOT提前“预见”热点功能，并编译为机器码，同样减少解释时间； 例如：C，C++，Rust，Go，Java AOT； AOP是JDK 9 引入了一种新的编译模式，主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。","categories":[{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"链表刷题—Java版","slug":"2023-10-17-链表刷题—Java版","date":"2023-10-17T12:07:36.377Z","updated":"2023-10-20T06:44:40.896Z","comments":true,"path":"2023/10/17/2023-10-17-链表刷题—Java版/","link":"","permalink":"http://example.com/2023/10/17/2023-10-17-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E2%80%94Java%E7%89%88/","excerpt":"","text":"[toc] 前言 链表是通过指针串联在一起的线性结构，指针是其中的一个重要部分。简单了解指针的概念： 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。 就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： 1type *var-name 在C/C++等语言中，都显式地定义了指针用于直接访问内存地址的机制，然而学习 Java 的人或多或少都听说过“Java没有指针”。 Java的设计目标之一是提供一种更安全和易于学习的编程语言。为了实现这一目标，Java采用了一种自动内存管理的方式，即垃圾回收机制。Java引入了引用（reference）的概念，但不允许直接访问内存地址。这意味着在Java中，并不能像C或C++中那样使用指针来操作内存。这种设计决策有助于减少内存管理错误和提高安全性。关于更多Java指针的理解，可参考 知乎专栏—Java真的没有“指针”吗？。 关于链表的基础理论，本文不再赘述，可参考：代码随想录-链表基础理论。 Java 链表的实现方式： 12345678910111213141516171819202122public class ListNode { // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() { } // 节点的构造函数(有一个参数) public ListNode(int val) { this.val = val; } // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) { this.val = val; this.next = next; }} 设计链表 题目链接： LC707. 设计链表 移除链表元素 题目链接： LC203. 移除链表元素; BM9删除链表的倒数第n个节点 因为是单链表，从前往后遍历，假如当前访问结点的 val 是要移除的，无法很好地定位到当前节点的前一个节点；另外就是需要考虑头结点可能为需要移除的结点的情况。综合来看，可以有三种移除方式：不设置 pre 节点和虚拟节点、仅设置pre节点、同时设置pre节点和虚拟节点。 LC203 不设置 pre 节点和 虚拟节点 分两步考虑：首先处理掉头结点需要移除的情况，之后判断 curr.next 节点是否需要移除。 12345678910111213141516171819class Solution { public ListNode removeElements(ListNode head, int val) { while(head != null &amp;&amp; head.val == val){ // 处理头结点要移除的情况 head = head.next; } ListNode curr = head; while(curr != null){ // curr的下一个节点 while(curr.next != null &amp;&amp; curr.next.val == val){ curr.next = curr.next.next; } curr = curr.next; } return head; }} 仅设置pre节点 同上一种方式，首先处理掉头结点需要移除的情况，之后使用 pre 节点指向 curr 的前一个节点，遍历中只需要关注 curr 节点的 val。 123456789101112131415161718192021222324252627class Solution { public ListNode removeElements(ListNode head, int val) { while(head != null &amp;&amp; head.val == val){ // 处理头结点要移除的情况 head = head.next; } if(head == null){ return null; } ListNode curr = head.next; ListNode pre = head; while(curr != null){ if(curr.val == val){ pre.next = curr.next; } else{ pre = pre.next; } curr = curr.next; } return head; }} 同时设置 pre 节点和 虚拟节点 这样做的好处在于，移除头结点和普通节点的逻辑可以统一，即原链表的所有节点就都可以按照统一的方式进行移除，使用 dummy.next 定位头结点。 12345678910111213141516171819202122class Solution { public ListNode removeElements(ListNode head, int val) { if(head == null){ return null; } // 设置虚拟节点 ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode curr = head; while(curr != null){ if(curr.val == val){ pre.next = curr.next; } else{ pre = curr; } curr = curr.next; } return dummy.next; }} BM9 index定位 123456789101112131415161718192021222324252627282930313233343536public class Solution { /** * * @param head ListNode类 * @param n int整型 * @return ListNode类 */ public ListNode removeNthFromEnd (ListNode head, int n) { if(n == 0){ return head; } // 确定链表的长度 ListNode cur = head; int len = 0; while(cur != null){ cur = cur.next; len++; } cur = head; int index = len - n; if(index == 0){ head = head.next; return head; } // 定位到要移除的结点 for(int i = 1; i &lt; index; i++){ cur = cur.next; } cur.next = cur.next.next; return head; }} 滑动窗口 1234567891011121314151617public ListNode removeNthFromEnd (ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // 向前移动 first 指针，使 first和 second 之间的间隔为n个节点 for (int i = 1; i &lt;= n + 1; i++) { first = first.next; } // 同时移动 first 和 second while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; } 翻转链表 题目链接： LC206 反转链表。 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。 然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。 为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。 接下来，就是循环走以上代码逻辑了，继续移动pre和cur指针。 最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。 1234567891011121314151617181920class Solution { public ListNode reverseList(ListNode head) { if(head == null || head.next == null){ return head; } ListNode pre = null; ListNode cur = head; ListNode tmp = null; while(cur != null){ tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; }} 链表相交 环形链表","categories":[{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"MySQL—— 基础理论概念","slug":"2023-10-17-MySQL基础","date":"2023-10-17T01:01:41.415Z","updated":"2023-10-17T03:57:40.032Z","comments":true,"path":"2023/10/17/2023-10-17-MySQL基础/","link":"","permalink":"http://example.com/2023/10/17/2023-10-17-MySQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"MySQL概述 1. 数据库相关概念 首先辨析三个概念：数据库、数据库管理系统、SQL 名称 含义 简称 数据库 存储数据的仓库，数据是有组织地进行存储 DataBase(DB) 数据库管理系统 操纵和管理数据库的大型软件 DataBase Management System(DBMS) SQL 操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 Structured Query Language(SQL) 各大主流 DBMS 的排名参考 DB-Engines Ranking， Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。 MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。 SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。 PostgreSQL：开源免费的中小型数据库。 DB2：IBM公司的大型收费数据库产品。 SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。 而不论我们使用的是上面的哪一个关系型数据库，最终在操作时，都是使用SQL语言来进行统一操作，因为SQL语言，是操作关系型数据库的 统一标准 。 2. MySQL数据库 官网地址： https://www.mysql.com/ MySQL官方提供了两种不同的版本： 社区版本（MySQL Community Server） 免费， MySQL不提供任何技术支持 商业版本（MySQL Enterprise Edition） 收费，可以使用30天，官方提供技术支持 安装与配置教程参考 知乎-smi安装、博客园-压缩包安装。 3. 数据模型 1) 关系型数据库(RDBMS) 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 所谓二维表，指的是由行和列组成的表，类似于Excel表格数据，有表头、有列、有行，还可以通过一列关联另外一个表格中的某一列数据。上述的MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。 特点： 使用表存储数据，格式统一，便于维护。 使用SQL语言操作，标准统一，使用方便。 2) 数据模型 MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构如图: 可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。 可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录 SQL 全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 。 1. SQL通用语法 SQL语句可以单行或多行书写，以分号结尾; SQL语句可以使用空格/缩进来增强语句的可读性; MySQL数据库的SQL语句不区分大小写，关键字建议使用大写; 注释： 单行注释：-- 注释内容 或 # 注释内容 多行注释：/* 注释内容 */ 2. SQL分类 SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的 3. DDL——数据定义语言 Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) 数据库操作 查询所有数据库 查询当前数据库 创建数据库 删除数据库 切换数据库 表操作 查询创建 查询当前所有表 查看指定表结构 查询指定表的建表语句 创建表结构 MySQL的数据类型 MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。 数值类型 类型 大小(BYTE) 有符号(SIGNED)范围 无符号(UNSIGNED)范围 描述 TINYINT 1 (-128,127) … 小整数值 SMALLINT 2 (-32768,32768) … 大整数值 MEDIUMINT 3 (-8388608,8388607) … 大整数值 INT/INTEGER 4 (-2^31, 2^31-1) … 大整数值 BIGINT 8 (-2^63, 2^63-1) … 极大整数值 FLOAT 4 … … 单精度浮点数值 DOUBLE 8 … … 双精度浮点数值 DECIMAL 依赖于精度M和标度D的值 … 小数值 字符串类型 类型 大小(byte) 描述 CHAR 0-255 定长字符串(需要指定长度) VARCHAR 0-65535 变长字符串(需要指定长度) TINYBLOB 0-255 不超过255个字符的二进制数据 TINITEXT 0-255 短文本字符串 BLOB 0-65535 二进制形式的长文本数据 TEXT 0-65535 长文本数据 MEDIUMBLOB 0-16777215 二进制形式的中等长度文本数据 MIDEUMTEXT 0-16777215 中等长度文本数据 LONGBLOB 0-4294967295 二进制形式的极大文本数据 LONGTEXT 0-4294967295 极大文本数据 char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。 12345678--- 1) 用户名 username ------&gt; 长度不定，最长不会超过50username varchar(50)--- 2) 性别 gender ------&gt; 存储值，不是男就是女gender char(1)--- 3) 手机号 phone ------&gt; 固定长度11（仅限国内移动手机号）phone char(11) 日期时间类型 类型 大小 范围 格式 描述 DATA 3 YYYY-MM-DD 日期值 TIME 3 HH:MM:SS 时间值或持续时间 YEAR 1 YYYY 年份值 DATETIME 8 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 4. DML DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。 添加数据（INSERT） 修改数据（UPDATE） 删除数据（DELETE） 5. DQL DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。 查询关键字: SELECT 在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。 6. DCL DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。 函数 MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。 字符串函数 内置函数一览 函数 功能 CONCAT(s1, s2, …sn) 字符串拼接，将s1，s2，… sn拼接成一个字符串 LOWER(str) 将字符串str全部转为小写 UPPER(str) 将字符串str全部转为大写 LPAD(str, N, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 演示用例 12345678910111213141516--- concatselect concat(\"Hello\", \"World\");--- lower &amp; upperselect lower(\"Hello\");select upper('Hello');--- lpad &amp; rpadselect lpad('01', 5, '-');select rpad('01', 5, '-');--- trim 去除空格select trim(' Hello MySQL ');--- substringselect substring('Hello MySQL',1,5); 数值函数 内置函数一览 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x,y) 求参数x的四舍五入的值，保留y位小数 演示用例 123456789101112131415161718--- ceil &amp; floorselect ceil(1.1);select flooor(1.9);--- modselect mod(7,4);--- randselect rand();--- roundselect round(3.344, 2);/* 通过数据库的函数，生成一个六位数的随机验证码。 思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0*/select lpad(round(rand()*1000000 , 0), 6, '0'); 日期函数 流程函数 约束 多表查询 事务","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Java中的栈与队列","slug":"2023-10-16-Java中的栈与队列","date":"2023-10-16T05:12:04.799Z","updated":"2023-10-20T06:41:20.189Z","comments":true,"path":"2023/10/16/2023-10-16-Java中的栈与队列/","link":"","permalink":"http://example.com/2023/10/16/2023-10-16-Java%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"本文主要记述 Java在实践中如何使用栈，关于栈与队列的基础知识点本文不再赘述，可参考 编程帮-栈、编程帮-队列。 栈 标准库 java.util.Stack 实现 在 java.util 中封装了 Stack 类，其继承自Vector类，定义了push、pop、peek、empty、search五个操作对Vector进行了扩展，JDK源码（已省去jdoc）如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Stack&lt;E&gt; extends Vector&lt;E&gt; { public Stack() { } // ... public E push(E item) { addElement(item); return item; } // ... public synchronized E pop() { E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; } // ... public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); } // ... public boolean empty() { return size() == 0; } // ... public synchronized int search(Object o) { int i = lastIndexOf(o); if (i &gt;= 0) { return size() - i; } return -1; } /** use serialVersionUID from JDK 1.0.2 for interoperability */ @java.io.Serial private static final long serialVersionUID = 1224463164541339165L;} Deque接口实现 在Java中，栈可以使用java.util.Stack类实现，也可以使用 java.util.LinkedList 结合push和pop操作来实现自定义的栈。通常，建议使用 Deque 接口中的 LinkedList 实现来代替java.util.Stack，因为后者是基于向量的数据结构，性能较差。 示例代码： 12345678910public class StackByDeque { public static void main(String[] args) { Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); stack.push(1); stack.push(2); int top = stack.pop(); System.out.println(top + \" \" + stack.size()); } } 其中，值得注意的是 LinkedList 类。LinkedList是Java中的一个双向链表实现，它继承自AbstractSequentialList类，并实现了List和Deque接口，同时提供了双向链表的功能。JDK中的源码如下： 1234567891011121314151617public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{ transient int size = 0; /** * Pointer to first node. */ transient Node&lt;E&gt; first; /** * Pointer to last node. */ transient Node&lt;E&gt; last; ... LinkedList 类有以下的特点： 双向链表: LinkedList是基于双向链表数据结构的实现，每个元素都被包装在一个节点中，而每个节点都包含指向前一个节点和后一个节点的引用。这使得在链表中插入和删除元素的操作非常高效，因为只需要调整节点的引用，而不需要移动其他元素。 实现了List接口: LinkedList实现了List接口，这意味着它可以像ArrayList一样用于存储有序的元素集合，支持随机访问、按索引插入和删除元素。与ArrayList不同，LinkedList在插入和删除操作上通常更高效，但在随机访问上性能较差。 实现了Deque接口: LinkedList还实现了Deque接口，这使得它可以被用作双端队列（double-ended queue）。您可以在队列的前端和后端进行插入和删除操作，支持先进先出（FIFO）和后进先出（LIFO）等不同的数据操作模式。 适合用于栈和队列: 由于LinkedList支持双向操作，它特别适合用作栈和队列的基础数据结构。您可以使用push和pop操作来实现栈，使用offer和poll操作来实现队列。 非线程安全: 与ArrayList不同，LinkedList是非线程安全的，这意味着在多线程环境下需要进行额外的同步处理，或者使用java.util.concurrent包中的并发数据结构来保证线程安全。 动态大小: LinkedList的大小是动态的，它会根据需要动态分配内存。这意味着它可以容纳任意数量的元素，但需要根据实际使用情况分配和释放内存，可能会引入一些内存管理开销。 LinkedList是一个灵活的双向链表实现，适合用于需要频繁插入和删除操作的情况，以及栈和队列等数据结构的实现。但需要注意，对于需要随机访问的情况，ArrayList通常更为高效。 自定义实现 1. 使用数组 可以使用数组来实现栈，通过维护一个指向栈顶元素的指针（通常称为top），以及数组来存储栈的元素。当进行push和pop操作时，相应地更新栈顶指针和数组元素。这种实现方式的优点是简单，但需要注意数组大小的限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ArrayStack { private int maxSize; // 栈的最大容量 private int top; // 栈顶指针 private int[] stack; // 存储元素的数组 public ArrayStack(int maxSize) { this.maxSize = maxSize; this.stack = new int[maxSize]; this.top = -1; // 栈开始时为空 } // 判断栈是否为空 public boolean isEmpty() { return top == -1; } // 判断栈是否已满 public boolean isFull() { return top == maxSize - 1; } // 入栈 public void push(int item) { if (isFull()) { System.out.println(\"栈已满，无法入栈\"); return; } stack[++top] = item; } // 出栈 public int pop() { if (isEmpty()) { System.out.println(\"栈为空，无法出栈\"); return -1; // 返回一个特定的值表示栈为空 } return stack[top--]; } // 查看栈顶元素 public int peek() { if (isEmpty()) { System.out.println(\"栈为空，无法查看栈顶元素\"); return -1; // 返回一个特定的值表示栈为空 } return stack[top]; } public static void main(String[] args) { ArrayStack stack = new ArrayStack(5); stack.push(1); stack.push(2); stack.push(3); System.out.println(\"栈顶元素：\" + stack.peek()); while (!stack.isEmpty()) { System.out.println(\"出栈元素：\" + stack.pop()); } }} 2. 使用链表: 类似于使用数组，您可以使用链表来实现栈。链表的头节点可以充当栈顶，而push和pop操作将在链表头部进行。这种实现方式通常不会受到数组大小的限制，并且在动态大小方面更加灵活。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class LinkedListStack&lt;T&gt; { private Node&lt;T&gt; top; // 栈顶节点 private static class Node&lt;T&gt; { T data; Node&lt;T&gt; next; public Node(T data) { this.data = data; } } // 判断栈是否为空 public boolean isEmpty() { return top == null; } // 入栈 public void push(T item) { Node&lt;T&gt; newNode = new Node&lt;&gt;(item); newNode.next = top; top = newNode; } // 出栈 public T pop() { if (isEmpty()) { throw new IllegalStateException(\"栈为空，无法出栈\"); } T data = top.data; top = top.next; return data; } // 查看栈顶元素 public T peek() { if (isEmpty()) { throw new IllegalStateException(\"栈为空，无法查看栈顶元素\"); } return top.data; } public static void main(String[] args) { LinkedListStack&lt;Integer&gt; stack = new LinkedListStack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); System.out.println(\"栈顶元素：\" + stack.peek()); while (!stack.isEmpty()) { System.out.println(\"出栈元素：\" + stack.pop()); } }} 3. 使用单链表节点 如果不需要支持pop操作，只需要实现push和peek，您可以使用单链表节点来创建一个简化的栈。每个节点包含数据和一个指向下一个节点的引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SingleLinkedListStack&lt;T&gt; { private Node&lt;T&gt; top; // 栈顶节点 private static class Node&lt;T&gt; { T data; Node&lt;T&gt; next; public Node(T data) { this.data = data; } } // 判断栈是否为空 public boolean isEmpty() { return top == null; } // 入栈 public void push(T item) { Node&lt;T&gt; newNode = new Node&lt;&gt;(item); newNode.next = top; top = newNode; } // 出栈 public T pop() { if (isEmpty()) { throw new IllegalStateException(\"栈为空，无法出栈\"); } T data = top.data; top = top.next; return data; } // 查看栈顶元素 public T peek() { if (isEmpty()) { throw new IllegalStateException(\"栈为空，无法查看栈顶元素\"); } return top.data; } public static void main(String[] args) { SingleLinkedListStack&lt;Integer&gt; stack = new SingleLinkedListStack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); System.out.println(\"栈顶元素：\" + stack.peek()); while (!stack.isEmpty()) { System.out.println(\"出栈元素：\" + stack.pop()); } }} 4. 使用双链表节点 如果需要支持pop操作和更高效的pop和peek操作，可以使用双链表节点来实现栈。这种实现方式允许从栈顶和栈底执行pop和peek操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class DoubleLinkedListStack&lt;T&gt; { private Node&lt;T&gt; top; // 栈顶节点 private static class Node&lt;T&gt; { T data; Node&lt;T&gt; prev; Node&lt;T&gt; next; public Node(T data) { this.data = data; } } // 判断栈是否为空 public boolean isEmpty() { return top == null; } // 入栈 public void push(T item) { Node&lt;T&gt; newNode = new Node&lt;&gt;(item); if (top != null) { newNode.next = top; top.prev = newNode; } top = newNode; } // 出栈 public T pop() { if (isEmpty()) { throw new IllegalStateException(\"栈为空，无法出栈\"); } T data = top.data; top = top.next; if (top != null) { top.prev = null; } return data; } // 查看栈顶元素 public T peek() { if (isEmpty()) { throw new IllegalStateException(\"栈为空，无法查看栈顶元素\"); } return top.data; } public static void main(String[] args) { DoubleLinkedListStack&lt;Integer&gt; stack = new DoubleLinkedListStack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); System.out.println(\"栈顶元素：\" + stack.peek()); while (!stack.isEmpty()) { System.out.println(\"出栈元素：\" + stack.pop()); } }} 自定义栈的实现方式可以根据特定需求选择，但需要注意线程安全和性能方面的考虑。 队列 java.util.Queue 接口实现 Java提供了java.util.Queue接口，是队列的标准接口。可以使用不同的实现类来创建队列，包括： java.util.LinkedList：基于双向链表的实现，支持先进先出（FIFO）操作。 java.util.PriorityQueue：优先级队列的实现，元素按照优先级顺序排列。 以下使用java.util.LinkedList来实现队列。offer方法用于将元素入队列，poll方法用于出队列。由于LinkedList实现了Queue接口，可以方便地使用它来实现队列的操作 123456789101112131415public class QueueByLinkedList { public static void main(String[] args) { Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 入对列 queue.offer(1); queue.offer(2); queue.offer(3); // 出队列 while (!queue.isEmpty()){ System.out.println(\"出队元素： \" + queue.poll()); } }} PriorityQueue是一个优先级队列，它根据元素的优先级来排列队列中的元素。较小的元素具有较高的优先级。使用offer方法入队列，poll方法出队列，优先级较高的元素会首先被出队列。 123456789101112131415public class QueueByPriorityQueue { public static void main(String[] args) { Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); // 入对列 queue.offer(1); queue.offer(2); queue.offer(3); // 出队列 while (!queue.isEmpty()){ System.out.println(\"出队元素： \" + queue.poll()); } }} 使用 java.util.concurrent 包中的队列 Java的java.util.concurrent包提供了多线程安全的队列实现，用于多线程环境。一些常见的实现包括： java.util.concurrent.LinkedBlockingQueue：基于链表的阻塞队列。 java.util.concurrent.ArrayBlockingQueue：基于数组的阻塞队列。 java.util.concurrent.PriorityBlockingQueue：多线程安全的优先级队列。 自定义队列 此外，还可以使用数组或链表等数据结构来自定义队列的实现，根据特定需求创建自己的队列类。这通常需要额外的编程工作，但可以满足特定场景的需求。 总结 本文总结了Java中栈和队列的几种实现方式: 栈的实现: 使用Java标准库中的Stack类 使用Deque接口中的LinkedList实现栈操作 自定义数组栈、链表栈、单链表栈、双链表栈 队列的实现: 使用Java标准库中的Queue接口及其实现类LinkedList、PriorityQueue 使用java.util.concurrent包下的阻塞队列 自定义使用数组或链表实现的队列","categories":[{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"}]},{"title":"hexo渲染的页面不支持mermaid语法","slug":"2023-10-16-hexo部署的页面不支持mermaid语法","date":"2023-10-15T22:09:15.568Z","updated":"2023-10-15T22:40:11.489Z","comments":true,"path":"2023/10/16/2023-10-16-hexo部署的页面不支持mermaid语法/","link":"","permalink":"http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/","excerpt":"","text":"mermaid 的介绍和使用请参考 这篇文章 和 官方文档。 hexo渲染的页面不支持mermaid语法问题 问题背景 在typora编写的Markdown文件能很好地渲染 mermaid 流程图，然而使用 hexo 部署后却不能渲染，只能显示出 mermaid 代码。 解决方案 从 hexo插件官网 找到对应的插件 hexo-filter-mermaid-diagrams，参照 hexo-filter-mermaid-diagrams 官方给出的环境配置方法进行配置。 安装插件 123yarn add hexo-filter-mermaid-diagrams// ornpm install hexo-filter-mermaid-diagrams 修改配置文件 同时修改根目录和themes目录下的 _config.yml 文件，加上以下内容： 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: \"7.1.2\" # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 在pug或js中包含mermaid.js 笔者使用的主题是 pure，在 themes\\pure\\layout\\_commons 路径下的 footer.ejs 中添加如下代码： 12345678&lt;% if (theme.mermaid.enable) { %&gt; &lt;script src='https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) { mermaid.initialize({theme: 'forest'}); } &lt;/script&gt;&lt;% } %&gt; 具体情况请参考 hexo-filter-mermaid-diagrams官方说明 。","categories":[{"name":"随机BUG","slug":"随机BUG","permalink":"http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"mermaid","slug":"mermaid","permalink":"http://example.com/tags/mermaid/"}]},{"title":"二叉树基本定义以及遍历方法","slug":"2023-10-16-二叉树基本概念与遍历方法","date":"2023-10-15T16:52:39.418Z","updated":"2023-10-20T06:44:51.934Z","comments":true,"path":"2023/10/16/2023-10-16-二叉树基本概念与遍历方法/","link":"","permalink":"http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"本文来自程序员Carl的 代码随想录。 [toc] 二叉树的基本定义 二叉树的种类 解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。 满二叉树 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树，如下图所示。 文章中使用了画图功能，使用方式参考 这篇文章， mermaid语法请参考 官方文档。 graph TD A--&gt;B A--&gt;C B--&gt;D B--&gt;E C--&gt;F C--&gt;G D--&gt;H D--&gt;I E--&gt;J E--&gt;K F--&gt;L F--&gt;M G--&gt;N G--&gt;O 完全二叉树 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。如下面的两个是完全二叉树： graph TD A--&gt;B A--&gt;C B--&gt;D B--&gt;E C--&gt;F C--&gt;G D--&gt;H D--&gt;I E--&gt;J graph TD A--&gt;B A--&gt;C B--&gt;D B--&gt;E C--&gt;F C--&gt;G D--&gt;H D--&gt;I E--&gt;J E--&gt;K 而下面一个就不是完全二叉树： graph TD A--&gt;B A--&gt;C B--&gt;D B--&gt;E C--&gt;F C--&gt;G D--&gt;H D--&gt;I E--&gt;Null E--&gt;K 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系 二叉搜索树 相比于前面介绍的没有数值的树，二叉搜索树是有数值的了，二叉搜索树是一个有序树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 例如下面这两棵树都是搜索树 graph TD 10--&gt;6 10--&gt;16 6--&gt;3 6--&gt;9 16--&gt;14 16--&gt;19 graph TD 10--&gt;6 10--&gt;Null 6--&gt;3 6--&gt;9 平衡二叉搜索树 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。例如： graph TD 10--&gt;6 10--&gt;16 6--&gt;3 6--&gt;9 graph TD 10--&gt;6 10--&gt;16 6--&gt;3 6--&gt;9 16--&gt;14 16--&gt;19 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是$log\\ n$， 注意这里不包括unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表 二叉树的存储方式 二叉树可以链式存储，也可以顺序存储。 那么链式存储方式就用指针， 顺序存储的方式就是用数组。 顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。 链式存储比较直观，即给每个节点设置左指针和有指针，分别指向左子树和右子树。 如何顺序存储呢？其实就是用数组来存储二叉树，顺序存储的方式如图： graph TD a--&gt;b a--&gt;c b--&gt;d b--&gt;e c--&gt;f c--&gt;g 对应的存储数组为：[a,b,c,d,e,f,g]，下标对应 0-6。 顺序存储的遍历方式： 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。 二叉树的遍历方式 注意总结做题的框架！！ 关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。 二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 这两种遍历是图论中最基本的两种遍历方式，后面在介绍图论的时候还会介绍到。 那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 在深度优先遍历中：有三个顺序，前中后序遍历。这里前中后，其实指的就是中间节点的遍历顺序，因此只需要记住： 前中后序指的就是中间节点的位置。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 例如对于下面的图，前中后序遍历的顺序依次是： 前序（DLR）：abdecfg 中序（LDR）：dbeafcg 后序（LRD）：debfgca graph TD a--&gt;b a--&gt;c b--&gt;d b--&gt;e c--&gt;f c--&gt;g 最后是二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。 前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。 而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树的代码实现 在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。 因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！ 1234567// C++代码struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; 1234567891011121314// java 代码public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }} 二叉树的递归遍历 递归的三要素 本部分将介绍前后中序的递归写法。首先确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！ 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 题目链接及题解 LC144_二叉树的前序遍历 确定递归函数的参数和返回值。预设代码给出了preorderTraversal函数，其参数为 TreeNode类型的root节点，返回List&lt;Integer&gt;类型。实现递归函数preorder，该函数主要实现对二叉树的遍历，并把遍历结果插入result向量中，返回值为void；参数需要两个：当前的结点和result向量 确定终止条件：当前结点为 null 时递归终止 单层递归逻辑：DLR 12345678910111213141516171819202122class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); preorder(root, result); return result; } // 确定参数：当前节点 和 result List // 返回值： void public void preorder(TreeNode curr, List&lt;Integer&gt; result){ // 终止条件 if(curr == null){ return; } // 单层递归逻辑：DLR result.add(curr.val); preorder(curr.left, result); preorder(curr.right, result); }} LC94_二叉树的中序遍历 原理&amp;思路同上一题 123456789101112131415161718class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); postorder(root, result); return result; } // LRD public void postorder(TreeNode curr, List&lt;Integer&gt; result){ if(curr == null){ return; } postorder(curr.left, result); postorder(curr.right, result); result.add(curr.val); }} LC145_二叉树的后序遍历 1234567891011121314151617class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorder(root, result); return result; } public void inorder(TreeNode curr, List&lt;Integer&gt; result){ if(curr == null){ return; } inorder(curr.left, result); result.add(curr.val); inorder(curr.right, result); }} BM24 二叉树的中序遍历 12345678910111213141516171819202122232425262728public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return int整型一维数组 */ public int[] inorderTraversal (TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorder(root, result); int[] resultArr = result.stream().mapToInt(i -&gt; i).toArray(); return resultArr; } public void inorder(TreeNode curr, List&lt;Integer&gt; result){ if(curr == null){ return; } inorder(curr.left, result); result.add(curr.val); inorder(curr.right, result); }} BM25 二叉树的后序遍历 BM23 二叉树的前序遍历 二叉树的迭代遍历 见 代码随想录。 迭代法遍历的基本原理 此部分建议细读 代码随想录-二叉树的迭代遍历 理解迭代遍历的基本原理。 统一迭代方法 迭代法实现的先中后序，其实风格并不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。 经过实践会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。 统一写法的基本思路是：将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。 如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法 12345678910111213141516171819202122232425// 前序class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; }} 12345678910111213141516171819202122232425// 中序class Solution {public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result;}} 12345678910111213141516171819202122232425// 后序class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; }} 二叉树的层序遍历 基本原理 层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。 而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。 使用队列实现二叉树广度优先遍历，动画如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 102.二叉树的层序遍历class Solution { public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { //checkFun01(root,0); checkFun02(root); return resList; } //DFS--递归方式 public void checkFun01(TreeNode node, Integer deep) { if (node == null) return; deep++; if (resList.size() &lt; deep) { //当层级增加时，list的Item也增加，利用list的索引值进行层级界定 List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;(); resList.add(item); } resList.get(deep - 1).add(node.val); checkFun01(node.left, deep); checkFun01(node.right, deep); } //BFS--迭代方式--借助队列 public void checkFun02(TreeNode node) { if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) { List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; } resList.add(itemList); } }} 题目链接 LC102. 二叉树的层序遍历； LC107. 二叉树的层序遍历 II； LC199. 二叉树的右视图；","categories":[{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Hello World","slug":"2023-10-15-hello-world","date":"2023-10-14T16:08:56.164Z","updated":"2023-10-14T16:04:19.185Z","comments":true,"path":"2023/10/15/2023-10-15-hello-world/","link":"","permalink":"http://example.com/2023/10/15/2023-10-15-hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"搭建GitHub Page-Jekyll篇","slug":"2023-10-13-搭建GitHub主页-jekyll篇","date":"2023-10-13T09:25:37.729Z","updated":"2023-10-20T06:46:27.904Z","comments":true,"path":"2023/10/13/2023-10-13-搭建GitHub主页-jekyll篇/","link":"","permalink":"http://example.com/2023/10/13/2023-10-13-%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/","excerpt":"","text":"一、概述 emoji 好看吗？这里 有很多哦 应该没有一个开发人员不向往有一个自己的个人网页吧？😏 这个主页怎么搭建呢？事实上，网络上有很多将搭建个人博客网站的项目，这样当然是好的，可是似乎需要自己搞一台服务器啊？如果服务器过期了，网站是不是就404了呢？🤔 那能不能不用自己租服务器，快乐当白嫖怪呢？GitHub表示：宝宝，还没想起来我吗？😤😘 不会前端咋办？当然是本着将白嫖进行到底的原则啦！看这里👉 Jekyll 模板👈。 二、Windows环境配置 Ruby (ruby -v) RubyGems (gem -v) Gcc &amp; make (gcc -v | g++ -v | make -v ) Git (git --version) 配置Gcc、make环境 参考： Gcc、g++安装； make安装。 安装 Ruby 和 Jekyll 参考 Jekyll 官方环境配置指南 。 通过 RubyInstaller 安装 Windows上安装Ruby和Jekyll最简单的方法是 RubyInstaller，RubyInstaller是一个基于windows的比较完备的安装程序，包括Ruby语言、执行环境、重要文档等等。 官方配置中介绍的是 RubyInstaller-2.4及更新版本，直接选择最新的安装包。 详细步骤： 从 RubyInstaller Downloads 下载并安装 Ruby+Devkit 版本。使用默认选项进行安装； 在安装向导的最后阶段运行 ridk install 步骤。这是安装带有本地扩展的 gem 所需要的。可以在 RubyInstaller Documentation 中找到更多相关信息。从选项中选择 MSYS2 and MINGW development tool chain ； 从开始菜单打开一个新的命令提示窗口，这样对 PATH 环境变量的更改就会生效。使用命令 gem Install Jekyll Bundler 安装Jekyll和Bundler； 注意：此处需将 Ruby gem的源换回国内源，清华镜像源操作方法。 查看Jekyll 是否正确安装：jekyll -v； RubyInstaller Downloads页面 安装向导完成页面 运行 ridk install ridk install 运行完成 检查Jekyll是否成功安装 通过bash安装 参考 Jekyll 官方环境配置指南 ，此处不再尝试 三、配置个人主页 根据自己选择的 Jekyll 模板，进行后续配置。以 Chirpy 模板为例。 1. 创建仓库 + 准备模板源码 首先创建名为 username.github.io 的远程仓库，并clone到本地。 ⚠ username不是你的昵称 or 你自己的名字。 ✔ username是你的github账户名，要严格保持一致 下载 Chripy 的源码，解压到clone的本地文件夹目录下，使用 bundle install 构建本地环境。 ⚠ 记住将 Gemfile 中的 source 替换为 清华镜像源。 2. 部署个人主页 修改配置文件 部署前，配置 _config.yml 中的 url，填写为仓库地址。 Before the deployment begins, check out the file_config.ymland make sure theurlis configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other thanGitHub Pages, remember to change thebaseurlto your project name that starts with a slash, e.g,/project-name. 使用Github Action部署个人主页。 首先在仓库设置页(Settings)-&gt;Pages-&gt;Build and deployment从下拉菜单中选择Github Actions。 Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar. Then, in the Source section (under Build and deployment), select GitHub Actions from the dropdown menu. 然后把本地修改commit并提交到Github远程仓库上，可以触发Github Action的Build and deployment工作流进行部署。如果没有自动触发，可以手动点击Build and Deploy进行部署。 Push any commits to GitHub to trigger the Actions workflow. In the Actions tab of your repository, you should see the workflow Build and Deploy running. Once the build is complete and successful, the site will be deployed automatically. 等待一段时间后，在 Actions 页查看部署情况。 可能的错误 (可选)手动构建和配置 不再演示，可参考 官方文档。 本地运行Jekyll项目 在项目路径下使用命令 bundle exec jekyll serve，即可在 Web 浏览器中导航到 http://localhost:4000 浏览本地项目。 参考文章 知乎-春枫禾旭 的博客； GitHub Page中文教程； Jekyll 模板主页； Jekyll 官方环境配置指南； Chirpy官方文档 ； emoji小基地","categories":[{"name":"工具库","slug":"工具库","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E5%BA%93/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]}],"categories":[{"name":"刷题日记","slug":"刷题日记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"},{"name":"Java手账本","slug":"Java手账本","permalink":"http://example.com/categories/Java%E6%89%8B%E8%B4%A6%E6%9C%AC/"},{"name":"随机BUG","slug":"随机BUG","permalink":"http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"工具库","slug":"工具库","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E5%BA%93/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Java线程","slug":"Java线程","permalink":"http://example.com/tags/Java%E7%BA%BF%E7%A8%8B/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"emoji","slug":"emoji","permalink":"http://example.com/tags/emoji/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"mermaid","slug":"mermaid","permalink":"http://example.com/tags/mermaid/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"}]}