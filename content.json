{"meta":{"title":"Liangshou","subtitle":"","description":"","author":"Liangshou","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"about","date":"2023-10-15T08:26:48.000Z","updated":"2023-10-15T08:26:48.224Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-10-15T08:28:18.437Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-10-15T06:26:40.586Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo渲染的页面不支持mermaid语法","slug":"2023-10-16-hexo部署的页面不支持mermaid语法","date":"2023-10-15T22:09:15.568Z","updated":"2023-10-15T22:23:41.298Z","comments":true,"path":"2023/10/16/2023-10-16-hexo部署的页面不支持mermaid语法/","link":"","permalink":"http://example.com/2023/10/16/2023-10-16-hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81mermaid%E8%AF%AD%E6%B3%95/","excerpt":"","text":"mermaid 的介绍和使用请参考 这篇文章 和 官方文档。 问题背景在typora编写的Markdown文件能很好地渲染 mermaid 流程图，然而使用 hexo 部署后却不能渲染，只能显示出 mermaid 代码。 解决方案从 hexo插件官网 找到对应的插件 hexo-filter-mermaid-diagrams，参照 hexo-filter-mermaid-diagrams 官方给出的环境配置方法进行配置。 安装插件 123yarn add hexo-filter-mermaid-diagrams// ornpm install hexo-filter-mermaid-diagrams 修改配置文件 同时修改根目录和themes目录下的 _config.yml 文件，加上以下内容： 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 在pug或js中包含mermaid.js 笔者使用的主题是 pure，在 themes\\pure\\layout\\_commons 路径下的 footer.ejs 中添加如下代码： 12345678&lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; 具体情况请参考 hexo-filter-mermaid-diagrams官方说明 。","categories":[{"name":"随机BUG","slug":"随机BUG","permalink":"http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"mermaid","slug":"mermaid","permalink":"http://example.com/tags/mermaid/"},{"name":"hexo-filter-mermaid-diagrams","slug":"hexo-filter-mermaid-diagrams","permalink":"http://example.com/tags/hexo-filter-mermaid-diagrams/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]},{"title":"二叉树基本定义以及遍历方法","slug":"2023-10-16-二叉树基本概念与遍历方法","date":"2023-10-15T16:52:39.418Z","updated":"2023-10-15T22:14:55.194Z","comments":true,"path":"2023/10/16/2023-10-16-二叉树基本概念与遍历方法/","link":"","permalink":"http://example.com/2023/10/16/2023-10-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"本文来自程序员Carl的 代码随想录。 [toc] 二叉树的基本定义二叉树的种类解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。 满二叉树满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树，如下图所示。 文章中使用了画图功能，使用方式参考 这篇文章， mermaid语法请参考 官方文档。 graph TD A-->B A-->C B-->D B-->E C-->F C-->G D-->H D-->I E-->J E-->K F-->L F-->M G-->N G-->O 完全二叉树完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。如下面的两个是完全二叉树： graph TD A-->B A-->C B-->D B-->E C-->F C-->G D-->H D-->I E-->J graph TD A-->B A-->C B-->D B-->E C-->F C-->G D-->H D-->I E-->J E-->K 而下面一个就不是完全二叉树： graph TD A-->B A-->C B-->D B-->E C-->F C-->G D-->H D-->I E-->Null E-->K 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系 二叉搜索树相比于前面介绍的没有数值的树，二叉搜索树是有数值的了，二叉搜索树是一个有序树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 例如下面这两棵树都是搜索树 graph TD 10-->6 10-->16 6-->3 6-->9 16-->14 16-->19 graph TD 10-->6 10-->Null 6-->3 6-->9 平衡二叉搜索树平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。例如： graph TD 10-->6 10-->16 6-->3 6-->9 graph TD 10-->6 10-->16 6-->3 6-->9 16-->14 16-->19 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是$log\\ n$， 注意这里不包括unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表 二叉树的存储方式二叉树可以链式存储，也可以顺序存储。 那么链式存储方式就用指针， 顺序存储的方式就是用数组。 顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。 链式存储比较直观，即给每个节点设置左指针和有指针，分别指向左子树和右子树。 如何顺序存储呢？其实就是用数组来存储二叉树，顺序存储的方式如图： graph TD a-->b a-->c b-->d b-->e c-->f c-->g 对应的存储数组为：[a,b,c,d,e,f,g]，下标对应 0-6。 顺序存储的遍历方式： 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。 二叉树的遍历方式 注意总结做题的框架！！ 关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。 二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 这两种遍历是图论中最基本的两种遍历方式，后面在介绍图论的时候还会介绍到。 那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 在深度优先遍历中：有三个顺序，前中后序遍历。这里前中后，其实指的就是中间节点的遍历顺序，因此只需要记住： 前中后序指的就是中间节点的位置。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 例如对于下面的图，前中后序遍历的顺序依次是： 前序（DLR）：abdecfg 中序（LDR）：dbeafcg 后序（LRD）：debfgca graph TD a-->b a-->c b-->d b-->e c-->f c-->g 最后是二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。 前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。 而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树的代码实现 在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。 因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！ 1234567// C++代码struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; 1234567891011121314// java 代码public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 二叉树的递归遍历递归的三要素本部分将介绍前后中序的递归写法。首先确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！ 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 题目链接及题解 LC144_二叉树的前序遍历 确定递归函数的参数和返回值。预设代码给出了preorderTraversal函数，其参数为 TreeNode类型的root节点，返回List&lt;Integer&gt;类型。实现递归函数preorder，该函数主要实现对二叉树的遍历，并把遍历结果插入result向量中，返回值为void；参数需要两个：当前的结点和result向量 确定终止条件：当前结点为 null 时递归终止 单层递归逻辑：DLR 12345678910111213141516171819202122class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); preorder(root, result); return result; &#125; // 确定参数：当前节点 和 result List // 返回值： void public void preorder(TreeNode curr, List&lt;Integer&gt; result)&#123; // 终止条件 if(curr == null)&#123; return; &#125; // 单层递归逻辑：DLR result.add(curr.val); preorder(curr.left, result); preorder(curr.right, result); &#125;&#125; LC94_二叉树的中序遍历 原理&amp;思路同上一题 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); postorder(root, result); return result; &#125; // LRD public void postorder(TreeNode curr, List&lt;Integer&gt; result)&#123; if(curr == null)&#123; return; &#125; postorder(curr.left, result); postorder(curr.right, result); result.add(curr.val); &#125;&#125; LC145_二叉树的后序遍历 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorder(root, result); return result; &#125; public void inorder(TreeNode curr, List&lt;Integer&gt; result)&#123; if(curr == null)&#123; return; &#125; inorder(curr.left, result); result.add(curr.val); inorder(curr.right, result); &#125;&#125; BM24 二叉树的中序遍历 12345678910111213141516171819202122232425262728public class Solution &#123; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return int整型一维数组 */ public int[] inorderTraversal (TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inorder(root, result); int[] resultArr = result.stream().mapToInt(i -&gt; i).toArray(); return resultArr; &#125; public void inorder(TreeNode curr, List&lt;Integer&gt; result)&#123; if(curr == null)&#123; return; &#125; inorder(curr.left, result); result.add(curr.val); inorder(curr.right, result); &#125;&#125; BM25 二叉树的后序遍历 BM23 二叉树的前序遍历 二叉树的迭代遍历 见 代码随想录。 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。可以用递归的一般都可以有等效的迭代的方法。 前序遍历（迭代法）前序遍历是 DLR ，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。 为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。 动画如下： 12345678910111213141516171819202122// 前序遍历顺序：中-左-右，入栈顺序：中-右-左class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null)&#123; return result; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; TreeNode node = stack.pop(); result.add(node.val); if (node.right != null)&#123; stack.push(node.right); &#125; if (node.left != null)&#123; stack.push(node.left); &#125; &#125; return result; &#125;&#125; 中序遍历（迭代法）因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。 那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。 那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 动画如下： 12345678910111213141516171819202122// 中序遍历顺序: 左-中-右 入栈顺序： 左-右class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null)&#123; return result; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty())&#123; if (cur != null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123; cur = stack.pop(); result.add(cur.val); cur = cur.right; &#125; &#125; return result; &#125;&#125; 后序遍历（迭代法）先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了 1234567891011121314151617181920212223// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null)&#123; return result; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; TreeNode node = stack.pop(); result.add(node.val); if (node.left != null)&#123; stack.push(node.left); &#125; if (node.right != null)&#123; stack.push(node.right); &#125; &#125; Collections.reverse(result); return result; &#125;&#125; 统一迭代方法迭代法实现的先中后序，其实风格并不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。 经过实践会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。 12345678910111213141516171819202122232425// 前序class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.peek(); if (node != null) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425// 中序class Solution &#123;public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.peek(); if (node != null) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 &#125; &#125; return result;&#125;&#125; 12345678910111213141516171819202122232425// 后序class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.peek(); if (node != null) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 &#125; &#125; return result; &#125;&#125; 二叉树的层序遍历层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。 需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。 而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。 使用队列实现二叉树广度优先遍历，动画如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 102.二叉树的层序遍历class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; //checkFun01(root,0); checkFun02(root); return resList; &#125; //DFS--递归方式 public void checkFun01(TreeNode node, Integer deep) &#123; if (node == null) return; deep++; if (resList.size() &lt; deep) &#123; //当层级增加时，list的Item也增加，利用list的索引值进行层级界定 List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;(); resList.add(item); &#125; resList.get(deep - 1).add(node.val); checkFun01(node.left, deep); checkFun01(node.right, deep); &#125; //BFS--迭代方式--借助队列 public void checkFun02(TreeNode node) &#123; if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) &#123; List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) &#123; TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; &#125; resList.add(itemList); &#125; &#125;&#125;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-10-14T16:08:56.164Z","updated":"2023-10-14T16:04:19.185Z","comments":true,"path":"2023/10/15/hello-world/","link":"","permalink":"http://example.com/2023/10/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"搭建GitHub Page-Jekyll篇","slug":"搭建GitHub主页-jekyll篇","date":"2023-10-13T09:25:37.729Z","updated":"2023-10-15T09:13:37.404Z","comments":true,"path":"2023/10/13/搭建GitHub主页-jekyll篇/","link":"","permalink":"http://example.com/2023/10/13/%E6%90%AD%E5%BB%BAGitHub%E4%B8%BB%E9%A1%B5-jekyll%E7%AF%87/","excerpt":"","text":"一、概述 emoji 好看吗？这里 有很多哦 应该没有一个开发人员不向往有一个自己的个人网页吧？:smirk: 这个主页怎么搭建呢？事实上，网络上有很多将搭建个人博客网站的项目，这样当然是好的，可是似乎需要自己搞一台服务器啊？如果服务器过期了，网站是不是就404了呢？:thinking: 那能不能不用自己租服务器，快乐当白嫖怪呢？GitHub表示：宝宝，还没想起来我吗？:triumph::kissing_heart: 不会前端咋办？当然是本着将白嫖进行到底的原则啦！看这里:point_right: Jekyll 模板:point_left:。 二、Windows环境配置 Ruby (ruby -v) RubyGems (gem -v) Gcc &amp; make (gcc -v | g++ -v | make -v ) Git (git –version) 配置Gcc、make环境 参考： Gcc、g++安装； make安装。 安装 Ruby 和 Jekyll 参考 Jekyll 官方环境配置指南 。 通过 RubyInstaller 安装Windows上安装Ruby和Jekyll最简单的方法是 RubyInstaller，RubyInstaller是一个基于windows的比较完备的安装程序，包括Ruby语言、执行环境、重要文档等等。 官方配置中介绍的是 RubyInstaller-2.4及更新版本，直接选择最新的安装包。 详细步骤： 从 RubyInstaller Downloads 下载并安装 Ruby+Devkit 版本。使用默认选项进行安装； 在安装向导的最后阶段运行 ridk install 步骤。这是安装带有本地扩展的 gem 所需要的。可以在 RubyInstaller Documentation 中找到更多相关信息。从选项中选择 MSYS2 and MINGW development tool chain ； 从开始菜单打开一个新的命令提示窗口，这样对 PATH 环境变量的更改就会生效。使用命令 gem Install Jekyll Bundler 安装Jekyll和Bundler； 注意：此处需将 Ruby gem的源换回国内源，清华镜像源操作方法。 查看Jekyll 是否正确安装：jekyll -v； RubyInstaller Downloads页面 安装向导完成页面 运行 ridk install ridk install 运行完成 检查Jekyll是否成功安装 通过bash安装 参考 Jekyll 官方环境配置指南 ，此处不再尝试 三、配置个人主页根据自己选择的 Jekyll 模板，进行后续配置。以 Chirpy 模板为例。 1. 创建仓库 + 准备模板源码首先创建名为 username.github.io 的远程仓库，并clone到本地。 :warning: username不是你的昵称 or 你自己的名字。 :heavy_check_mark: username是你的github账户名，要严格保持一致 下载 Chripy 的源码，解压到clone的本地文件夹目录下，使用 bundle install 构建本地环境。 :warning: 记住将 Gemfile 中的 source 替换为 清华镜像源。 2. 部署个人主页修改配置文件部署前，配置 _config.yml 中的 url，填写为仓库地址。 Before the deployment begins, check out the file_config.ymland make sure theurlis configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other thanGitHub Pages, remember to change thebaseurlto your project name that starts with a slash, e.g,/project-name. 使用Github Action部署个人主页。 首先在仓库设置页(Settings)-&gt;Pages-&gt;Build and deployment从下拉菜单中选择Github Actions。 Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar. Then, in the Source section (under Build and deployment), select GitHub Actions from the dropdown menu. 然后把本地修改commit并提交到Github远程仓库上，可以触发Github Action的Build and deployment工作流进行部署。如果没有自动触发，可以手动点击Build and Deploy进行部署。 Push any commits to GitHub to trigger the Actions workflow. In the Actions tab of your repository, you should see the workflow Build and Deploy running. Once the build is complete and successful, the site will be deployed automatically. 等待一段时间后，在 Actions 页查看部署情况。 可能的错误 (可选)手动构建和配置 不再演示，可参考 官方文档。 本地运行Jekyll项目在项目路径下使用命令 bundle exec jekyll serve，即可在 Web 浏览器中导航到 http://localhost:4000 浏览本地项目。 参考文章 知乎-春枫禾旭 的博客； GitHub Page中文教程； Jekyll 模板主页； Jekyll 官方环境配置指南； Chirpy官方文档 ； emoji小基地","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://example.com/categories/GitHub/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"}]}],"categories":[{"name":"随机BUG","slug":"随机BUG","permalink":"http://example.com/categories/%E9%9A%8F%E6%9C%BABUG/"},{"name":"刷题笔记","slug":"刷题笔记","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"GitHub","slug":"GitHub","permalink":"http://example.com/categories/GitHub/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"mermaid","slug":"mermaid","permalink":"http://example.com/tags/mermaid/"},{"name":"hexo-filter-mermaid-diagrams","slug":"hexo-filter-mermaid-diagrams","permalink":"http://example.com/tags/hexo-filter-mermaid-diagrams/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"NowCoder","slug":"NowCoder","permalink":"http://example.com/tags/NowCoder/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"}]}